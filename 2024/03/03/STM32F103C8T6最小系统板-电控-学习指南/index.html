

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon_cat.png">
  <link rel="icon" href="/img/icon_cat.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yunru Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="学习stm32的基本开发笔记~">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32F103C8T6最小系统板(电控)学习指南">
<meta property="og:url" content="http://zoechen04616.github.io/2024/03/03/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="学习stm32的基本开发笔记~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p47.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p1.jpg">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p2.jpg">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p55.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p2.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p3.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p49.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p50.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p1.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p4.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p5.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p51.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p6.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p8.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p7.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p9.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p10.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p11.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p12.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p13.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p52.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p53.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p54.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p57.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p14.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p18.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p15.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p16.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p17.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p19.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p20.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p21.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p22.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p23.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p24.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p25.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p26.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p27.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p28.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p29.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p30.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p31.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p35.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p32.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p33.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p34.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p36.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p37.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p38.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p39.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p40.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p41.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p42.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p43.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p44.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p46.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p45.png">
<meta property="og:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p48.png">
<meta property="article:published_time" content="2024-03-03T14:52:40.000Z">
<meta property="article:modified_time" content="2025-01-19T17:47:55.964Z">
<meta property="article:author" content="Yunru Chen">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://zoechen04616.github.io/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p47.png">
  
  
  
  <title>STM32F103C8T6最小系统板(电控)学习指南 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zoechen04616.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":false,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":21845181,"cnzz":null,"leancloud":{"app_id":"Zq01YuoCcS34rK55Lminokne-gzGzoHsz","app_key":"Ua2GYZwL65Ms3X2yTxREFwuk","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  
    <!-- 51.la Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('//js.users.51.la/21845181.js');
      }
    </script>
  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>My Blogs</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="http://localhost:4000/admin/">
                <i class="iconfont icon-link-fill"></i>
                <span>CodeCloud</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E7%99%BD%E5%A4%A9.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="STM32F103C8T6最小系统板(电控)学习指南"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-03 22:52" pubdate>
          2024年3月3日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          160 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">STM32F103C8T6最小系统板(电控)学习指南</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2025年1月20日 凌晨
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>学习stm32的基本开发笔记~</p>
<span id="more"></span> 
<h1 id="学习一下这块最小系统板"><a href="#学习一下这块最小系统板" class="headerlink" title="学习一下这块最小系统板"></a>学习一下这块最小系统板</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669325586">不错的讲解，点这里</a></p>
<h2 id="Stm32F103C8T6的常用引脚"><a href="#Stm32F103C8T6的常用引脚" class="headerlink" title="Stm32F103C8T6的常用引脚"></a>Stm32F103C8T6的常用引脚</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nolate_chen/article/details/132359815?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170964934116800227461640%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170964934116800227461640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-132359815-null-null.142%5Ev99%5Epc_search_result_base5&utm_term=stm32f103c8t6%E5%BC%95%E8%84%9A%E5%8A%9F%E8%83%BD&spm=1018.2226.3001.4187">STM32F103C8T6引脚功能整理</a></p>
<ol>
<li>通用I&#x2F;O口</li>
</ol>
<ul>
<li><p>PA0-PA15： 16个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断、模拟输入等。</p>
</li>
<li><p>PB0-PB15： 16个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断、模拟输入等。</p>
</li>
<li><p>PC13-PC15： 3个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p>
</li>
<li><p>PD0-PD2： 3个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p>
</li>
<li><p>PE0-PE5： 6个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p>
</li>
<li><p>PF0-PF1： 2个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p>
</li>
</ul>
<ol start="2">
<li>晶振引脚</li>
</ol>
<ul>
<li>3456号引脚口，时钟晶振引脚口，</li>
<li>PC14-OSC32_IN，PC15-OSC32_OUT，32.768kHz的晶振</li>
<li>OSC_IN ，OSC_OUT，8MHz的晶振。主晶振。</li>
</ul>
<ol start="3">
<li>下载端口</li>
</ol>
<ul>
<li>PA13:JTMS&#x2F;SWDIO </li>
<li>PA14:JTCK&#x2F;SWCLK</li>
</ul>
<ol start="4">
<li>串口</li>
</ol>
<ul>
<li>PA9,PA10：USART1_TX，USART1_RX</li>
<li>PA2,PA3：USART2_TX，USART2_RX</li>
</ul>
<ol start="5">
<li>IIC</li>
</ol>
<ul>
<li>PB6,PB7：I2C1_SCL，I2C1_SDA</li>
<li>PB10,PB11：I2C2_SCL，I2C2_SDA</li>
</ul>
<ol start="6">
<li>SPI</li>
</ol>
<ul>
<li>PA4，SPI1 NSS；PA5，SPI1 SCK，PA6，SPI1 MISO；PA7，SPI1 MOSI</li>
<li>PA12，SPI2 NSS；PA13，SPI2 SCK，PA14，SPI2 MISO；PA15，SPI2 MOSI</li>
</ul>
<h1 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h1><p>简单的说，面包板是一种电子实验用品，表面是打孔的塑料，底部有金属条，电子元器件按照一定规则插上即可使用无需焊接。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p47.png" srcset="/img/loading.gif" lazyload alt="面包板"></p>
<p><a target="_blank" rel="noopener" href="http://www.taichi-maker.com/homepage/reference-index/circuit-reference-index/breadboard/">面包板的讲解和使用方法</a></p>
<center class="half">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p1.jpg" srcset="/img/loading.gif" lazyload width="325/">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p2.jpg" srcset="/img/loading.gif" lazyload width="300/">
</center>

<h1 id="STM32CubeMX配置"><a href="#STM32CubeMX配置" class="headerlink" title="STM32CubeMX配置"></a>STM32CubeMX配置</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48896613/article/details/127243070">不错的教程，点这里</a></p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol>
<li>打开STM32CubeMX，单击ACCESS TO MCU SELECTOR</li>
<li>选择STM32F103C8T6芯片,创建project</li>
<li>进入配置界面后单击System Core（系统的核心） → SYS → Debug → Serial Wire</li>
<li>单击System Core（系统的核心） → RCC（配置晶振） → High speed Clock(HSE)（高速晶振）→ Crystal&#x2F;Ceramic Resonator（外部晶振，8M）</li>
</ol>
<ul>
<li>如果这里选Disable则无法使用外部高速晶振，这时PD0与PD1被用来做晶振的接口，如果不配置则可以把PD0、PD1当做普通IO口使用（新手建议还是进行配置）</li>
</ul>
<ol start="5">
<li>单击Clock Configuration在这里输入72，按下回车 → OK，自动配置时钟频率为72Mhz</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/555632154">配置STM32外部时钟源</a></p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p55.png" srcset="/img/loading.gif" lazyload alt="配置外部时钟源"></p>
<h2 id="需求配置（GPIO），以点灯为例"><a href="#需求配置（GPIO），以点灯为例" class="headerlink" title="需求配置（GPIO），以点灯为例"></a>需求配置（GPIO），以点灯为例</h2><ol start="6">
<li>依次单击Pinout &amp; Configuration → System Core → <code>GPIO</code> →右边的PC13（点灯） → GPIO_Output</li>
</ol>
<ul>
<li>根据电路图，PC13应为输出<code>高电平</code>，即3.3V时，LED灯<code>熄灭</code>，0V<code>低电平</code>时LED灯<code>亮</code>，交替输出可以实现闪烁的效果。</li>
<li>GPIO_Input，为输入模式，可读取当前引脚的电平状态，该电平一般是由外部驱动的。<br>GPIO_Output为输出模式，意味着可控制当前引脚的电平状态。</li>
</ul>
<ol start="7">
<li>继续配置PC13</li>
</ol>
<ul>
<li>设置GPIO output level：初始化电平，根据LED灯电路图，初始化输出低电平，灯亮。</li>
<li>设置GPIO mode 为：Output Push Pull(推挽输出)</li>
<li>设置 “既不上拉也不下拉”</li>
<li>输出最大速度默认为LOW</li>
<li>使用user label对该引脚进行别名，方便编程时区分和引用</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p2.png" srcset="/img/loading.gif" lazyload alt="PC13配置"></p>
<h2 id="项目和代码生成"><a href="#项目和代码生成" class="headerlink" title="项目和代码生成"></a>项目和代码生成</h2><p>单击Project Manager → Project ，配置准备要生成的工程</p>
<ul>
<li>工程名不能为中文，开头不能用数字</li>
<li>工程路径也不能包含中文</li>
<li>程序结构选basic即可，Advanced为高级的，工程会很大</li>
<li>IDE选择MDK-ARM</li>
<li>设置Code Generator</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p3.png" srcset="/img/loading.gif" lazyload alt="设置Code Generator"></p>
<p>上述的配置都设置好后就可以单击右上角的GENERATE CODE生成工程了。</p>
<ul>
<li>可直接Open Project，cubeMX会打开keil。</li>
</ul>
<h3 id="如果使用Stm32CubeIDE"><a href="#如果使用Stm32CubeIDE" class="headerlink" title="如果使用Stm32CubeIDE"></a>如果使用Stm32CubeIDE</h3><p>更简单了，设置好芯片之后，<code>Ctrl+S</code>保存配置，IDE会自动生成初始代码，并跳转到main.c页面。编写好代码之后，点击顶栏的<code>小锤子</code>进行编译。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p49.png" srcset="/img/loading.gif" lazyload alt="CubeIDE的代码页面"></p>
<h4 id="可能遇到的一些问题："><a href="#可能遇到的一些问题：" class="headerlink" title="可能遇到的一些问题："></a>可能遇到的一些问题：</h4><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014798590/article/details/126655017">STM32CubeIDE更新STLINK驱动失败</a></li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p50.png" srcset="/img/loading.gif" lazyload alt="使用STM32 ST-LINK utility进行驱动更新"></p>
<ol start="2">
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46695934/article/details/108474195">Please choose another workspace as ‘E:&#x2F;eclipse-workspace‘ is currently in use.</a></li>
</ol>
<ul>
<li>删掉该workspace目录下隐藏文件.metadata中的.lock文件</li>
</ul>
<h4 id="如何批量注释代码"><a href="#如何批量注释代码" class="headerlink" title="如何批量注释代码"></a>如何批量注释代码</h4><p>加入&#x2F;&#x2F;的方法，整行或者多行选中，按键<code>Ctrl + 按键/</code></p>
<h1 id="点灯——基础版"><a href="#点灯——基础版" class="headerlink" title="点灯——基础版"></a>点灯——基础版</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangshengwei230612/article/details/104419697">参考教程</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/516662177#:~:text=%E6%9C%AC%E6%96%87%E4%B8%AD%E7%9A%84%E7%82%B9%E7%81%AF%EF%BC%8C%E6%98%AF%E6%8C%87%E7%94%A8STM32%E5%8D%95%E7%89%87%E6%9C%BA%E7%82%B9%E4%BA%AE%E4%B8%8E%E4%B9%8B%E8%BF%9E%E6%8E%A5%E7%9A%84LED%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82%20%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BLED%E8%BF%99%E7%A7%8D%E5%99%A8%E4%BB%B6%EF%BC%8C%E5%AE%9E%E7%89%A9%E5%9B%BE%E5%A6%82%E4%B8%8B%E3%80%82,LED%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E7%82%B9%E7%81%AF%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B0%B1%E6%98%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8STM32%E6%8E%A7%E5%88%B6%E4%B8%80%E4%B8%AA%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%94%B5%E8%B7%AF%E3%80%82%20%E5%B8%82%E5%9C%BA%E4%B8%8A%E5%90%84%E7%B1%BBLED%EF%BC%88%E7%9B%B4%E6%8F%92%E5%BC%8F%2F%E8%B4%B4%E7%89%87%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%9A%84LED%EF%BC%8C%E9%83%BD%E6%9C%89%E7%82%B9%E5%8C%BA%E5%88%AB%EF%BC%89%E5%9C%A8%E5%AF%BC%E9%80%9A%E6%97%B6%E7%9A%84%E5%8E%8B%E9%99%8D%E4%B8%80%E8%88%AC%E5%9C%A81.8~3.3V%E3%80%82">点灯的原理</a></p>
<p>由该最小系统板的原理图可知，PC13自带可编程普通LED灯,板载LED灯的电路：</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p1.png" srcset="/img/loading.gif" lazyload alt="板载LED灯"></p>
<h2 id="Keli5编写代码"><a href="#Keli5编写代码" class="headerlink" title="Keli5编写代码"></a>Keli5编写代码</h2><p>打开工程后，进入Keli5软件，依次打开工程结构树，双击main.c开始写源码</p>
<ul>
<li>切忌：一定要在<code>BEGIN END</code>里写代码，不然后面STM32CubeMX重新配置生成代码, 会删除BEGIN END外面的代码</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p4.png" srcset="/img/loading.gif" lazyload alt="keil5界面"></p>
<ul>
<li><p>找到Drivers文件夹里的stm32f1xx_hal_gpio.c（双击打开），找到第465行的HAL_GPIO_WritrPin函数，复制其函数名，并在main方法里的wihile(1)调用</p>
<ul>
<li>注意使用了别名LED0后，可直接在里面传入参数<code>LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET</code><ul>
<li>参数1：GPIO端口；<br>  参数2：GPIO引脚；<br>  参数3：输出电平，使LED灯亮，输出低电平</li>
<li>GPIO_PIN_RESET :   代表低电平</li>
<li>GPIO_PIN_SET :   代表高电平</li>
</ul>
</li>
</ul>
</li>
<li><p>左上角编译，0错误，0警告</p>
</li>
</ul>
<h2 id="CubeIDE-编写代码"><a href="#CubeIDE-编写代码" class="headerlink" title="CubeIDE 编写代码"></a>CubeIDE 编写代码</h2><p>使用<code>Alt+/</code>可以打开代码提示，方便查找需要的函数。</p>
<h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul>
<li><p>void <code>HAL_GPIO_TogglePin</code>(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)：<br>这个函数用于<code>反转（切换）指定的GPIO引脚的输出状态</code>。它的参数包括：</p>
<ul>
<li>GPIOx：GPIO端口的基址，指明要操作的GPIO端口（如GPIOA、GPIOB等）。</li>
<li>GPIO_Pin：指定要反转状态的GPIO引脚（可以是一个或多个引脚的位域）。<ul>
<li>例如，如果之前引脚是高电平，调用这个函数后引脚将变为低电平，反之亦然。</li>
</ul>
</li>
<li>由于系统运行太快，想看到LED灯闪烁，要加上延时函数：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> `HAL_Delay`(<span class="hljs-built_in">uint32</span>_t Delay)<br></code></pre></td></tr></table></figure>
  此函数为<code>毫秒级延时</code>。如果想要指定间隔时间控制LED灯的亮灭，也是使用这个延时函数。</li>
</ul>
</li>
<li><p>void <code>HAL_GPIO_WritePin</code>(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)：<br>这个函数用于<code>设置指定GPIO引脚的输出状态</code>。它的参数包括：</p>
<ul>
<li>GPIOx：GPIO端口的基址，指明要操作的GPIO端口（如GPIOA、GPIOB等）。</li>
<li>GPIO_Pin：指定要设置状态的GPIO引脚（可以是一个或多个引脚的位域）。<br>   -PinState：指定要设置的状态，可以是 GPIO_PIN_SET（设置为高电平）或 GPIO_PIN_RESET（设置为低电平）。</li>
</ul>
</li>
<li><p>一种走马灯的思路设计：<br>(设置状态机，通过不同状态if的设置达到多个小灯交替变换的效果，一个周期结束之后，状态清零，继续while循环)</p>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p5.png" srcset="/img/loading.gif" lazyload alt="走马灯"></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p.png" srcset="/img/loading.gif" lazyload alt="build成功"></p>
<h2 id="程序烧录"><a href="#程序烧录" class="headerlink" title="程序烧录"></a>程序烧录</h2><p>（之前用的keli5，后面换平台了）<br>这里记录的是使用CubeIDE平台，通过stlink进行程序烧录。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p51.png" srcset="/img/loading.gif" lazyload alt="程序烧录成功"></p>
<h1 id="点灯——按键控制"><a href="#点灯——按键控制" class="headerlink" title="点灯——按键控制"></a>点灯——按键控制</h1><p>此项目是为了学习GPIO的输入： <code>GPIO_Input</code></p>
<h2 id="关于按键——通过轮询方式读取GPIO状态"><a href="#关于按键——通过轮询方式读取GPIO状态" class="headerlink" title="关于按键——通过轮询方式读取GPIO状态"></a>关于按键——通过轮询方式读取GPIO状态</h2><ol>
<li>关于<code>按键消抖</code>：</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p6.png" srcset="/img/loading.gif" lazyload alt="并联电容实现按键消抖"></p>
<ul>
<li>上述是属于<code>硬件消抖</code>，但是为了以防万一，一般还会进行<code>软件消抖</code>——进行Delay，一般为10ms。</li>
</ul>
<ol start="2">
<li>关于<code>上拉</code>：使用电源使GPIO口处的电平拉高。</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p8.png" srcset="/img/loading.gif" lazyload alt="上拉操作"></p>
<center class="half">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p7.png" srcset="/img/loading.gif" lazyload width="330/">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p9.png" srcset="/img/loading.gif" lazyload width="300/">
</center>

<ul>
<li>对于上拉电路：<ul>
<li>按键摁下——低电平</li>
<li>按键松开——高电平</li>
</ul>
</li>
</ul>
<ol start="3">
<li>关于<code>下拉</code>:使用电源使GPIO口处的电平拉低。</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p10.png" srcset="/img/loading.gif" lazyload alt="上拉电路和下拉电路"></p>
<ul>
<li>对于下拉电路：<ul>
<li>按键摁下——高电平</li>
<li>按键松开——低电平</li>
</ul>
</li>
</ul>
<ol start="4">
<li>stm32内置了上拉和下拉电阻：<br>默认为<code>no-pull-up and no-pull-down</code> :浮空输入模式</li>
</ol>
<ul>
<li>上拉输入模式：Pull-up</li>
<li>下拉输入模式：Pull-down</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p11.png" srcset="/img/loading.gif" lazyload alt="stm32内置GPIO上拉输入和下拉输入"></p>
<h2 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h2><ol>
<li><code>GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code></li>
</ol>
<ul>
<li>参数：<ul>
<li>GPIOx：GPIO 控制器的基址，例如 GPIOA、GPIOB 等。</li>
<li>GPIO_Pin：要读取状态的 GPIO 引脚，可以使用宏定义，如 GPIO_PIN_0、GPIO_PIN_1 等。</li>
</ul>
</li>
<li>返回值：<br>返回值类型为 GPIO_PinState，该类型是一个枚举类型，有两个可能的值：<ul>
<li>GPIO_PIN_RESET：引脚处于低电平状态。</li>
<li>GPIO_PIN_SET：引脚处于高电平状态。</li>
</ul>
</li>
</ul>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">GPIO_PinState pinState;<br>pinState = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);<br><span class="hljs-keyword">if</span>(pinState == GPIO_PIN_SET) &#123;<br>    <span class="hljs-regexp">//</span> 如果引脚处于高电平状态，则执行相应操作<br>    <span class="hljs-regexp">//</span>例如：熄灭小灯<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> 如果引脚处于低电平状态，则执行相应操作<br>    <span class="hljs-regexp">//</span>例如：点亮小灯<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>按键反转小灯亮灭：</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p12.png" srcset="/img/loading.gif" lazyload alt="stm32内置GPIO上拉输入和下拉输入"></p>
<p>需要添加按键摁下时等待，否则小灯会一直在while循环中从低电平被拉到高电平，然后又由于按键下拉成为低电平。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p13.png" srcset="/img/loading.gif" lazyload alt="stm32内置GPIO上拉输入和下拉输入"></p>
<h2 id="使用矩阵式键盘模块"><a href="#使用矩阵式键盘模块" class="headerlink" title="使用矩阵式键盘模块"></a>使用矩阵式键盘模块</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p52.png" srcset="/img/loading.gif" lazyload alt="博主使用的矩阵式键盘模块实物图"></p>
<p>矩阵按键扫描原理：</p>
<ul>
<li>先是把列(<code>col</code>)置0（推挽输出），行是输入上拉，扫描行得到行的键值；</li>
<li>再是把行(<code>row</code>)置0（推完输出），列是输入上拉，扫描列得到列的键值；</li>
<li>最后把行列的键值相加得到最后的总的键值。</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p53.png" srcset="/img/loading.gif" lazyload alt="矩阵式键盘模块原理图"></p>
<h3 id="关于GPIO配置"><a href="#关于GPIO配置" class="headerlink" title="关于GPIO配置"></a>关于GPIO配置</h3><p>4个引脚配推挽输出，这4个配输出的引脚内部上下拉不用配置；另外4个配成输入，内部上拉。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p54.png" srcset="/img/loading.gif" lazyload alt="矩阵式键盘模块GPIO配置"></p>
<p>在key.h里面对硬件的引脚进行define，方便后面代码的书写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx_hal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gpio.h&quot;</span>   <span class="hljs-comment">//这里如果不引入gpio.h，会出现报错显示引脚标签为没有定义的变量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span>     _KEY_BOARD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     _KEY_BOARD_H_</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PORT          GPIOD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK_FUN       RCC_APB2PeriphClockCmd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK           RCC_APB2Periph_GPIOD</span><br><br><br><span class="hljs-comment">//line    行</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN0           KEY_col0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN1           KEY_col1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN2           KEY_col2_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN3           KEY_col3_Pin</span><br><br><br><br><span class="hljs-comment">//row      列</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN4           KEY_row0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN5           KEY_row1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN6           KEY_row2_Pin</span><br><br><br><span class="hljs-comment">//extern uint8_t Send_F;</span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">Keyboard_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title">keyboard_scan</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>具体的函数实现在key.c文件中，具体的调用方法参见库函数整理的那一篇博客。</p>
<h1 id="关于GPIO的内部电路原理"><a href="#关于GPIO的内部电路原理" class="headerlink" title="关于GPIO的内部电路原理"></a>关于GPIO的内部电路原理</h1><h2 id="GPIO功能描述"><a href="#GPIO功能描述" class="headerlink" title="GPIO功能描述"></a>GPIO功能描述</h2><p>每个GPI&#x2F;O端口有:<br>两个32位<code>配置寄存器</code>(GPIOx_CRL，GPIOx_CRH)，两个32位<code>数据寄存器</code>(GPIOx_IDR和GPIOx_ODR)，一个<code>32位置位/复位寄存器</code>(GPIOx_BSRR)，一个<code>16位复位寄存器</code>(GPIOx_BRR)和一个<code>32位锁定寄存器</code>(GPIOx_LCKR)。<br>根据数据手册中列出的每个I&#x2F;O端口的特定硬件特征， GPIO端口的每个位可以由软件分别配置成多种模式。</p>
<ul>
<li>输入浮空</li>
<li>输入上拉</li>
<li>输入下拉</li>
<li>模拟输入</li>
<li>开漏输出</li>
<li>推挽式输出</li>
<li>推挽式复用功能</li>
<li>开漏复用功能</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p57.png" srcset="/img/loading.gif" lazyload alt="GPIO口读取高低电平原理"></p>
<ul>
<li>模拟输入，读取的是具体数值，没有经过施密特触发器处理。</li>
<li>数字输入和复用输入都是读取的高低电平（经过施密特触发器过滤处理）</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p14.png" srcset="/img/loading.gif" lazyload alt="I/O端口位的基本结构"></p>
<p>1.输出驱动器： <br>主要配置<code>开漏输出</code>和<code>推挽输出</code>。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p18.png" srcset="/img/loading.gif" lazyload alt="开漏输出和推挽输出区别"></p>
<ul>
<li>推挽输出：<br>该模式需要P-MOS和N-MOS协同作用。</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p15.png" srcset="/img/loading.gif" lazyload alt="推挽输出-输出高电平"></p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p16.png" srcset="/img/loading.gif" lazyload alt="推挽输出-输出低电平"></p>
<ul>
<li>开漏输出：<br>当外设元器件需要的电压不是3.3V时，可以使用开漏输出，此时只有N-MOS工作，外接GND变为器件需要的工作电压VCC。<ul>
<li>开漏输出必须依靠外接的电压源来进行驱动，当外接电压大于3.3V时，需要选择<code>5V容忍</code>的I&#x2F;O口。</li>
<li>当要求I&#x2F;O口输出低电平时，N-MOS断开，反之则N-MOS连接GND为0V。</li>
</ul>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p17.png" srcset="/img/loading.gif" lazyload alt="开漏输出"></p>
<ul>
<li>由于输出驱动器的控制指令来源有2个：<ul>
<li>一个是写入(HAL_GPIO_WritePin函数)控制的输出寄存器</li>
<li>另一个是片上外设，例如串口模块，I^2C模块的复用功能输入</li>
</ul>
</li>
</ul>
<p>因此，根据控制来源的不同，stm32将输出模块分为：</p>
<ul>
<li>开漏输出</li>
<li>推挽式输出</li>
<li>推挽式复用功能</li>
<li>开漏复用功能</li>
</ul>
<ol>
<li>输入驱动器：<br>根据是否开启上拉&#x2F;下拉电阻可以选择以下三种模式。</li>
</ol>
<ul>
<li>输入浮空</li>
<li>输入上拉</li>
<li>输入下拉</li>
</ul>
<p>TTL肖特基触发器的功能：稳定电平</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p19.png" srcset="/img/loading.gif" lazyload alt="TTL肖特基触发器"></p>
<p>经过肖特基触发器处理之后的电平数据存储在输入数据寄存器中，等待使用HAL_GPIO_ReadPin函数对寄存器进行读取。</p>
<ul>
<li><p>模拟输入模式可以读取输入电压的具体数值，即不经过肖特基触发器处理的原始电压数据。</p>
</li>
<li><p>输入部分的不同分支可以同时读取施密特触发器的输出：</p>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p20.png" srcset="/img/loading.gif" lazyload alt="输入部分"></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断的概念：</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p21.png" srcset="/img/loading.gif" lazyload alt="输入部分"></p>
<p>常见的中断事件有：</p>
<ul>
<li>指令出错</li>
<li>定时器结束</li>
<li>串口接收数据</li>
<li>GPIO电平发生变化(外部中断EXTI)</li>
</ul>
<h2 id="外部中断：红灯循环闪烁，按键中断，绿灯闪烁"><a href="#外部中断：红灯循环闪烁，按键中断，绿灯闪烁" class="headerlink" title="外部中断：红灯循环闪烁，按键中断，绿灯闪烁"></a>外部中断：红灯循环闪烁，按键中断，绿灯闪烁</h2><p> 不使用中断，会存在的情况：</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p22.png" srcset="/img/loading.gif" lazyload alt="逻辑错误"></p>
<h3 id="设置中断："><a href="#设置中断：" class="headerlink" title="设置中断："></a>设置中断：</h3><p>   将接收电平输入的引脚设置为：<code>GPIO_EXTIXX</code>，XX为引脚号，表示第XX号外部中断线。</p>
<ul>
<li>设置GPIO mode：<ul>
<li>上升沿触发中断：某个GPIO口读取的电平由低电平变为高电平，触发中断</li>
<li>下降沿触发中断：某个GPIO口读取的电平由高电平变为低电平，触发中断</li>
<li>上升、下降沿都触发中断</li>
</ul>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p23.png" srcset="/img/loading.gif" lazyload alt="GPIO mode"></p>
<ul>
<li>设置NVIC(中断控制器)：勾选开启<code>中断向量EXTI15_10</code></li>
</ul>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>在Core&#x2F;Src中可以找到stm32f1xx_it.c，其后缀it就表示它是与中断(interrupt)相关的文件。</p>
<p>此文件的最底部有CubeMX自动生成的函数:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EXTI15_10_IRQHandler</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>&#123;<br>    HAL_GPIO_EXTI_IRQHandler(KET1_PIN);   <span class="hljs-meta"># KET1_PIN为引脚的用户标签</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>该函数为我们摁下按键触发中断后，stm32会调用执行的中断处理函数。</p>
<h4 id="外部中断的软件消抖-按键"><a href="#外部中断的软件消抖-按键" class="headerlink" title="外部中断的软件消抖(按键)"></a>外部中断的软件消抖(按键)</h4><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p24.png" srcset="/img/loading.gif" lazyload alt="软件消抖"></p>
<ul>
<li><p>在中断处理函数中，先等10ms，用于软件消抖，等按键稳定之后，再读取按键状态判断是否为有效的中断触发。</p>
<ul>
<li>若为误触，则中断处理函数不做任何操作，直接回到主程序</li>
</ul>
</li>
<li><p>注意：如果要在回调函数中使用<code>HAL_Delay()</code>，就必须配置<code>中断优先级</code>:</p>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p25.png" srcset="/img/loading.gif" lazyload alt="中断优先级配置"></p>
<ul>
<li>System Core -&gt; NVIC，将 Time base: System tick timer 的主要优先级调到比EXTI line[15:10] Interrupts 高即可。<ul>
<li>HAL_Delay()函数依靠<code>System tick timer</code>的中断提供1ms的时钟基准。该中断的优先级如果低于我们触发的中断，使 HAL_Delay() 函数无法在中断函数中正常执行，会导致程序卡死在这里。</li>
</ul>
</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在正规的项目中，在中断中调用HAL_Delay()函数是不被推荐的，需要尽可能的保证中断任务可以尽快执行完成，将中断对正常执行流程的影响降到最低。</p>
<h2 id="深入外部中断"><a href="#深入外部中断" class="headerlink" title="深入外部中断"></a>深入外部中断</h2><h3 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p26.png" srcset="/img/loading.gif" lazyload alt="外部中断/事件控制器框图"></p>
<p>在stm32f1系列芯片中一共有19个这样的外部中断&#x2F;事件控制器，它们共用一套寄存器，但连线是独立的，称为<code>外部中断线</code>。</p>
<ul>
<li>前16条外部中断线，即EXTI0~EXTI15分别对应其同号的GPIO口。<ul>
<li>从PA0，PB0，PC0，PD0进入的电平信号都可以进入EXTI0。</li>
</ul>
</li>
</ul>
<ol>
<li>事件信号：<br>事件是和中断类似的概念，但是事件信号直接送达相应的外设，由外设自行处理，不会中断正常代码执行流程。</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p27.png" srcset="/img/loading.gif" lazyload alt="事件信号处理部分"></p>
<ol start="2">
<li>软件中断事件寄存器可以用代码模拟产生一个中断。</li>
<li>边沿检测电路就是用来检测电平变化的，经过一个或门，传输中断数据到<code>请求挂起寄存器</code>，其输出的信号和<code>中断屏蔽寄存器</code>的信号通过一个与门, 进入NVIC中断控制器。</li>
</ol>
<h3 id="NVIC-嵌套向量中断控制器"><a href="#NVIC-嵌套向量中断控制器" class="headerlink" title="NVIC 嵌套向量中断控制器"></a>NVIC 嵌套向量中断控制器</h3><ol>
<li>关于中断向量：</li>
</ol>
<ul>
<li>EXTI0~EXTI4 ： 拥有自己的中断向量</li>
<li>EXTI5~EXTI9： 共享中断向量 EXTI9_5</li>
<li>EXTI10~EXTI15: 共享中断向量EXTI15_10</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p28.png" srcset="/img/loading.gif" lazyload alt="中断向量"></p>
<ol start="2">
<li>NVIC会一直读取中断信号线是否存在中断请求。为了让中断处理函数只执行一遍而不是无限重复，需要在中断处理函数中，将请求挂起寄存器的对应位清零。<ul>
<li>CubeMX生成的代码中，中断处理函数里面自动调用了该清零的函数_HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN)。<br> 所以不需要额外写。</li>
</ul>
</li>
<li>优先级</li>
</ol>
<ul>
<li>两中断同时发生时，先比较<code>抢占优先级</code>；若抢占优先级相同，再比较<code>响应优先级</code>。</li>
<li>某中断正在进行中，另一中断突然发生，只比较二者抢占优先级。</li>
</ul>
<center class="half">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p29.png" srcset="/img/loading.gif" lazyload width="250/">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p30.png" srcset="/img/loading.gif" lazyload width="280/">
</center>

<p>CubeMX用四个二进制位表示优先级，默认4位均为抢占优先级。</p>
<h2 id="一些其他的中断"><a href="#一些其他的中断" class="headerlink" title="一些其他的中断"></a>一些其他的中断</h2><ul>
<li>串口USART：<ul>
<li>空暇中断</li>
<li>接收中断</li>
<li>发送完成中断</li>
<li>奇偶校验中断</li>
<li>…</li>
</ul>
</li>
<li>定时器TIM：<ul>
<li>刹车中断</li>
<li>触发和通信中断</li>
<li>捕获比较中断</li>
<li>…</li>
</ul>
</li>
<li>I^2C:<ul>
<li>传输完成终端</li>
<li>地址发送终端</li>
<li>起始位发送中断</li>
<li>接收缓存区非空中断</li>
<li>…</li>
</ul>
</li>
</ul>
<p>这些中断虽然没有外部中断线这套结构，但是也有相关的请求挂起寄存器和中断屏蔽寄存器，触发中断后依旧需要NVIC通过中断向量找到并执行中断处理函数。</p>
<h1 id="串口通信——TTL串口"><a href="#串口通信——TTL串口" class="headerlink" title="串口通信——TTL串口"></a>串口通信——TTL串口</h1><p>常见的串口：</p>
<ul>
<li>RS-232、RS-485</li>
<li>RJ-45 ：网线接口</li>
<li>USB串口</li>
</ul>
<p>这里介绍的是单片机中最常见的串口：TTL串口</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p31.png" srcset="/img/loading.gif" lazyload alt="串口接线图"></p>
<ul>
<li>共地是两设备通信的前提</li>
<li>TTL串口为异步通信</li>
<li>波特率：每秒传送的码元数量，即每秒多少次高低电平信号。<ul>
<li>TTL串口每传递一个字节(Byte)，也就是<code>8 bit</code>数据，加上一位<code>起始位</code>和一位<code>停止位</code>,每传递一字节的信息需要10 bit</li>
<li>常见的波特率：<ul>
<li>115200</li>
<li>9600</li>
<li>19200</li>
<li>38400</li>
</ul>
</li>
<li>通信的两个设备需要使用相同的波特率才能正常通信。</li>
</ul>
</li>
<li>除了波特率，另外需要在CubeMX中设置的<code>Word Length</code>(字节长度),<code>Parity</code>(校验位)，<code>Stop Bits</code>(停止位)保持默认即可。</li>
</ul>
<h2 id="初识串口——项目实战"><a href="#初识串口——项目实战" class="headerlink" title="初识串口——项目实战"></a>初识串口——项目实战</h2><p>串口通信方式：</p>
<ul>
<li>轮询方式：CPU不断检测串口的状态标志来判断数据收发的情况。<ul>
<li>特点：程序设计简单，但CPU在检测标志位期间，无法执行其他任务，CPU利用率较低。</li>
</ul>
</li>
<li>中断方式：使能中断后，接收一字节数据或发送一字节后申请中断，在ISR中完成后续处理。<ul>
<li>在数据收发期间，CPU可以执行其他任务，CPU利用率较高。</li>
</ul>
</li>
<li>DMA方式：初始化时设置相关参数，启动DMA传输后，数据传输过程不需要CPU的干预。<ul>
<li>传输完成后，再产生DMA中断，由CPU进行后续处理，传输效率最高。</li>
</ul>
</li>
</ul>
<h3 id="轮询模式的底层机制"><a href="#轮询模式的底层机制" class="headerlink" title="轮询模式的底层机制"></a>轮询模式的底层机制</h3><p>在stm32的每个串口内部都有两个发送数据寄存器：<code>发送数据寄存器(TDR)</code>,<code>发送移位寄存器</code>，两个接收数据的寄存器：<code>接收数据寄存器(RDR)</code>,<code>接收移位寄存器</code>。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p35.png" srcset="/img/loading.gif" lazyload alt="两个发送数据寄存器的作用"></p>
<p>CPU不停的轮询发送数据寄存器中的数据是否已经移送到发送移位寄存器。</p>
<p>同理，CPU不停的轮询接收数据寄存器中是否有新数据可以读，直到接收完设置的希望接收的字节数或者时间超时。</p>
<ul>
<li>在轮询模式下，不管是发送还是接收，CPU一直处于忙碌状态。容易产生长期串口占用CPU导致堵塞的问题。</li>
</ul>
<h3 id="CubeMX设置"><a href="#CubeMX设置" class="headerlink" title="CubeMX设置"></a>CubeMX设置</h3><p>stm32F103C8T6的芯片中，调试串口的I&#x2F;O口为PA2和PA3。<br>设置USART2为异步模式，设置波特率为115200,保存设置并生成代码。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p32.png" srcset="/img/loading.gif" lazyload alt="CubeMX设置串口"></p>
<h3 id="代码编写-1"><a href="#代码编写-1" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="函数介绍：串口轮询模式"><a href="#函数介绍：串口轮询模式" class="headerlink" title="函数介绍：串口轮询模式"></a>函数介绍：串口轮询模式</h4><ol>
<li><p>MX_USART2_UART_Init()：初始化USART2串口。<br>这个函数通常在微控制器固件的初始化阶段被调用，用于根据在 STM32CubeMX 中配置的参数（如波特率、数据位、停止位和校验位）设置和配置 USART2 外设（在本例中为 UART2）。</p>
</li>
<li><p>发送数据 :</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Transmit(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size, <span class="hljs-params">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参数：<ul>
<li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li>
<li>pData：指向要发送的数据缓冲区的指针。</li>
<li>Size：要发送的数据字节数。</li>
<li>Timeout：发送操作的超时时间（以毫秒为单位）。如果在超时时间内未完成发送操作，则函数可能会返回超时错误。<ul>
<li><code>HAL_MAX_DELAY</code> :表示不设超时时间，可以无限等待到发送完成。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>HAL_OK：操作成功完成。</li>
<li>其他错误代码，例如超时错误或者传输中断。</li>
</ul>
</li>
<li>功能：<ul>
<li>当调用 HAL_UART_Transmit() 函数时，它会尝试将指定数量的数据字节发送到 UART 外设。</li>
<li>如果 UART 外设正在发送其他数据或者处于忙状态，该函数将等待直到 UART 外设空闲，然后再发送数据。</li>
<li>如果发送过程中发生错误（例如超时或者传输中断），函数将返回相应的错误代码。</li>
</ul>
</li>
</ul>
<h4 id="实战项目：串口控制LED灯的亮灭"><a href="#实战项目：串口控制LED灯的亮灭" class="headerlink" title="实战项目：串口控制LED灯的亮灭"></a>实战项目：串口控制LED灯的亮灭</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> main(void)<br>    &#123;<br>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span><br>  <span class="hljs-constructor">HAL_Init()</span>;<br>  <span class="hljs-constructor">SystemClock_Config()</span>;<br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  <span class="hljs-constructor">MX_GPIO_Init()</span>;<br>  <span class="hljs-constructor">MX_USART2_UART_Init()</span>;<br><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>	<span class="hljs-built_in">char</span> message_1<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Normal situation : The LED is extincting ...&quot;</span>;<br>	<span class="hljs-built_in">char</span> message_2<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;The LED is lit up !!!&quot;</span>;<br>	uint8_t receiveData<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>			<span class="hljs-constructor">HAL_UART_Receive(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,1,100)</span>;<br>			<span class="hljs-comment">//Normal situation--Flashing light</span><br>			<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>		  <span class="hljs-constructor">HAL_Delay(1000)</span>;<br>			<span class="hljs-keyword">if</span>(receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>==<span class="hljs-character">&#x27;0&#x27;</span>)&#123;<br>				<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>				<span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_2,strlen(message_2),<span class="hljs-number">100</span>);<br>				<span class="hljs-constructor">HAL_Delay(5000)</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_1,strlen(message_1),<span class="hljs-number">100</span>);<br>				<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_SET)</span>;<br>				<span class="hljs-constructor">HAL_Delay(1000)</span>;<br>			&#125;<br>			receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* USER CODE END WHILE */</span><br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<center class="half">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p33.png" srcset="/img/loading.gif" lazyload width="420/">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p34.png" srcset="/img/loading.gif" lazyload width="420/">
</center>

<h2 id="串口的中断模式"><a href="#串口的中断模式" class="headerlink" title="串口的中断模式"></a>串口的中断模式</h2><p>采用中断模式，当CPU把发送的内容塞入发送数据寄存器之后，就去处理其他代码，<code>当发送数据寄存器为空之后，触发中断，CPU再继续塞数据</code>…由此可以解决串口占用CPU导致的阻塞问题。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p36.png" srcset="/img/loading.gif" lazyload alt="串口的中断模式"></p>
<h3 id="CubeMX设置-1"><a href="#CubeMX设置-1" class="headerlink" title="CubeMX设置"></a>CubeMX设置</h3><p>在NVIC中勾选上UART2即可。</p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p37.png" srcset="/img/loading.gif" lazyload alt="串口中断模式设置"></p>
<h3 id="函数介绍-2"><a href="#函数介绍-2" class="headerlink" title="函数介绍"></a>函数介绍</h3><ol>
<li>发送数据：<code>HAL_UART_Transmit_IT()</code><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Transmit_IT(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参数：<ul>
<li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li>
<li>pData：指向要发送的数据缓冲区的指针。</li>
<li>Size：要发送的数据字节数。</li>
<li>因为是中断模式，不会长期占用CPU，所以无需设置等待时间</li>
</ul>
</li>
<li>功能：<ul>
<li>当调用 HAL_UART_Transmit_IT() 函数时，它会将指定数量的数据字节放入发送缓冲区，并启动发送过程。</li>
<li>函数将立即返回，不会等待数据发送完成。数据将在后台通过中断的方式进行发送。</li>
<li>一旦发送完成，将触发相应的 UART 发送完成中断，可以在中断处理函数中进行进一步的处理。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>接收数据：<code>HAL_UART_Receive_IT()</code><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Receive_IT(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参数：<ul>
<li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li>
<li>pData：指向接收数据的缓冲区的指针。</li>
<li>Size：要接收的数据字节数。</li>
</ul>
</li>
<li>功能：<ul>
<li>当调用 HAL_UART_Receive_IT() 函数时，它会启动接收过程，并将接收到的数据存储到指定的缓冲区中。</li>
<li>函数将立即返回，不会等待数据接收完成。数据将在后台通过中断的方式进行接收。<ul>
<li>因此不能把这个函数放到while循环中，否则会出现新一轮循环调用它时，上一次的接收还未结束</li>
<li>需要设置回调函数，并且记得在HAL_UART_RxCpltCallback()中开启下一次串口的接收</li>
</ul>
</li>
<li>一旦接收到指定数量的数据字节或者接收超时，将触发相应的 UART 接收<code>完成中断</code>(接收数据寄存器非空中断)，可以在中断处理函数中获取接收到的数据。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>回调函数</li>
</ol>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p38.png" srcset="/img/loading.gif" lazyload alt="USART中断请求"></p>
<p>一个USART只有一个中断向量，使用回调函数，可以更好的处理各种中断事件。</p>
<ul>
<li><code>HAL_UART_RxCpltCallback()</code>函数<br>当串口接收到指定数量的数据字节后，将触发接收完成中断。此时，HAL 库将自动调用 HAL_UART_RxCpltCallback() 函数（如果已经在代码中定义了该函数），并将 UART 句柄作为参数传递给它。<br>此类函数虽然定义在stm32的库函数中，但是都是<code>_weak</code>定义，可以在其他地方重新定义此函数，然后在中间加入处理部分的代码。<ul>
<li>一般单开一个文件对这类函数重新定义的。<br>通常情况下，可以在 HAL_UART_RxCpltCallback() 函数中进行以下操作：</li>
<li>处理接收到的数据，例如解析数据包、执行相应的操作或者存储数据到缓冲区中。</li>
<li>启动下一次接收过程，以便继续接收数据。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">HAL_UART_RxCpltCallback</span>(UART_HandleTypeDef *huart) &#123;<br>    if (huart == &amp;huart2) &#123;<br>        <span class="hljs-comment">// 在这里处理接收到的数据，例如打印到终端或者执行特定的操作</span><br>        <span class="hljs-comment">// 以下示例假设接收到的数据存储在 rxBuffer 中，并且数据长度为 RX_BUFFER_SIZE</span><br>        <span class="hljs-built_in">printf</span>(&quot;Received data: %s\n&quot;, rxBuffer);<br><br>        <span class="hljs-comment">// 启动下一次接收过程</span><br>        <span class="hljs-built_in">HAL_UART_Receive_IT</span>(&amp;huart2, rxBuffer, RX_BUFFER_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>补充一个代码规范：用户自定义的全局变量，放在<code>USER CODE PV</code>注释块中</li>
</ol>
<h2 id="串口DMA模式和接收不定长数据"><a href="#串口DMA模式和接收不定长数据" class="headerlink" title="串口DMA模式和接收不定长数据"></a>串口DMA模式和接收不定长数据</h2><h3 id="DMA的概念"><a href="#DMA的概念" class="headerlink" title="DMA的概念"></a>DMA的概念</h3><p>DMA（Direct Memory Access，<code>直接内存访问</code>）是一种计算机系统中用于实现高效数据传输的技术。它允许外部设备（如网络适配器、硬盘控制器、串口等）直接访问系统内存，而无需 CPU 的干预。DMA 可以大大提高数据传输的效率，因为它可以在数据传输过程中释放 CPU，使 CPU 可以同时执行其他任务。</p>
<ul>
<li><p>数据传输效率：DMA 允许<code>数据在外设和内存之间直接传输</code>，无需 CPU 的介入。这消除了 CPU 在数据传输期间的等待时间，从而提高了系统的总体效率。</p>
</li>
<li><p>减少 CPU 负载：由于 DMA 可以独立地管理数据传输，CPU 可以将更多的时间用于执行其他任务，从而减少了 CPU 的负载。这对于实时系统和多任务系统尤其有用。</p>
</li>
<li><p><code>多通道</code>支持：许多 DMA 控制器支持多个 DMA 通道，每个通道可以独立地管理一个数据传输任务。这允许系统<code>同时执行多个数据传输</code>，提高了系统的并发性。</p>
</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p39.png" srcset="/img/loading.gif" lazyload alt="形象理解DMA"></p>
<ul>
<li><p>工作原理：在 DMA 操作中，<code>CPU 配置 DMA 控制器来指定数据传输的源地址、目的地址和数据长度等参数</code>。一旦 DMA 控制器被配置好，它可以独立地控制数据传输，直到传输完成或者遇到错误。一旦数据传输完成，DMA 控制器触发一个<code>DMA传输完成中断</code>或者通知 CPU。</p>
</li>
<li><p>适用场景：DMA 主要用于大量数据的传输，例如大文件的读写、图像传输、音频处理等场景。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>中断模式</th>
<th>发送数据寄存器空终端、接收数据寄存器非空中断</th>
<th>每收&#x2F;发一个字节时</th>
</tr>
</thead>
<tbody><tr>
<td>DMA模式</td>
<td>DMA传输完成中断</td>
<td>收&#x2F;发完成时</td>
</tr>
</tbody></table>
<h4 id="四种情况的数据传输如下："><a href="#四种情况的数据传输如下：" class="headerlink" title="四种情况的数据传输如下："></a>四种情况的数据传输如下：</h4><p>Dirction ： DMA传输方向<br>(1)外设到内存 Peripheral To Memory<br>(2)内存到外设 Memory To Peripheral<br>(3)内存到内存 Memory To Memory<br>(4)外设到外设 Peripheral To Peripheral</p>
<h4 id="DMA基础工作原理"><a href="#DMA基础工作原理" class="headerlink" title="DMA基础工作原理"></a>DMA基础工作原理</h4><p>当用户将参数设置好，主要涉及<code>源地址</code>、<code>目标地址</code>、<code>传输数据量</code>这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输。</p>
<ul>
<li>当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。<ul>
<li>也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。</li>
</ul>
<p>　</p>
</li>
<li>总之，每次DMA传送由3个操作组成：<ul>
<li>从外设数据寄存器或者从当前外设&#x2F;存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；</li>
<li>存数据到外设数据寄存器或者当前外设&#x2F;存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；</li>
<li>执行一次DMA_CNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目</li>
</ul>
</li>
</ul>
<h4 id="DMA传输方式"><a href="#DMA传输方式" class="headerlink" title="DMA传输方式"></a>DMA传输方式</h4><ul>
<li>方法1：<code>DMA_Mode_Normal</code>，正常模式<br>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次</li>
<li>方法2：<code>DMA_Mode_Circular</code> ，循环传输模式<br>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式</li>
</ul>
<h3 id="CubeMX配置DMA"><a href="#CubeMX配置DMA" class="headerlink" title="CubeMX配置DMA"></a>CubeMX配置DMA</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p40.png" srcset="/img/loading.gif" lazyload alt="CubeMX配置DMA"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/104827639">详细参考配置教程</a></p>
<ul>
<li>DMA Request ： DMA传输的对应外设<ul>
<li>注意： 如果你是在DMA设置界面添加DMA 而没有开启对应外设的话 ，默认为MENTOMEN</li>
</ul>
</li>
<li>Channel DMA传输通道设置:<br>DMA1 : DMA1 Channel 0 - DMA1 Channel 7<br>DMA2: DMA2 Channel 1 - DMA1 Channel 5</li>
<li>Priority： 传输速度<br>最高优先级 Very Hight<br>高优先级 Hight<br>中等优先级 Medium<br>低优先级；Low</li>
<li>DMA指针递增设置<br>Increment Address：地址指针递增。<br>(1)左侧Src Memory 表示外设地址寄存器<br>功能：设置传输数据的时候<code>外设地址</code>是不变还是递增。如果设置为递增，那么下一次传输的时候地址加 Data Width个字节。<br>(2)右侧Dst Memory 表示内存地址寄存器<br>功能：设置传输数据时候<code>内存地址</code>是否递增。如果设置为递增，那么下一次传输的时候地址加 Data Width个字节。</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p41.png" srcset="/img/loading.gif" lazyload alt="DMA指针递增设置"></p>
<ul>
<li>串口发送数据是将数据不断存进固定外设地址串口的发送数据寄存器(USARTx_TDR)。所以外设的地址是不递增。</li>
<li>而内存储器存储的是要发送的数据，所以地址指针要递增，保证数据依次被发出</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p42.png" srcset="/img/loading.gif" lazyload alt="DMA指针递增原理"></p>
<ul>
<li>串口数据发送寄存器只能存储8bit,每次发送一个字节，所以数据长度选择Byte</li>
</ul>
<h3 id="函数介绍-3"><a href="#函数介绍-3" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul>
<li>HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)<br>串口DMA模式发送</li>
<li>HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)<br>串口DMA模式接收</li>
</ul>
<p>前两个函数的形参和串口中断模式一样。</p>
<ul>
<li><p>HAL_UART_DMAPause(&amp;huart1) <br>暂停串口DMA</p>
</li>
<li><p>HAL_UART_DMAResume(&amp;huart1)<br> 恢复串口DMA</p>
<ul>
<li>作用： 恢复DMA的传输</li>
<li>返回值： 0 正在恢复 1 完成DMA恢复</li>
</ul>
</li>
<li><p>HAL_UART_DMAStop(&amp;huart1)<br>结束串口DMA</p>
</li>
</ul>
<h3 id="STM32-IDLE-接收空闲中断-可接收不定长数据"><a href="#STM32-IDLE-接收空闲中断-可接收不定长数据" class="headerlink" title="STM32 IDLE 接收空闲中断(可接收不定长数据)"></a>STM32 IDLE 接收空闲中断(可接收不定长数据)</h3><p>如果勾选了<code>为每个外设生成单独的.c.h文件</code>，在按照视频关闭dma半传输中断时会报错，需要在代码的开头加上:</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">extern DM<span class="hljs-built_in">A_HandleTypeDef</span> hdm<span class="hljs-built_in">a_usart2</span>_rx；<br></code></pre></td></tr></table></figure>
<p>我们可以认为空闲中断发生时，一帧数据包就接收完成了。</p>
<h4 id="函数介绍-4"><a href="#函数介绍-4" class="headerlink" title="函数介绍"></a>函数介绍</h4><ol>
<li>接收数据函数<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>uint16_t Size为可接收的最大数据size，一般可以直接<code>sizeof(receiveData)</code></li>
</ul>
<ol start="2">
<li>回调函数<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint16_t</span> Size)</span><br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用回调函数的一个好习惯：先确认是哪个串口触发了回调函数  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(huart == &amp;huart2)</span></span>&#123;<br>    \\确认是需要处理的目标串口之后再进行函数处理<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>接收数据储存在receiveData数组中，在回调函数中处理之后，需要清零数组内容，以便下一次接收数据。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">memset(<span class="hljs-name">receiveData</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-name">receiveData</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="项目实战："><a href="#项目实战：" class="headerlink" title="项目实战："></a>项目实战：</h4><p>需求：接收电脑端发送的三种类型的数据：1,非1的单个数据，长数据</p>
<ul>
<li>收到1，发送<code>The LED Is Lit Up!</code>，点亮小灯</li>
<li>收到非1的单个数据，发送<code>Get Wrong Messages ~ Why Not TRY again?</code></li>
<li>收到长数据，发送<code>Get Long Messages ~YOU SEND :这里拼接上电脑端发送的长数据</code></li>
<li>while主程序为闪烁小灯<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">uint8_t receiveData<span class="hljs-literal">[<span class="hljs-number">50</span>]</span>;<br>volatile uint8_t tx_complete = <span class="hljs-number">1</span>;<br>void <span class="hljs-constructor">HAL_UART_TxCpltCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (huart-&gt;Instance<span class="hljs-operator"> == </span>USART2) &#123;<br>        tx_complete = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//串口空闲中断的回调函数</span><br>void <span class="hljs-constructor">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint16_t</span> Size)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(huart<span class="hljs-operator"> == </span>&amp;huart2)&#123; <br>    <span class="hljs-comment">//先确认是哪个串口触发了回调函数</span><br>		<span class="hljs-keyword">if</span>(Size &gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//接收到长数据</span><br>			<span class="hljs-built_in">char</span> message_long<span class="hljs-literal">[<span class="hljs-number">100</span>]</span>=<span class="hljs-string">&quot;Get Long Messages ~YOU SEND :&quot;</span>;<br>			strcat(message_long,receiveData);<br>			<span class="hljs-keyword">if</span> (tx_complete) &#123;<br>					tx_complete = <span class="hljs-number">0</span>; <br>					<span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_long,strlen(message_long));	<br>					&#125;<br>			memset(receiveData, <span class="hljs-number">0</span>, sizeof(receiveData));<br>		&#125;<br>		<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//接收到短数据</span><br>			<span class="hljs-built_in">char</span> message_1<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Get Wrong Messages ~ Why Not TRY again?&quot;</span>;<br>			<span class="hljs-built_in">char</span> message_2<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;The LED Is Lit Up!&quot;</span>;<br>			<span class="hljs-keyword">if</span> (tx_complete) &#123;<br>					tx_complete = <span class="hljs-number">0</span>; <br>					<span class="hljs-keyword">if</span>(receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>==<span class="hljs-character">&#x27;1&#x27;</span>)&#123;<br>						<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>						<span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_2,strlen(message_2));<br>						&#125;<br>					<span class="hljs-keyword">else</span><br>						<span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_1,strlen(message_1));<br>					&#125;<br>		receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">0</span>;<br>		&#125;<br><br>        <span class="hljs-comment">//记得开启下一次的串口接收函数</span><br>		<span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,<span class="hljs-params">sizeof</span>(<span class="hljs-params">receiveData</span>)</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main(void)<br>&#123;<br>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br>  <span class="hljs-constructor">HAL_Init()</span>;<br>  <span class="hljs-comment">/* Configure the system clock */</span><br>  <span class="hljs-constructor">SystemClock_Config()</span>;<br><br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  <span class="hljs-constructor">MX_GPIO_Init()</span>;<br>  <span class="hljs-constructor">MX_DMA_Init()</span>;<br>  <span class="hljs-constructor">MX_USART2_UART_Init()</span>;<br><br><span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,<span class="hljs-params">sizeof</span>(<span class="hljs-params">receiveData</span>)</span>);<br> <br> <br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>			<span class="hljs-comment">//Normal situation--Flashing light</span><br>			<span class="hljs-built_in">char</span> message_3<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Normal situation : The LED is extincting ...&quot;</span>;<br>			<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>		  <span class="hljs-constructor">HAL_Delay(200)</span>;<br>			<span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_SET)</span>;<br>			<span class="hljs-constructor">HAL_Delay(200)</span>;<br>		<span class="hljs-keyword">if</span> (tx_complete) &#123;<br>				tx_complete = <span class="hljs-number">0</span>; <br>				<span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_3,strlen(message_3));<br>		&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<center class="half">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p43.png" srcset="/img/loading.gif" lazyload width="430/">
<img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p44.png" srcset="/img/loading.gif" lazyload width="430/">
</center>

<h2 id="简单帧格式串口通信"><a href="#简单帧格式串口通信" class="headerlink" title="简单帧格式串口通信"></a>简单帧格式串口通信</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_65489379/article/details/122792920">https://blog.csdn.net/weixin_65489379/article/details/122792920</a></p>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p46.png" srcset="/img/loading.gif" lazyload alt="简单的帧格式"></p>
<p>常见的帧格式为：<br><code>帧头-帧size-数据部分-校验位-帧尾</code></p>
<h3 id="解析数据包"><a href="#解析数据包" class="headerlink" title="解析数据包"></a>解析数据包</h3><p>解析数据包就是对收到的数据内部按照帧格式进行解析</p>
<ul>
<li>该项目使用空闲中断DMA接收不定长数据，使用使用简单帧格式对三色LED灯进行控制，实现命令某几种颜色LED灯闪烁，某几种颜色的灯长时间熄灭的效果。</li>
<li>采用的简单帧格式为：帧头(0xAA)-帧size-数据部分-和校验</li>
<li>该项目的不足：在相对复杂的工程中，需要建立<code>数据缓冲区</code>，将解析数据包的步骤搬出中断，在主循环中进行，并且需要考虑<code>数据粘包</code>，<code>数据丢失</code>等情况。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HAL_UARTEx_RxEventCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart, <span class="hljs-type">uint16_t</span> Size)</span></span><br><span class="hljs-function"></span>&#123;	<br>	<span class="hljs-type">uint8_t</span> Verify_Flag =<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//接收新消息之前需要重置FLAG</span><br>	Red_Flag = <span class="hljs-number">0</span>;<br>    Green_Flag = <span class="hljs-number">0</span>;<br>    Yello_Flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(huart == &amp;huart2)&#123;<br>        <span class="hljs-comment">//不定长数据接收(控制外设的3色LED灯)</span><br>		<span class="hljs-keyword">if</span>(Size &gt;<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-type">char</span> message_long[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;Get Long Messages ~&quot;</span>;<br>			<span class="hljs-comment">// 开始校验数据</span><br>			<span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">0</span>]== <span class="hljs-number">0xAA</span> )<span class="hljs-comment">//帧头校验</span><br>				<span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">1</span>]== Size)&#123;<span class="hljs-comment">//位数校验</span><br>				<span class="hljs-type">uint8_t</span> sum = <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Size<span class="hljs-number">-1</span>;i++)&#123;<br>				sum+=receiveData[i];<br>				&#125;<br>				<span class="hljs-keyword">if</span>(sum==receiveData[Size<span class="hljs-number">-1</span>])&#123;<br>				<span class="hljs-comment">//和校验</span><br>				Verify_Flag =<span class="hljs-number">1</span>;<br>				&#125;<br>				&#125;<br>			<span class="hljs-keyword">if</span>(Verify_Flag)&#123;<br>			<span class="hljs-comment">//校验成功，开始解析数据</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;Size<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br>				<span class="hljs-type">uint8_t</span> state = <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">if</span>(receiveData[i+<span class="hljs-number">1</span>]== <span class="hljs-number">0xFF</span>)<br>					state = <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x01</span>)<span class="hljs-comment">//red</span><br>					Red_Flag =state;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x02</span>)<span class="hljs-comment">//yello</span><br>					Yello_Flag =state;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x03</span>)<span class="hljs-comment">//green</span><br>					Green_Flag =state;<br>			&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (tx_complete) &#123;<br>					tx_complete = <span class="hljs-number">0</span>; <br>					<span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_long,<span class="hljs-built_in">strlen</span>(message_long));	<br>					&#125;<br>			<span class="hljs-built_in">memset</span>(receiveData, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(receiveData));<br>		&#125;<br>        <span class="hljs-comment">//定长单个指令接受（控制LED_0）</span><br>		<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-type">char</span> message_1[]=<span class="hljs-string">&quot;Get Wrong Messages ~ Why Not TRY again?&quot;</span>;<br>			<span class="hljs-type">char</span> message_2[]=<span class="hljs-string">&quot;The LED Is Lit Up!&quot;</span>;<br>			<span class="hljs-keyword">if</span> (tx_complete) &#123;<br>					tx_complete = <span class="hljs-number">0</span>; <br>					<span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>						<span class="hljs-built_in">HAL_GPIO_WritePin</span>(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET);<br>						<span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_2,<span class="hljs-built_in">strlen</span>(message_2));<br>						&#125;<br>					<span class="hljs-keyword">else</span><br>						<span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_1,<span class="hljs-built_in">strlen</span>(message_1));<br>					&#125;<br>		receiveData[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>		&#125;<br>		<span class="hljs-built_in">HAL_UARTEx_ReceiveToIdle_DMA</span>(&amp;huart2,receiveData,<span class="hljs-built_in">sizeof</span>(receiveData));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="蓝牙模式"><a href="#蓝牙模式" class="headerlink" title="蓝牙模式"></a>蓝牙模式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>蓝牙是一种短距的无线通讯技术，可实现固定设备、移动设备之间的数据交换。一般将蓝牙3.0之前的BR&#x2F;EDR蓝牙称为<code>传统蓝牙</code>，而将蓝牙4.0规范下的LE蓝牙称为<code>低功耗蓝牙</code>。</p>
</li>
<li><p>BLE（Bluetooh Low Energy）蓝牙低能耗技术是短距离、低成本、可互操作性的无线技术，它利用许多智能手段最大限度地降低功耗。</p>
<p>BLE技术的工作模式非常适合用于从微型无线传感器（每半秒交换一次数据）或使用完全异步通信的遥控器等其它外设传送数据。这些设备发送的数据量非常少（通常几个字节），而且发送次数也很少（例如每秒几次到每分钟一次，甚至更少）。</p>
</li>
<li><p><code>协议</code>概述<br>所谓协议，即将指定的字节按照一定的顺序排列起来，以便他人使用自己的设备时，能通过该协议同其他设备进行通信。协议一特点，就是有固定的帧格式，通过该格式发送，接收者通过解读帧格式，进而得到新息内容；</p>
</li>
</ol>
<ul>
<li>一般通信协议，一类通信是直接发生数据，当设备接送到数据时，<code>直接对数据进行解析</code>，当接受到的数据合法时，即为有效数据，该类型的通信协议，主要用在<code>有线通信协议</code>中，比如Modbus，Can通常采用的即为该类型的通信方式。</li>
</ul>
<p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p45.png" srcset="/img/loading.gif" lazyload alt="蓝牙BLE协议"></p>
<ul>
<li>另一类通信协议，则需要新建立连接，当双方<code>连接建立成功了方可通信</code>，例如<code>TCP、BLE</code>；BLE协议在需要进行通信时，即需要向外发送广播信号，告诉接收者，即将和它进行通信，接受者接收到广播内容后，确认是与自己通信，于是向广播者发送一响应信息，这样当广播者和接受者都有了对方的身份信息时，即表示双方连接成功。<ul>
<li>因此，在连接过程中，必定有相应的广播帧格式。在BLE通信过程中，假设设备A需要连其他设备假设为B，则A需要不断地发送广播信号（此过程一般有一个时间间隔，在没发送广播数据时间内，芯片处于低功耗状态），每发送一次广播包，称之为一次广播事件。</li>
</ul>
</li>
</ul>
<h1 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h1><h3 id="IIC通信概念"><a href="#IIC通信概念" class="headerlink" title="IIC通信概念"></a>IIC通信概念</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p48.png" srcset="/img/loading.gif" lazyload alt="IIC通信"></p>
<ul>
<li>串口通信是全双工通信，除了共GND外，两根线（TX,RX）都能同时传输数据<ul>
<li>异步通信模式，双方统一比特率，在合适时机设置或者读取数据线上的高低电平</li>
</ul>
</li>
<li>IIC通信是半双工通信，采用主从模式进行单线通信，必须先由主机向从机发送数据（询问）之后从机才能应答。<ul>
<li>传输数据的线为SDA线，另一根线为SCL线，提供同步时钟脉冲。<ul>
<li>同步通信</li>
</ul>
</li>
<li>可以通过ICC实现多设备通信。</li>
</ul>
</li>
</ul>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%94%B5%E6%8E%A7/" class="category-chain-item">电控</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/STM32/" class="print-no-link">#STM32</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>STM32F103C8T6最小系统板(电控)学习指南</div>
      <div>http://zoechen04616.github.io/2024/03/03/STM32F103C8T6最小系统板-电控-学习指南/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yunru Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/14/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/" title="3.0HUB四层板设计">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">3.0HUB四层板设计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/02/STM32F407VET6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" title="STM32F407VET6最小系统板(电控)学习指南">
                        <span class="hidden-mobile">STM32F407VET6最小系统板(电控)学习指南</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
