<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文投稿记录&amp;入门指南</title>
    <link href="/2025/02/04/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%B0%E5%BD%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2025/02/04/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%B0%E5%BD%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>踏入科研的第一步，从自己完成第一次论文投稿开始~</p><span id="more"></span> <h1 id="中文期刊"><a href="#中文期刊" class="headerlink" title="中文期刊"></a>中文期刊</h1><h2 id="中国电机工程学报"><a href="#中国电机工程学报" class="headerlink" title="中国电机工程学报"></a>中国电机工程学报</h2><h3 id="投稿前的准备"><a href="#投稿前的准备" class="headerlink" title="投稿前的准备"></a>投稿前的准备</h3><ul><li>在<a href="http://ntps.epri.sgcc.com.cn/djgcxb/CN/home">官网</a>注册<code>作者账号</code>。</li><li>登录之后，点击<code>向导式投稿</code>进入投稿流程。</li><li>记得在官网的下载中心下载<code>版权转让协议</code>和<code>投稿信</code>，投稿系统里面的下载链接好像失效了。</li></ul><h3 id="投稿流程"><a href="#投稿流程" class="headerlink" title="投稿流程"></a>投稿流程</h3><ul><li><p>第一步：输入文章题目</p></li><li><p>第二步：输入本文作者信息</p><ul><li>作者顺序是按照论文的位次来排序的</li></ul></li><li><p>第三步：输入本文摘要</p><ul><li>关键词在下一步单独填写，这里只需要复制中文和英文的摘要内容</li></ul></li><li><p>第四步：输入本文关键词</p><ul><li>记得关键词之间用分号间隔，中文和英文关键词分别使用中文分号和英文分号。</li><li>学科分类号（MASS或PACS）：去官网查询，<a href="https://xkfl.xhma.com/html/1467.html">点这里去官网</a></li><li>中图分类号：去官网查询，<a href="https://www.clcindex.com/category/TM/">点这里去官网</a></li></ul><p>  <img src="/images/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%B0%E5%BD%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1.png" alt="中图分类号查询"></p><p>  <img src="/images/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%B0%E5%BD%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/2.png" alt="学科分类号查询"></p></li><li><p>第五步：输入本文学科分类信息</p><ul><li>学科专业：<code>电力系统-电力系统</code></li><li>稿件类型：<code>研究类</code></li><li>稿件创作类别：<code>国家电网及高校</code>（可能会修改，看导师意见）</li><li>稿件拟投栏目：<code>电机及其系统</code>（找导师选一下）</li><li>稿件字数</li></ul></li><li><p>第六步： 输入本文基金资助信息（没有就直接下一步）</p></li><li><p>第七步：推荐审稿人（没有就直接下一步）</p></li><li><p>第八步：给编辑部留言（可以不留言，直接下一步）</p></li><li><p>第九步：上传稿件内容</p><ul><li>稿件原文的word文件（建议压缩一下，用压缩包格式上传）</li><li>稿件的PDF文件</li><li>相关附件（非必填）</li><li>版权转让协议<ul><li>初次投稿不需要上传这个，中稿之后会生成论文编号，再上传</li></ul></li><li>投稿信<ul><li>需要通讯作者的身份证号码，以及全体作者的电子签名</li><li>根据摘要和结论，引言提炼论文的创新点</li></ul></li></ul></li><li><p>第十步：确认信息，点击投稿</p></li></ul><h4 id="投稿成功"><a href="#投稿成功" class="headerlink" title="投稿成功"></a>投稿成功</h4><p><img src="/images/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E8%AE%B0%E5%BD%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/3.png" alt="投稿成功的系统回复"></p>]]></content>
    
    
    <categories>
      
      <category>科研课题组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电气工程及其自动化专业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文审稿细节记录（防挨骂版）</title>
    <link href="/2025/02/02/%E8%AE%BA%E6%96%87%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%EF%BC%88%E9%98%B2%E6%8C%A8%E9%AA%82%E7%89%88%EF%BC%89/"/>
    <url>/2025/02/02/%E8%AE%BA%E6%96%87%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%EF%BC%88%E9%98%B2%E6%8C%A8%E9%AA%82%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>导师审稿的建议，一定要注意~</p><span id="more"></span> <h1 id="排版格式"><a href="#排版格式" class="headerlink" title="排版格式"></a>排版格式</h1><h3 id="关于正文"><a href="#关于正文" class="headerlink" title="关于正文"></a>关于正文</h3><ul><li>正文里直接插入字母和符号，不要用latex写成公式格式，占地方。记得格式为<code>斜体</code>&amp;<code>Times Roman</code></li><li>正文一定要对齐，不要居中，记得全部要检查排版。</li><li>1.1这种标题，两个空格缩进；1.1.1这种标题，一个空格缩进。</li><li>正文里面的小节标题要归并一下，不要太多，最多同级不超过4个。</li><li>合理断句，不要写又臭又长的绕句子。</li><li>善用分号，注意不要在中文论文里面混入英文标点。<ul><li>全文搜查英文逗号和分号，查用错的。</li></ul></li><li>主语尽量放在句子开头。</li><li>英文全称只写一次（包括摘要），后面都直接用缩写。</li><li>每段结尾不要排在</li></ul><h3 id="关于公式："><a href="#关于公式：" class="headerlink" title="关于公式："></a>关于公式：</h3><ul><li>公式的符号解释段落，加了“式中”就不用提行缩进了。</li><li>公式的标号要居中。</li><li>公式前面不能有缩进，对公式的符号说明要依照公式中出现的顺序来。</li><li>公式中不能出现中文。</li></ul><h3 id="关于图表"><a href="#关于图表" class="headerlink" title="关于图表"></a>关于图表</h3><ul><li>图片顺序必须是从a&#x2F;b&#x2F;c……顺序来，不能乱排位置（大图里面的子图）。</li><li>图片英文名字为小五号字体，记得图表和下面的文字设置1行或者0.5行间距。</li><li>尽量一篇文章不要有太多大图，一般一个章节就一张图，里面一堆子图。</li><li>表格不要跨页，要紧凑！！！</li></ul><h3 id="关于参考文献"><a href="#关于参考文献" class="headerlink" title="关于参考文献"></a>关于参考文献</h3><ul><li><p>使用<code>zotero</code>生成参考文献表，记得手动修改。</p><ul><li>英文里面的“等”要改成’et al’。</li><li>修改一下缩进，两端对齐。</li><li>中文文献必须加上英文翻译。</li></ul></li><li><p>不少于20篇。<br>英文期刊不能是会议，主要是<code>IEEE的Transactions</code>或者<code>IET的Transactions</code><br>中文期刊只能有以下的几种：</p><ul><li>中国电机工程学报</li><li>电力系统自动化</li><li>电网技术</li><li>电力自动化设备</li><li>高电压与绝缘</li></ul></li><li><p>记得引用实验室的论文（1-2篇）。</p></li><li><p>在引言部分，每篇文献大概一句话介绍内容，引用的参考文献要和自己的研究内容相关。</p></li></ul><h3 id="小论文取标题，都不能叫”XX研究“，只能叫“XX方法、模型、系统……”"><a href="#小论文取标题，都不能叫”XX研究“，只能叫“XX方法、模型、系统……”" class="headerlink" title="小论文取标题，都不能叫”XX研究“，只能叫“XX方法、模型、系统……”"></a>小论文取标题，都不能叫”XX研究“，只能叫“XX方法、模型、系统……”</h3><h1 id="论文的写法"><a href="#论文的写法" class="headerlink" title="论文的写法"></a>论文的写法</h1><h3 id="说明文风格，结构要清晰明了，不需要变换表达形式。"><a href="#说明文风格，结构要清晰明了，不需要变换表达形式。" class="headerlink" title="说明文风格，结构要清晰明了，不需要变换表达形式。"></a>说明文风格，结构要清晰明了，不需要变换表达形式。</h3><h2 id="引言的写法"><a href="#引言的写法" class="headerlink" title="引言的写法"></a>引言的写法</h2><ul><li>首先介绍研究背景，强调本论文研究问题的必要性、重要性。</li><li>将现有的研究进行综述，记得写出层次，比如按照研究方法分类、解决具体问题侧重点分类、使用模型类型分类等等，中间加一些过渡句，在综述末尾，总结现有研究的不足、局限性、空白领域……</li><li>本文的研究内容主要是……，几句话把全文重点的模型内容说一下。</li><li>本文的主要贡献是：讲明白自己的创新点、解决了什么问题、具有什么价值。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">行业、领域痛点→ 现有方案局限→ 需要解决的核心问题→ 本研究提出的创新方案→ 主要贡献和价值<br></code></pre></td></tr></table></figure></li><li>本文的结构安排如下：第几部分讲了啥……，每部分一句话概括。</li></ul><h2 id="结论的写法"><a href="#结论的写法" class="headerlink" title="结论的写法"></a>结论的写法</h2><ul><li>论文建立了什么模型、系统</li><li>论文提出了什么算法，有什么创新点，解决了什么现有问题……</li><li>用数据证明本研究好在哪里，比其他思路好多少，不能只有文字定性，要给出具体的数据。</li></ul>]]></content>
    
    
    <categories>
      
      <category>科研课题组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电气工程及其自动化专业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32常用模块的函数整理</title>
    <link href="/2025/01/19/stm32%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <url>/2025/01/19/stm32%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>存放一些常用模块的函数实现，<code>.h</code>和<code>.c</code>文件就不放啦~</p><span id="more"></span> <h1 id="Stm32CubeIDE的一些使用技巧"><a href="#Stm32CubeIDE的一些使用技巧" class="headerlink" title="Stm32CubeIDE的一些使用技巧"></a>Stm32CubeIDE的一些使用技巧</h1><ul><li>调整代码字体大小<ul><li><code>Ctrl+Shift+&#39;+&#39; </code> 放大，<code>Ctrl +&#39;-&#39;</code> 缩小。放大为啥多了个Shift，因为不按Shift，是等号</li></ul></li><li>导入已有的工程：<a href="https://blog.csdn.net/qingwufeiyang12346/article/details/127722993">参考这篇博客</a><ul><li>要打开芯片设置页面，直接open工程的<code>.ioc</code>文件。</li></ul></li><li><a href="https://blog.csdn.net/weixin_61834560/article/details/132596182">STM32IDE窗口恢复</a></li><li>数组统一赋值&#x2F;清零操作，不能直接赋值，需要用<code>memset</code>函数，记得使用前检查是否<code>include &lt;string.h&gt;</code><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">memset</span>(rx_data, <span class="hljs-number">0</span>, sizeof(rx_data));<span class="hljs-comment">//清理缓冲区</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="问题篇"><a href="#问题篇" class="headerlink" title="问题篇"></a>问题篇</h1><h2 id="Stm32CubeIDE相关的问题"><a href="#Stm32CubeIDE相关的问题" class="headerlink" title="Stm32CubeIDE相关的问题"></a>Stm32CubeIDE相关的问题</h2><h4 id="1-Confirm-Perspective-Switch（确认视角切换）"><a href="#1-Confirm-Perspective-Switch（确认视角切换）" class="headerlink" title="1.Confirm Perspective Switch（确认视角切换）"></a>1.Confirm Perspective Switch（确认视角切换）</h4><ul><li>问题描述:<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">This kind <span class="hljs-keyword">of</span> launch <span class="hljs-keyword">is</span> configured <span class="hljs-keyword">to</span> <span class="hljs-keyword">open</span> the <span class="hljs-keyword">Debug</span> perspective <span class="hljs-keyword">when</span> it suspends.<br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/stm32%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/2.png" alt="弹窗"></p><ul><li>如果不想每次都这么提示，可以点<code>Remember my decision</code>。点击<code>switch</code>就是切换。</li></ul><h4 id="2-Command-aborted-命令失败"><a href="#2-Command-aborted-命令失败" class="headerlink" title="2.Command aborted(命令失败)"></a>2.Command aborted(命令失败)</h4><ul><li>问题描述：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">all</span> hardware breakpoints<br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/stm32%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/3.png" alt="弹窗"></p><ul><li>一般解决方式：<ul><li><code>减少断点/监视点的数量</code>：硬件调试器通常有硬件断点&#x2F;监视点的数量限制。你可以尝试删除一些不必要的断点&#x2F;监视点。</li><li><code>使用软件断点</code>：有些IDE支持软件断点，虽然性能稍逊于硬件断点，但可以避免硬件断点数量限制的问题。</li><li><code>检查断点的有效性</code>：确保所有设置的断点都是在有效的代码位置，而不是在无效或者不适合设置断点的位置。</li></ul></li></ul><h4 id="3-Porblem-occurred（发生问题）"><a href="#3-Porblem-occurred（发生问题）" class="headerlink" title="3.Porblem occurred（发生问题）"></a>3.Porblem occurred（发生问题）</h4><ul><li>问题描述：<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#x27;Launching xxxx&#x27; has encountered a problem.<br><br><span class="hljs-keyword">Error </span>in final launch sequence:<br><br>Failed to execute MI command:<br>load xxxxxx<br><br><span class="hljs-keyword">Error </span>message from debugger back end:<br><span class="hljs-keyword">Error </span>finishing flash operation<br></code></pre></td></tr></table></figure>这个问题比较复杂，也遇到很多次，大部分情况，和硬件连接相关，简单说就是硬件没连接好。</li><li>解决方式<br>解决方式不是唯一吧，这里罗列些。<ul><li><code>检查硬件连接</code>：确保调试器和目标设备连接正常。如果有物理连接问题，可能导致这种错误。</li><li><code>重新启动调试器和设备</code>：有时重启调试器和设备可以解决问题。</li><li><code>检查文件路径和权限</code>：确保文件或者路径有访问权限，有正确且有访问权限。</li><li><code>重新编译项目</code>：重新编译项目，以确保生成的ELF文件没有问题。</li><li><code>更新调试器固件</code>：确保使用的是最新版本的调试器固件。</li></ul></li></ul><h4 id="4-使用STM32CubeIDE-ST-Link下载提示“Target-no-device-found”"><a href="#4-使用STM32CubeIDE-ST-Link下载提示“Target-no-device-found”" class="headerlink" title="4.使用STM32CubeIDE ST-Link下载提示“Target no device found”"></a>4.使用STM32CubeIDE ST-Link下载提示“Target no device found”</h4><p>复位管脚复位时，利用下载软件（比如STM32 ST-LINK Utility），连接，清除单片机里的程序，然后再试一次烧录。</p><h1 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h1><h2 id="debug模式，打断点-串口输出调试"><a href="#debug模式，打断点-串口输出调试" class="headerlink" title="debug模式，打断点+串口输出调试"></a>debug模式，打断点+串口输出调试</h2><p><a href="https://blog.csdn.net/tuxinbang1989/article/details/100826820">参考这篇博客</a></p><h2 id="printf函数输出到串口"><a href="#printf函数输出到串口" class="headerlink" title="printf函数输出到串口"></a>printf函数输出到串口</h2><h3 id="keil5-IDE"><a href="#keil5-IDE" class="headerlink" title="keil5-IDE"></a>keil5-IDE</h3><p>Keil MDK使用的是ARM编译器，参考<a href="https://blog.csdn.net/lwb450921/article/details/127339596">这篇博客</a>即可，三种方法。</p><ul><li><p>使用微库（Use MicroLIB）</p></li><li><p>在 usrat.c 文件中添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span><span class="hljs-comment">//放在usrat.h开头</span></span><br></code></pre></td></tr></table></figure><p>这段代码放在usrat.c文件开头</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> import(__use_no_semihosting)             </span><br>  <span class="hljs-comment">//标准库需要的支持函数                 </span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__FILE</span> <br>  &#123; <br>   <span class="hljs-type">int</span> handle; <br>  <br>  &#125;; <br> <br>  FILE __stdout;       <br>  <span class="hljs-comment">//定义_sys_exit()以避免使用半主机模式    </span><br>  <span class="hljs-type">void</span> _sys_exit(<span class="hljs-type">int</span> x) <br>  &#123; <br>   x = x; <br>  &#125; <br>  <span class="hljs-comment">//重定义fputc函数 </span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span></span><br><span class="hljs-function">  </span>&#123;      <br>      <span class="hljs-comment">//二选一,功能一样</span><br>      <span class="hljs-built_in">HAL_UART_Transmit</span> (&amp;huart1 ,(<span class="hljs-type">uint8_t</span> *)&amp;ch,<span class="hljs-number">1</span>,HAL_MAX_DELAY );<br>   <span class="hljs-keyword">return</span> ch;<br>  <br>  <span class="hljs-comment">//while((USART1-&gt;SR&amp;0X40)==0);//循环发送,直到发送完毕   </span><br>  <span class="hljs-comment">//    USART1-&gt;DR = (uint8_t) ch;      </span><br>  <span class="hljs-comment">//return ch;</span><br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>在任意需要使用printf函数打印的C文件中，都需要引用<code>#include &lt;stdio.h&gt;</code>头文件</li></ul></li><li><p>适合多个串口打印的方法（GCC编译器也可以用）</p><ul><li>首先在usrat.c 文件中添加如下代码<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">UsartPrintf</span>(UART_HandleTypeDef USARTx, char *fmt,...)<br>  &#123;<br> <br>   unsigned char UsartPrintfBuf<span class="hljs-selector-attr">[296]</span>;<br>   va_list ap;<br><br>   <span class="hljs-built_in">va_start</span>(ap, fmt);<br>      <span class="hljs-built_in">vsnprintf</span>((char *)UsartPrintfBuf, <span class="hljs-built_in">sizeof</span>(UsartPrintfBuf), fmt, ap);  <span class="hljs-comment">// 格式化字符串</span><br>      <span class="hljs-built_in">va_end</span>(ap);<br><br>   <span class="hljs-comment">// 发送整个字符串</span><br>      <span class="hljs-built_in">HAL_UART_Transmit</span>(USARTx, UsartPrintfBuf, strlen((char *)UsartPrintfBuf), HAL_MAX_DELAY);<br>  &#125;<br></code></pre></td></tr></table></figure></li><li>然后在usrat.h文件中添加如下代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USART_DEBUGhuart1 <span class="hljs-comment">//看硬件选择的是uart几，就在这里写几</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsartPrintf</span><span class="hljs-params">(UART_HandleTypeDef USARTx, <span class="hljs-type">char</span> *fmt,...)</span></span>;<br></code></pre></td></tr></table></figure></li><li>使用方法：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">UsartPrintf</span>(<span class="hljs-type">USART_DEBUG</span>, <span class="hljs-string">&quot;The USART1 is OK!<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>注意：函数参数中 <code>USART_DEBUG</code> 参数为在 usrat.h 中重定义的 huart1 。</p><ul><li>如果同时打开了USART1和USART2，那么在 usrat.h 中还会有一个 huart2 ，像huart1（重新define为USART_DEBUG） 一样重定义 huart2 ，和其它串口区分。</li></ul></li></ul><h3 id="Stm32CubeIDE"><a href="#Stm32CubeIDE" class="headerlink" title="Stm32CubeIDE"></a>Stm32CubeIDE</h3><ul><li>法一：使用于单个串口调试输出,但是该串口同时使用DMA串口通信时会失效</li></ul><p>在usart.h中加入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/unistd.h&gt;</span> <span class="hljs-comment">// STDOUT_FILENO, STDERR_FILENO</span></span><br><br><span class="hljs-type">int</span> _write(<span class="hljs-type">int</span> file, <span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> len)<br>&#123;<br>   <span class="hljs-keyword">if</span> ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO))<br>   &#123;<br>      errno = EBADF;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// 实现 USART 发送数据的逻辑</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">HAL_UART_Transmit</span>(&amp;huart1, (<span class="hljs-type">uint8_t</span>*)data, len, HAL_MAX_DELAY) != HAL_OK)<br>   &#123;<br>      errno = EIO;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后直接使用printf打印即可输出到串口。</p><ul><li><p>法二：适合多个串口打印的方法（同上）</p></li><li><p>法三：在Private includes 中引入：<code>#include &lt;stdio.h&gt;</code></p><ul><li>再在USERCODEBEGIN0添加：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span></span>&#123;<br> <span class="hljs-type">uint8_t</span> temp[<span class="hljs-number">1</span>] = &#123;ch&#125;;<br> <span class="hljs-built_in">HAL_UART_Transmit</span>(&amp;huart1, temp, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//huart1需要根据你的配置修改</span><br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure>然后你就可以在任意地方使用printf语句方便的输出你想要的内容。</li></ul></li></ul><h3 id="串口数据缓冲区每次用完，记得清理"><a href="#串口数据缓冲区每次用完，记得清理" class="headerlink" title="串口数据缓冲区每次用完，记得清理"></a>串口数据缓冲区每次用完，记得清理</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//重新启动接收，使用Ex函数，接收不定长数据</span><br>    memset(rx_data, <span class="hljs-number">0</span>, sizeof(rx_data));<span class="hljs-comment">//清理缓冲区</span><br>    <span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">rx_data</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">rx_data</span>)</span>);<br></code></pre></td></tr></table></figure><h1 id="功能模块篇"><a href="#功能模块篇" class="headerlink" title="功能模块篇"></a>功能模块篇</h1><h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><p>这里是4行3列的键盘</p><h3 id="key-h文件"><a href="#key-h文件" class="headerlink" title="key.h文件"></a>key.h文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx_hal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gpio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span>     _KEY_BOARD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     _KEY_BOARD_H_</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PORT          GPIOD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK_FUN       RCC_APB2PeriphClockCmd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK           RCC_APB2Periph_GPIOD</span><br><br><br><span class="hljs-comment">//line    行</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN0           KEY_col0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN1           KEY_col1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN2           KEY_col2_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN3           KEY_col3_Pin</span><br><br><br><br><span class="hljs-comment">//row      列</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN4           KEY_row0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN5           KEY_row1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN6           KEY_row2_Pin</span><br><br><br><span class="hljs-comment">//extern uint8_t Send_F;</span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">Keyboard_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title">keyboard_scan</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="key-c文件"><a href="#key-c文件" class="headerlink" title="key.c文件"></a>key.c文件</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-meta">#include &quot;<span class="hljs-string">stm</span>32f1<span class="hljs-string">xx_hal.h</span>&quot;</span><br><span class="hljs-meta">#include &quot;<span class="hljs-string">key.h</span>&quot;</span><br><br><br><span class="hljs-comment">// 初始化键盘 GPIO</span><br><span class="hljs-type">void</span> Keyboard_GPIO_Init(<span class="hljs-type">void</span>) &#123;<br>    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// 使能 GPIOD 的时钟</span><br>    __HAL_RCC_GPIOD_CLK_ENABLE();<br><br>    <span class="hljs-comment">// 配置列线为输出</span><br>    GPIO_InitStruct.Pin = KEYBOARD_GPIO_PIN0 | KEYBOARD_GPIO_PIN1 | KEYBOARD_GPIO_PIN2;<br>    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;<br>    HAL_GPIO_Init(KEYBOARD_GPIO_PORT, &amp;GPIO_InitStruct);<br><br>    <span class="hljs-comment">// 配置行线为输入，带上拉电阻</span><br>    GPIO_InitStruct.Pin = KEYBOARD_GPIO_PIN4 | KEYBOARD_GPIO_PIN5 | KEYBOARD_GPIO_PIN6;<br>    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    HAL_GPIO_Init(KEYBOARD_GPIO_PORT, &amp;GPIO_InitStruct);<br>&#125;<br><br><br>uint16_t keyboard_scan(<span class="hljs-type">void</span>) &#123;<br>    uint16_t key_val = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 列和行引脚数组定义</span><br>    const uint16_t <span class="hljs-built_in">cols</span>[<span class="hljs-number">3</span>] = &#123;KEYBOARD_GPIO_PIN0, KEYBOARD_GPIO_PIN1, KEYBOARD_GPIO_PIN2&#125;; <span class="hljs-comment">// 列引脚</span><br>    const uint16_t <span class="hljs-built_in">rows</span>[<span class="hljs-number">4</span>] = &#123;KEYBOARD_GPIO_PIN4, KEYBOARD_GPIO_PIN5, KEYBOARD_GPIO_PIN6, KEYBOARD_GPIO_PIN3&#125;; <span class="hljs-comment">// 行引脚</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">col</span> = <span class="hljs-number">1</span>; <span class="hljs-built_in">col</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-built_in">col</span>++) &#123;<br>        printf(<span class="hljs-string">&quot;Setting column %d to LOW\n&quot;</span>, <span class="hljs-built_in">col</span>);<br>        <span class="hljs-comment">// 设置当前列为低电平</span><br>        KEYBOARD_GPIO_PORT-&gt;BSRR = (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">16</span> + <span class="hljs-built_in">cols</span>[<span class="hljs-built_in">col</span>]));  <span class="hljs-comment">// Reset part of BSRR sets pin low</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">row</span> = <span class="hljs-number">1</span>; <span class="hljs-built_in">row</span> &lt; <span class="hljs-number">4</span>; <span class="hljs-built_in">row</span>++) &#123;<br>            printf(<span class="hljs-string">&quot;Reading row %d state\n&quot;</span>, <span class="hljs-built_in">row</span>);<br>            <span class="hljs-comment">// 检查行状态</span><br>            <span class="hljs-keyword">if</span> (!(KEYBOARD_GPIO_PORT-&gt;IDR &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">rows</span>[<span class="hljs-built_in">row</span>]))) &#123; <span class="hljs-comment">// 检测行是否为低</span><br>                printf(<span class="hljs-string">&quot;Key pressed at row %d, col %d\n&quot;</span>, <span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>);<br>                key_val = <span class="hljs-number">1</span> + <span class="hljs-built_in">row</span> * <span class="hljs-number">3</span> + <span class="hljs-built_in">col</span>; <span class="hljs-comment">// 计算按键值</span><br>                HAL_Delay(<span class="hljs-number">10</span>); <span class="hljs-comment">// 消抖</span><br>                printf(<span class="hljs-string">&quot;Waiting for key release at row %d, col %d\n&quot;</span>, <span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>);<br>                <span class="hljs-type">int</span> timeout = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 设置一个超时计数器</span><br>                <span class="hljs-keyword">while</span> (!(KEYBOARD_GPIO_PORT-&gt;IDR &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">rows</span>[<span class="hljs-built_in">row</span>])) &amp;&amp; --timeout) &#123;<br>                    <span class="hljs-comment">//printf(&quot;Waiting for key release at row %d, col %d\n&quot;, row, col);</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (!timeout) &#123;<br>                    printf(<span class="hljs-string">&quot;Timeout waiting for key release.\n&quot;</span>); <span class="hljs-comment">// 如果超时则打印消息</span><br>                &#125;<br>                printf(<span class="hljs-string">&quot;Key released at row %d, col %d\n&quot;</span>, <span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>);<br>                KEYBOARD_GPIO_PORT-&gt;BSRR = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">cols</span>[<span class="hljs-built_in">col</span>]); <span class="hljs-comment">// 将当前列设置回高电平</span><br>                <span class="hljs-keyword">return</span> key_val; <span class="hljs-comment">// 返回按键值</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前列设置回高电平</span><br>        KEYBOARD_GPIO_PORT-&gt;BSRR = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">cols</span>[<span class="hljs-built_in">col</span>]);<br>        printf(<span class="hljs-string">&quot;Setting column %d back to HIGH\n&quot;</span>, <span class="hljs-built_in">col</span>);<br>    &#125;<br><br>    printf(<span class="hljs-string">&quot;No key pressed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 无按键被按下</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主程序调用"><a href="#主程序调用" class="headerlink" title="主程序调用"></a>主程序调用</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lsl">uint16_t <span class="hljs-type">key</span> = keyboard_scan();<br>   if (<span class="hljs-type">key</span> != <span class="hljs-number">0</span>) &#123;<br>   printf(<span class="hljs-string">&quot;Pressed Key: %d<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-type">key</span>);<br>    &#125;<br>HAL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">// 避免过快重复扫描</span><br></code></pre></td></tr></table></figure><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h3><ul><li><code>开启外部晶振</code>：在Pinout&amp;Configuration -&gt; System Core -&gt; RCC 页面，将 High Speed Clock (HSE) 配置为 Crystal&#x2F;Ceramic Resonator</li><li><code>配置时钟频率</code>：在Clock Configuration 页面，将PLL Source 选择为 HSE，将System Clock Mux 选择为 PLLCLK，然后在HCLK (MHz) 输入72并回车，将HCLK频率配置为 72 MHz</li><li><code>打开串口外设</code>：Pinout&amp;Configuration -&gt; Connectivity -&gt; USART1&#x2F;2&#x2F;3，将Mode选择为Asynchronous（自行选择串口）<ul><li>Usart3一般是蓝牙串口</li></ul></li><li><code>添加DMA通道</code>：在 USARTx -&gt; Configuration -&gt; <code>DMA Settings</code> 标签卡中，点击 Add 按钮，分别添加 USARTx_RX 和 USARTx_TX 的 DMA 通道</li><li><code>使能串口中断</code>：在 USART2 -&gt; Configuration -&gt; <code>NVIC Settings</code> 标签卡中，勾选 USARTx global interrupt 的 Enable</li></ul><h3 id="收发主体代码"><a href="#收发主体代码" class="headerlink" title="收发主体代码"></a>收发主体代码</h3><ul><li>定义全局变量 <code>rx_data</code> 作为串口接收缓冲区,<code>tx_data</code> 作为串口发送缓冲区。<ul><li>由于是不定长数据的接收，因此缓冲区大小可以根据实际需求调整，只能大不能小，否则可能会丢失数据  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//串口接收缓冲区<br>uint8_t rx_data[<span class="hljs-number">256</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">0</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>在 main 函数中，使用 <code>HAL_UARTEx_ReceiveToIdle_DMA</code> 函数开启不定长数据DMA接收<ul><li>注意：需要<code>关闭DMA传输过半中断</code>，我们只需要接收完成中断。</li><li>此函数是以空闲中断作为接收完成的标志，而不是接收长度，因此可以接收任意长度的数据。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 使用Ex函数，接收不定长数据</span><br><span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart2</span>, <span class="hljs-params">rx_data</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">rx_data</span>)</span>);<br><span class="hljs-comment">// 关闭DMA传输过半中断（HAL库默认开启，但我们只需要接收完成中断）</span><br><span class="hljs-constructor">__HAL_DMA_DISABLE_IT(<span class="hljs-params">huart2</span>.<span class="hljs-params">hdmarx</span>, DMA_IT_HT)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>在中断函数 <code>HAL_UARTEx_RxEventCallback</code> 中，处理接收到的数据<ul><li>记得在回调函数结尾，<code>重新启动接收，使用Ex函数</code>，接收不定长数据</li><li>记得每次接收完和发送完数据之后，都要清理缓冲区<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 不定长数据接收完成回调函数,这里将接收到的数据又发送出去</span><br>void <span class="hljs-constructor">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint16_t</span> Size)</span> &#123;<br>    <span class="hljs-keyword">if</span> (huart<span class="hljs-operator"> == </span>&amp;huart1) &#123;<br>        data_ready = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记数据已准备好</span><br>    <span class="hljs-comment">//在主函数中，检查data_ready，当数据已准备好，进入数据校验和解析过程。</span><br>    <span class="hljs-comment">//重新启动接收，使用Ex函数，接收不定长数据</span><br>    memset(data_send, <span class="hljs-number">0</span>, sizeof(data_send));<span class="hljs-comment">//清理send缓冲区</span><br>    <span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">rx_data</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">rx_data</span>)</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="校验部分"><a href="#校验部分" class="headerlink" title="校验部分"></a>校验部分</h3><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p><img src="/images/stm32%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/1.png" alt="奇偶校验的计算方法（代码思路）"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void process<span class="hljs-constructor">Data(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span> <span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span> &#123;<br>    <span class="hljs-comment">// 解析和处理数据</span><br>    <span class="hljs-built_in">char</span> message<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Start Check!&quot;</span>;<br>    <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message</span>)</span>, HAL_MAX_DELAY);<br><br>    uint8_t data_check<span class="hljs-literal">[<span class="hljs-number">256</span>]</span> = &#123;<span class="hljs-number">0</span>&#125;;  <br>    <span class="hljs-comment">// 处理新消息前重置标志</span><br>    Red_Flag = Green_Flag = Yello_Flag = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 将接收到的数据复制到数据检查数组</span><br>    memcpy(data_check, data, size);<br><br>    <span class="hljs-comment">// 清理rx_data缓冲区</span><br>    memset(data, <span class="hljs-number">0</span>, size);<br><br>    <span class="hljs-comment">// 校验数据是否有效，例程的校验思路为头校验，长度校验和奇偶校验，size是有效数据的长度。</span><br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>data_check<span class="hljs-literal">[<span class="hljs-number">0</span>]</span><span class="hljs-operator"> == </span><span class="hljs-number">0xAA</span>) &#123;<br>        <span class="hljs-comment">// 校验数据长度是否匹配</span><br>        <span class="hljs-keyword">if</span> (data_check<span class="hljs-literal">[<span class="hljs-number">1</span>]</span><span class="hljs-operator"> == </span>size) &#123;<br>            <span class="hljs-comment">// 校验奇偶校验位</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-constructor">CheckParity(<span class="hljs-params">data_check</span>, <span class="hljs-params">size</span>)</span>) &#123;<br>                <span class="hljs-comment">// 校验成功，解析数据包</span><br>                <span class="hljs-constructor">ParseDataPacket(<span class="hljs-params">data_check</span>, <span class="hljs-params">size</span>)</span>;<br>                <span class="hljs-built_in">char</span> message1<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Data processed successfully.&quot;</span>;<br>                <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message1</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message1</span>)</span>, HAL_MAX_DELAY);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">char</span> message2<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Parity check failed.&quot;</span>;<br>                <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message2</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message2</span>)</span>, HAL_MAX_DELAY);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">char</span> message2<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Invalid size.&quot;</span>;<br>            <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message2</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message2</span>)</span>, HAL_MAX_DELAY);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">char</span> message2<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Invalid frame header.&quot;</span>;<br>        <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message2</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message2</span>)</span>, HAL_MAX_DELAY);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CheckParity(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span> <span class="hljs-params">data</span>, <span class="hljs-params">uint16_t</span> <span class="hljs-params">size</span>)</span> &#123;<br>    uint8_t parity = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">2</span>; i++) &#123;<br>        parity ^= data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <span class="hljs-comment">// XOR所有数据字节（除了校验位）</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (parity<span class="hljs-operator"> == </span>data<span class="hljs-literal">[<span class="hljs-identifier">size</span> - <span class="hljs-number">1</span>]</span>) &#123;<br>        <span class="hljs-comment">// 校验成功</span><br>        <span class="hljs-built_in">char</span> message<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Parity check successfully.&quot;</span>;<br>        <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message</span>)</span>, HAL_MAX_DELAY);<br>        return <span class="hljs-number">1</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 校验失败</span><br>        <span class="hljs-built_in">char</span> message<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;Parity check failed.&quot;</span>;<br>        <span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart1</span>, <span class="hljs-params">message</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">message</span>)</span>, HAL_MAX_DELAY);<br>        return <span class="hljs-number">0</span>;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="和校验"><a href="#和校验" class="headerlink" title="和校验"></a>和校验</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkChecksum</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">uint16_t</span> size)</span> </span>&#123;<br>    <span class="hljs-type">uint8_t</span> checksum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 对数据包的所有字节（除了最后一个字节,此字节为目标校验和）进行求和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">2</span>; i++) &#123;<br>        checksum += data[i];  <span class="hljs-comment">// 求和</span><br>    &#125;<br><br>    <span class="hljs-comment">// 比较计算的校验和与接收到的校验和</span><br>    <span class="hljs-keyword">if</span> (checksum == data[size - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 校验成功</span><br>        <span class="hljs-type">char</span> message[] = <span class="hljs-string">&quot;Checksum check successfully.&quot;</span>;<br>        <span class="hljs-built_in">HAL_UART_Transmit</span>(&amp;huart1, message, <span class="hljs-built_in">strlen</span>(message), HAL_MAX_DELAY);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 校验通过</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 校验失败</span><br>        <span class="hljs-type">char</span> message[] = <span class="hljs-string">&quot;Checksum check failed.&quot;</span>;<br>        <span class="hljs-built_in">HAL_UART_Transmit</span>(&amp;huart1, message, <span class="hljs-built_in">strlen</span>(message), HAL_MAX_DELAY);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 校验失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h4><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><h4 id="将信息固定帧格式打包，作为发送端数据包"><a href="#将信息固定帧格式打包，作为发送端数据包" class="headerlink" title="将信息固定帧格式打包，作为发送端数据包"></a>将信息固定帧格式打包，作为发送端数据包</h4><ul><li>奇偶校验<ul><li>使用串口调试助手生成一个发送数据包的话，可以用电脑计算器的程序员模式异或算出最后一位奇偶校验码，取最后面两位即可。</li><li>波特率动串口调试助手可以自动计算校验和。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>全局变量，数据包根据FLAG对发送数据进行打包<br>int Red_Flag = <span class="hljs-number">0</span>;<br>int Green_Flag = <span class="hljs-number">0</span>;<br>int Yello_Flag = <span class="hljs-number">0</span>;<br><br>void generateDataPacket(uint8_t* data) &#123;<br>    <span class="hljs-regexp">//</span> 设置初始帧头和长度<br>    data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>xAA;          <span class="hljs-regexp">//</span> 帧头<br>    data[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>x09;          <span class="hljs-regexp">//</span> 数据长度（包括帧头、长度、LED控制和校验位）<br><br>    <span class="hljs-regexp">//</span> 设置LED控制<br>    <span class="hljs-keyword">if</span> (Red_Flag == <span class="hljs-number">1</span>) &#123;<br>        data[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>x01;      <span class="hljs-regexp">//</span> 点亮红色LED<br>        data[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>xFF;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>x01;      <span class="hljs-regexp">//</span> 关闭红色LED<br>        data[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>x00;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Yello_Flag == <span class="hljs-number">1</span>) &#123;<br>        data[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>x02;      <span class="hljs-regexp">//</span> 点亮黄色LED<br>        data[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>xFF;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>x02;      <span class="hljs-regexp">//</span> 关闭黄色LED<br>        data[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>x00;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Green_Flag == <span class="hljs-number">1</span>) &#123;<br>        data[<span class="hljs-number">6</span>] = <span class="hljs-number">0</span>x03;      <span class="hljs-regexp">//</span> 点亮绿色LED<br>        data[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>xFF;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data[<span class="hljs-number">6</span>] = <span class="hljs-number">0</span>x03;      <span class="hljs-regexp">//</span> 关闭绿色LED<br>        data[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span>x00;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 计算奇偶校验位<br>    uint8_t parity = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        parity ^= data[i];  <span class="hljs-regexp">//</span> XOR计算校验<br>    &#125;<br>    data[<span class="hljs-number">8</span>] = parity;      <span class="hljs-regexp">//</span> 将计算得出的校验位放入数据包的最后<br><br>    <span class="hljs-regexp">//</span> 此时数据包已经封装完成，可以通过串口发送<br>    HAL_UART_Transmit(&amp;huart1, data, <span class="hljs-number">9</span>, HAL_MAX_DELAY);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>如果是和校验，则最后一位：<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">// 计算校验和</span><br>    uint8_t checksum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        checksum += <span class="hljs-title">data</span>[i];  <span class="hljs-comment">// 求和</span><br>    &#125;<br>    <span class="hljs-title">data</span>[<span class="hljs-number">8</span>] = checksum;<br></code></pre></td></tr></table></figure></li></ul><h4 id="接收端将数据包固定帧格式解析"><a href="#接收端将数据包固定帧格式解析" class="headerlink" title="接收端将数据包固定帧格式解析"></a>接收端将数据包固定帧格式解析</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//串口接收、校验过程略</span><br><span class="hljs-comment">//例程的帧格式规定为</span><br><span class="hljs-type">uint8_t</span> valid_data[] = &#123;<br>    <span class="hljs-number">0xAA</span>, <span class="hljs-number">0x09</span>,  <span class="hljs-comment">// 帧头和长度</span><br>    <span class="hljs-number">0x01</span>, <span class="hljs-number">0xFF</span>,  <span class="hljs-comment">// 点亮红色LED</span><br>    <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>,  <span class="hljs-comment">// 关闭黄色LED</span><br>    <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>,  <span class="hljs-comment">// 关闭绿色LED</span><br><span class="hljs-number">0x5C</span>         <span class="hljs-comment">// 奇偶校验位（计算其他数据的XOR）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParseDataPacket</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">uint16_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; size - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint8_t</span> state = (data[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0xFF</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span> (data[i]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0x01</span>: Red_Flag = state; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0x02</span>: Yello_Flag = state; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0x03</span>: Green_Flag = state; <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="蓝牙模块"><a href="#蓝牙模块" class="headerlink" title="蓝牙模块"></a>蓝牙模块</h2>]]></content>
    
    
    <categories>
      
      <category>电控</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web基础知识</title>
    <link href="/2024/08/07/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/08/07/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>记录Mmdn Web docs学习笔记~</p><span id="more"></span> <h1 id="互联网是如何工作的"><a href="#互联网是如何工作的" class="headerlink" title="互联网是如何工作的"></a>互联网是如何工作的</h1><p>互联网是一种将所有计算机连接在一起的方式，并确保无论发生什么，它们都能找到保持连接的方法。</p><p>IP地址：任何链接到网络的计算机都有一个唯一的地址来识别它，成为“IP地址”。</p><ul><li>IP代表Internet协议</li><li>IP地址由四个数字组成，例如：<code>192.0.2.172</code></li></ul><p>为了方便起见，使用域名为IP地址添加别名。（增加了可读性，例如<code>google.com</code>）</p><h2 id="区分互联网和网络"><a href="#区分互联网和网络" class="headerlink" title="区分互联网和网络"></a>区分互联网和网络</h2><p>互联网是一种技术基础设施，它允许数十亿台计算机连接在一起。在这些计算机中，某些计算机（称为 Web 服务器）可以向 Web 浏览器发送可理解的消息。</p><ul><li><p>Internet 是一种基础设施，而 Web 是建立在基础设施之上的服务。</p></li><li><p>值得注意的是，还有其他一些服务建立在互联网之上，例如电子邮件和IRC。</p></li></ul><h2 id="区分内联网和外联网"><a href="#区分内联网和外联网" class="headerlink" title="区分内联网和外联网"></a>区分内联网和外联网</h2><ul><li>Intranet 是仅限于特定组织的成员的专用网络。 它们通常用于为成员提供一个门户，以安全地访问共享资源、协作和通信。 <ul><li>例如，组织的 Intranet 可能托管用于共享部门或团队信息的网页、用于管理关键文档和文件的共享驱动器、 用于执行业务管理任务的门户，以及 Wiki、讨论板和消息传递系统等协作工具。</li></ul></li><li>Extranet 与 Intranet 非常相似，不同之处在于它们打开全部或部分专用网络，以便与其他组织共享和协作。 它们通常用于与与企业密切合作的客户和利益相关者安全可靠地共享信息。 <ul><li>通常，它们的功能类似于 Intranet 提供的功能：信息和文件共享、协作工具、讨论板等。</li></ul></li><li>Intranet 和 Extranet 都运行在与 Internet 相同的基础设施上，并使用相同的协议。 因此，授权成员可以从不同的物理位置访问它们。</li></ul><p><img src="/images/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" alt="辅助理解图"></p><h2 id="网页、网站、网络服务器和搜索引擎有什么区别？"><a href="#网页、网站、网络服务器和搜索引擎有什么区别？" class="headerlink" title="网页、网站、网络服务器和搜索引擎有什么区别？"></a>网页、网站、网络服务器和搜索引擎有什么区别？</h2><h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p>可以在 Firefox、Google Chrome、Opera、Microsoft Edge 或 Apple Safari 等 Web 浏览器中显示的文档。这些通常也被称为“页面”，可由浏览器显示。</p><ul><li>这些文档是用 <code>HTML</code> 语言编写的。</li><li>网页可以嵌入各种不同类型的资源，例如：<ul><li><code>样式信息</code> — 控制页面的外观</li><li><code>脚本</code> — 增加页面的交互性</li><li><code>媒体</code> — 图像、声音和视频</li></ul></li><li>浏览器还可以显示其他文档，例如 PDF 文件或图像，但术语<code>网页</code>特指<code> HTML 文档</code>。</li><li>网络上可用的所有网页都可以通过唯一的地址访问。要访问页面，只需在浏览器地址栏中输入其地址。</li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>网网站是共享唯一域名的链接网页（及其相关资源）的集合，这些网页被组合在一起，通常以各种方式连接在一起。通常称为“网站”或“站点”。</p><ul><li>给定网站的每个网页都提供明确的链接（大多数时候以可点击的文本部分的形式存在），允许用户从网站的一个页面移动到另一个页面。<ul><li>请注意，也可以拥有单页网站：由单个网页组成的网站，该网页在需要时会动态更新新内容。</li></ul></li><li>要访问网站，请在浏览器地址栏中输入其域名，浏览器将显示网站的主网页或主页</li></ul><h3 id="网页服务器"><a href="#网页服务器" class="headerlink" title="网页服务器"></a>网页服务器</h3><p><code>Web 服务器</code>是托管一个或多个网站的计算机。“托管”意味着所有网页及其支持文件都可以在该计算机上使用。根据用户请求，Web 服务器将从它托管的网站将任何网页发送到任何用户的浏览器。</p><p>不要混淆网站和 Web 服务器。</p><ul><li>例如，如果您听到有人说“我的网站没有响应”，这实际上意味着网络服务器没有响应，因此网站不可用。<ul><li>由于 Web 服务器可以托管多个网站，因此术语 Web 服务器绝不用于指定网站，因为它可能会导致极大的混淆</li></ul></li><li>如果我们说“我的 Web 服务器没有响应”，则意味着该 Web 服务器上的多个网站不可用。</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>一种 Web 服务，可帮助您查找其他网页，例如 Google、Bing、Yahoo 或 DuckDuckGo。搜索引擎通常通过网络浏览器（例如，您可以直接在Firefox、Chrome等的地址栏中执行搜索引擎搜索）或通过网页（例如 bing.com 或 duckduckgo.com）访问。</p><ul><li>搜索引擎是一种特殊类型的网站，可帮助用户从其他网站查找网页。</li></ul><h4 id="区分浏览器和搜索引擎"><a href="#区分浏览器和搜索引擎" class="headerlink" title="区分浏览器和搜索引擎"></a>区分浏览器和搜索引擎</h4><ul><li>浏览器是一种检索和显示网页的软件;搜索引擎是一个帮助人们从其他网站找到网页的网站。</li><li>不要将基础设施（例如浏览器）与服务（例如搜索引擎）混淆。<ul><li>之所以产生混淆，是因为当有人第一次启动浏览器时，浏览器会显示搜索引擎的主页。这是有道理的，因为很明显，您要用浏览器做的第一件事就是找到要显示的网页。</li></ul></li></ul><h4 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h4><p>让我们看一个简单的类比——公共图书馆。这是您在访问图书馆时通常会做的事情：</p><ol><li>找到一个搜索索引，并查找您想要的书名。</li><li>记下图书的目录号。</li><li>转到包含该书的特定部分，找到正确的目录号，然后获取该书。</li></ol><p>让我们将库与 Web 服务器进行比较：</p><ul><li>该库就像一个 Web 服务器。它有几个部分，类似于托管多个网站的 Web 服务器。</li><li>图书馆的不同部分（科学、数学、历史等）就像网站一样。每个部分都像一个独特的网站（两个部分不包含相同的书籍）。</li><li>每个部分的书籍都像网页一样。一个网站可能有几个网页，例如，科学部分（网站）将有关于热、声音、热力学、静力学等的书籍（网页）。每个网页都可以在唯一的位置 （URL） 找到。</li><li>搜索索引就像搜索引擎。每本书在图书馆中都有自己独特的位置（两本书不能放在同一个地方），该位置由目录号指定。</li></ul><h2 id="URL：统一资源定位符"><a href="#URL：统一资源定位符" class="headerlink" title="URL：统一资源定位符"></a>URL：统一资源定位符</h2><p>早在 1989 年，Web 的发明者 Tim Berners-Lee 就谈到了 Web 赖以存在的三大支柱：</p><ul><li>URL，一个跟踪 Web 文档的地址系统</li><li>HTTP，一种传输协议，用于在给定文档的 URL 时查找文档</li><li>HTML，一种允许嵌入超链接的文档格式</li></ul><p>Web 上的一切都围绕着文档以及如何访问它们。Web 的最初目的是提供一种访问、阅读和浏览文本文档的简单方法。从那时起，Web 已经发展到提供对图像、视频和二进制数据的访问，但这些改进几乎没有改变三大支柱。</p><p>统一资源定位符 （URL） 是一个<code>文本字符串</code>，用于指定可以在 Internet 上找到资源（如网页、图像或视频）的位置。</p><p>在 HTTP 的上下文中，URL 称为“Web 地址”或“链接”。您的浏览器在其地址栏中显示 URL，例如：<code>https://developer.mozilla.org</code></p><ul><li>某些浏览器仅显示 URL 中“&#x2F;&#x2F;”之后的部分，即域名。</li></ul><p>URL 还可用于文件传输 （FTP）、电子邮件 （SMTP） 和其他应用程序。</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>以下是一些URL示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>developer.mozilla.org<br>https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/en-US/</span>docs<span class="hljs-regexp">/Learn/</span><br>https:<span class="hljs-regexp">//</span>developer.mozilla.org<span class="hljs-regexp">/en-US/</span>search?q=URL<br></code></pre></td></tr></table></figure><p><img src="/images/web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" alt="URL组成"></p><p>可以将 URL 视为常规的邮政地址：</p><ul><li>Scheme 代表您要使用的邮政服务，Domain Name(域名)是城市或城镇，Port类似于邮政编码;</li><li>路径代表应将邮件投递的建筑物;这些参数代表额外的信息，例如建筑物中公寓的编号;</li><li>最后，锚点代表向其发送邮件的实际人。</li></ul><h4 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h4><p>URL的第一部分是Scheme，它表示浏览器必须用于请求资源的协议。</p><ul><li>协议是在计算机网络中交换或传输数据的固定方法。</li><li>通常对于网站，协议是<code>HTTPS</code>或<code>HTTP</code>（其不安全版本）。<ul><li>寻址网页需要这两者之一，但浏览器也知道如何处理其他方案，例如（打开邮件客户端），因此，如果您看到其他协议，请不要感到惊讶。<code>mailto:</code></li></ul></li></ul><h4 id="Authority"><a href="#Authority" class="headerlink" title="Authority"></a>Authority</h4><p>Authority通过<code>://</code>与Scheme分开,包括域 （e.） 和端口 （），用冒号分隔：:&#x2F;&#x2F;<a href="http://www.example.com80/">www.example.com80</a></p><ul><li>Domain Name:<br>指正在请求的 Web 服务器。通常这是一个域名，但也可以使用 IP 地址（但这很少见，因为它不太方便）。</li><li>Port：<br>端口表示用于访问 Web 服务器上的资源的技术“门”。如果 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）来授予对其资源的访问权限，则通常会省略它。<ul><li>不使用的Authority 的URL 示例是邮件客户端 。它包含一个Scheme，但不使用Authority。因此，冒号后面没有两个斜杠，仅充当方案和邮件地址之间的分隔符。mailto:foobar</li></ul></li></ul><h4 id="Path-to-resouorce"><a href="#Path-to-resouorce" class="headerlink" title="Path to resouorce"></a>Path to resouorce</h4><p><code>/path/to/myfile.html</code>是 Web 服务器上资源的路径。在 Web 的早期，像这样的路径表示 Web 服务器上的物理文件位置。如今，它主要是由 Web 服务器处理的抽象，没有任何物理现实。</p><h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h4><p><code>?key1=value1&amp;key2=value2</code>是提供给 Web 服务器的额外参数。这些参数是用符号分隔的键&#x2F;值对列表。在返回资源之前，Web 服务器可以使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则。</p><h4 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a>Anchor</h4><p><code>#SomewhereInTheDocument</code>是资源本身的另一部分的锚点。</p><p>锚点代表资源内部的一种“书签”，为浏览器提供指示，以显示位于该“书签”位置的内容。</p><ul><li>例如，在 HTML 文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚点所代表的时间。</li><li><code>#</code> 后面的部分，也称为<code>片段标识符</code>，永远不会随请求一起发送到服务器。</li></ul><h3 id="使用URL"><a href="#使用URL" class="headerlink" title="使用URL"></a>使用URL</h3><p>HTML 语言大量使用 URL：</p><ul><li>使用<code>&lt;a&gt;</code>元素创建指向其他文档的链接;</li><li>通过各种元素（如<code> &lt;link&gt;</code> 或 <code>&lt;script&gt;</code> 将文档与其相关资源链接起来。</li><li>显示媒体，如图像（带有 <code>&lt;img&gt; </code>元素）、视频（带有<code> &lt;video&gt;</code> 元素）、声音和音乐（带有 <code>&lt;audio&gt;</code> 元素）等;</li><li>显示带有<code>&lt;iframe&gt;</code> 元素的其他 HTML 文档。</li></ul><p>注意：在指定 URL 以将资源作为页面的一部分加载时，通常应仅使用 HTTP 和 HTTPS URL。</p><h3 id="绝对URL与相对URL"><a href="#绝对URL与相对URL" class="headerlink" title="绝对URL与相对URL"></a>绝对URL与相对URL</h3><p>URL 标准定义了两者 — 尽管它使用术语<code>绝对 URL 字符串</code>和<code>相对 URL 字符串</code>，以将它们与 URL 对象（它们是 URL 的内存表示形式）区分开来。</p><p>URL 的必需部分在很大程度上取决于使用 URL 的上下文。</p><ul><li><p>在浏览器的地址栏中，URL 没有任何上下文，因此您必须提供一个完整（或绝对）的 URL，就像我们上面看到的一样。您不需要包含协议（浏览器默认使用 HTTP）或端口（仅当目标 Web 服务器使用某些不寻常的端口时才需要），但 URL 的所有其他部分都是必需的。</p></li><li><p>当在文档中使用 URL 时，例如在 HTML 页面中，情况会有所不同。由于浏览器已经拥有文档自己的 URL，因此它可以使用此信息来填充该文档中任何可用 URL 的缺失部分。我们可以通过仅查看 URL 的路径部分来区分绝对 URL 和相对 URL。如果 URL 的路径部分以 <code>/</code> 字符开头，则浏览器将从服务器的顶部根目录获取该资源，而不引用当前文档给出的上下文。</p></li></ul><p>例如：<code>https://developer.mozilla.org/en-US/docs/Learn</code>本身是一个绝对的 URL。它具有找到它指向的资源所需的所有必要部分。</p><ul><li>相对于Scheme的 URL<br> 仅缺少协议。浏览器将使用与用于加载托管该 URL 的文档相同的协议。<code>//developer.mozilla.org/en-US/docs/Learn</code></li><li>Domain Name相对URL：<br>协议和域名都丢失。浏览器将使用与用于加载托管该 URL 的文档相同的协议和相同的域名。<code>/en-US/docs/Learn</code></li><li>子资源：<br>协议和域名缺失，浏览器将尝试在包含当前资源的子目录中查找文档。在这种情况下访问此 URL：<br><code>.Common_questions/Web_mechanics/What_is_a_URL</code></li><li>仅Auchor：<br>除锚外的所有部件都丢失。浏览器将使用当前文档的 URL 并替换或添加锚点部分。当您想要链接到当前文档的特定部分时，这很有用。<code>#semantic_urls</code></li></ul><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>由于人类可读，URL 已经让事情变得更容易，但是每当您想要访问文档时，都很难输入长 URL。这就是<code>超链接</code>彻底改变一切的地方。链接可以将任何文本字符串与 URL 关联起来，这样用户就可以通过激活链接立即访问目标文档。</p><h4 id="超链接的类型"><a href="#超链接的类型" class="headerlink" title="超链接的类型"></a>超链接的类型</h4><ul><li><p>内部链接<br>两个网页之间的链接，如果两个网页属于同一个网站，则称为内部链接。</p><ul><li>没有内部链接，就没有网站这样的东西（当然，除非它是一个单页网站）。</li></ul></li><li><p>外部链接<br>从您的网页到其他人的网页的链接。</p><ul><li>没有外部链接，就没有Web，因为Web是网页的网络。使用外部链接提供信息，而不是通过您的网页提供的内容。</li></ul></li><li><p>传入链接<br>从他人的网页到您网站的链接。它与外部链接相反。</p><ul><li>请注意，当有人链接到您的网站时，您不必链接回去。</li></ul></li></ul><p>当你刚开始时，你不必那么担心外部和传入链接，但如果你想让搜索引擎找到你的网站，它们非常重要</p><h4 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h4><p>大多数链接将两个网页联系在一起。锚点将一个文档的两个部分联系在一起。当您点击指向锚点的链接时，您的浏览器会跳转到当前文档的另一部分，而不是加载新文档。</p><h4 id="链接和搜索引擎"><a href="#链接和搜索引擎" class="headerlink" title="链接和搜索引擎"></a>链接和搜索引擎</h4><p>链接对用户和搜索引擎都很重要。每次搜索引擎抓取网页时，它们都会按照网页上可用的链接为网站编制索引。搜索引擎不仅通过跟踪链接来发现网站的各个页面，而且还使用链接的可见文本来确定哪些搜索查询适合到达目标网页。</p><p>链接会影响搜索引擎链接到您的网站的难易程度。</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>任何连接到互联网的计算机都可以通过公共 IP 地址访问，无论是 IPv4 地址（例如 ）还是 IPv6 地址（例如）。</p><p>IP地址便于计算机处理，但是不具有人类可读性，因此使用域名。</p><h3 id="域名的结构"><a href="#域名的结构" class="headerlink" title="域名的结构"></a>域名的结构</h3><p>域名有一个简单的结构，由几个部分组成（可能只是一个部分、两个部分、三个部分……），用点分隔，从右到左阅读。其中每个部分都提供了有关整个域名的特定信息。</p><ul><li>TLD:顶级域名<br>顶级域名告诉用户域名背后的服务的一般目的。最通用的 TLD （， ， ） 不需要 Web 服务满足任何特定标准，但一些 TLD 执行更严格的政策，因此更清楚地了解其目的。例如：<code>.com</code>,<code>.org</code>,<code>.net</code><ul><li>本地顶级域名可以要求以特定语言提供服务或在特定国家&#x2F;地区托管<ul><li>它们应该以特定语言或国家&#x2F;地区表示资源。<code>.us</code>,<code>.fr</code>,<code>.se</code></li></ul></li><li>一些顶级域名仅允许政府部门使用。<code>.gov</code></li><li>一些顶级域名仅供教育和学术机构使用。<code>.edu</code></li><li>TLD可以包含特殊字符以及拉丁字符。TLD 的最大长度为 63 个字符，但大多数约为 2-3 个字符。</li></ul></li><li>标签（或组件）<br>标签是 TLD 后面的内容。标签是一个不区分大小写的字符序列，长度从 1 到 63 个字符不等（字母和数字，-字符）</li><li>二级域 （SLD）<br>位于 TLD 正前方的标签。<ul><li>一个域名可以有许多标签（或组件）。形成域名不是强制性的，也没有必要有 3 个标签。</li><li>例如，<code>informatics.ed.ac.uk</code> 是一个有效的域名。</li><li>对于您控制的任何域（例如 <code>mozilla.org</code>），您可以创建“<code>子域</code>”，每个子域都有不同的内容，例如 <code>developer.mozilla.org</code>、<code>support.mozilla.org</code> 或 <code>bugzilla.mozilla.org</code></li></ul></li></ul><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>不能“永久购买域名”。这是为了让未使用的域名最终可供其他人再次使用。如果每个域名都被购买，网络很快就会填满未使用的域名，这些域名被锁定，任何人都无法使用。</p><p>取而代之的是，您需要为使用域名一年或更长时间的权利付费。您可以续展您的权利，并且您的续展优先于其他人的申请。但是您永远不会拥有该域名。</p><ul><li>称为注册商的公司使用域名注册机构来跟踪将您与您的域名联系起来的技术和管理信息。</li><li>对于某些域名，它可能不是负责跟踪的注册商。<ul><li>例如，下面的每个域名都由亚马逊管理。<code>.fire</code></li></ul></li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS数据库存储在全球的每个DNS服务器上，所有这些服务器都是指一些称为“权威名称服务器”或“顶级DNS服务器”的特殊服务器 </p><ul><li>这些服务器就像管理系统的老板服务器。<ul><li>每当您的注册商为给定域创建或更新任何信息时，都必须在每个 DNS 数据库中刷新该信息。每个知道给定域的DNS服务器都会将信息存储一段时间，然后自动失效，然后刷新（DNS服务器查询权威服务器并从中获取更新的信息）。因此，了解此域名的DNS服务器需要一些时间才能获取最新信息。</li></ul></li></ul><h4 id="DNS请求如何工作？"><a href="#DNS请求如何工作？" class="headerlink" title="DNS请求如何工作？"></a>DNS请求如何工作？</h4><p>正如我们已经看到的，当您想在浏览器中显示网页时，输入域名比输入 IP 地址更容易。让我们看一下过程：</p><ul><li>在浏览器的位置栏中输入内容。<code>mozilla.org</code></li><li>您的浏览器会询问您的计算机是否已经识别此域名标识的 IP 地址（使用<code>本地 DNS 缓存</code>）。<ul><li>如果是这样，则名称将转换为 IP 地址，浏览器将与 Web 服务器协商内容。故事到此结束。</li></ul></li><li>如果您的计算机不知道名称后面是哪个 IP，它会继续询问 DNS 服务器，该服务器的工作就是告诉您的计算机哪个 IP 地址与每个注册域名匹配。</li><li>现在计算机知道请求的 IP 地址，您的浏览器可以与 Web 服务器协商内容。</li></ul><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>Web 服务器可以指硬件或软件，或者两者协同工作。</p><ul><li>在硬件方面，Web 服务器是存储 Web 服务器软件和网站组件文件（例如，HTML 文档、图像、CSS 样式表和 JavaScript 文件）的计算机。Web 服务器连接到 Internet，并支持与连接到 Web 的其他设备进行物理数据交换。</li><li>在软件方面，Web 服务器包括几个部分，用于控制 Web 用户访问托管文件的方式。至少，这是一个 HTTP 服务器。     <ul><li>HTTP 服务器是理解 URL（网址）和 HTTP（浏览器用于查看网页的协议）的软件。HTTP服务器可以通过其存储的网站的域名进行访问，并将这些托管网站的内容传送到最终用户的设备。</li></ul></li></ul><p>在最基本的层面上，每当浏览器需要托管在 Web 服务器上的文件时，浏览器都会通过 HTTP 请求该文件。当请求到达正确的（硬件）Web 服务器时，（软件）HTTP 服务器接受请求，找到请求的文档，并将其发送回浏览器，也通过 HTTP。（如果服务器找不到请求的文档，它将返回 404 响应。</p><h3 id="静态or动态Web服务器"><a href="#静态or动态Web服务器" class="headerlink" title="静态or动态Web服务器"></a>静态or动态Web服务器</h3><ul><li><p>静态 Web 服务器或堆栈由计算机（硬件）和 HTTP 服务器（软件）组成。我们称其为“静态”，因为服务器将其托管文件按原样发送到您的浏览器。</p></li><li><p>动态 Web 服务器由静态 Web 服务器和额外的软件组成，最常见的是<code>应用程序服务器</code>和<code>数据库</code>。</p><ul><li>我们称其为“动态”，因为应用程序服务器在通过 HTTP 服务器将内容发送到您的浏览器之前会更新托管文件。</li><li>例如，为了生成在浏览器中看到的最终网页，应用程序服务器可能会使用数据库中的内容填充 HTML 模板。像MDN或Wikipedia这样的网站有数以千计的网页。通常，这类网站仅由几个 HTML 模板和一个巨大的数据库组成，而不是由数千个静态 HTML 文档组成。通过此设置，可以更轻松地维护和交付内容。</li></ul></li></ul><h3 id="托管文件"><a href="#托管文件" class="headerlink" title="托管文件"></a>托管文件</h3><p>首先，Web 服务器必须存储网站的文件，即所有 HTML 文档及其相关资产，包括图像、CSS 样式表、JavaScript 文件、字体和视频。</p><p>从技术上讲，您可以将所有这些文件托管在自己的计算机上，但将所有文件存储在专用的 Web 服务器上要方便得多，因为：</p><ul><li>专用 Web 服务器通常更可用（启动并运行）。</li><li>排除停机时间和系统故障，专用的 Web 服务器始终连接到 Internet。</li><li>专用 Web 服务器可以始终具有相同的 IP 地址。这称为专用 IP 地址。（并非所有 ISP 都为家庭线路提供固定的 IP 地址。</li><li>专用 Web 服务器通常由第三方维护。</li></ul><h3 id="通过-HTTP-进行通信"><a href="#通过-HTTP-进行通信" class="headerlink" title="通过 HTTP 进行通信"></a>通过 HTTP 进行通信</h3><p>Web 服务器提供对 HTTP （Hypertext Transfer Protocol） 的支持。顾名思义，<code>HTTP</code>指定了如何在两台计算机之间传输<code>超文本</code>（链接的Web文档）。</p><ul><li><p>协议是两台计算机之间通信的一组规则。HTTP 是一种<code>文本的无状态协议</code>。</p><ul><li>所有命令都是纯文本的，并且人类可读。</li><li>服务器和客户端都不记得以前的通信。例如，仅依赖 HTTP，服务器无法记住您输入的密码，也无法记住未完成事务的进度。您需要一个应用程序服务器来完成此类任务。</li></ul></li><li><p>通常只有客户端才会发出 HTTP 请求，并且只向服务器发出。</p><ul><li>通过 HTTP 请求文件时，客户端必须提供文件的 URL。</li></ul></li><li><p>服务器响应客户端的 HTTP 请求。服务器还可以通过一种称为服务器推送的机制，在请求数据之前将数据填充到客户端缓存中。</p><ul><li>Web 服务器必须响应每个 HTTP 请求，至少要回答一条错误消息。</li></ul></li><li><p>在 Web 服务器上，HTTP 服务器负责处理和应答传入的请求。</p><ul><li>收到请求后，HTTP 服务器会检查请求的 URL 是否与现有文件匹配。</li><li>如果是这样，Web 服务器会将文件内容发送回浏览器。如果没有，服务器将检查它是否应该为请求动态生成文件（请参阅静态与动态内容）。</li><li>如果这两个选项都不可行，Web 服务器将向浏览器返回一条错误消息，最常见的是 <code>404 Not Found</code>。 <ul><li>404 错误非常普遍，以至于一些网页设计师投入了大量的时间和精力来设计 404 错误页面。</li></ul></li></ul></li></ul><h1 id="Web入门"><a href="#Web入门" class="headerlink" title="Web入门"></a>Web入门</h1><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><h3 id="网站应该使用什么结构"><a href="#网站应该使用什么结构" class="headerlink" title="网站应该使用什么结构"></a>网站应该使用什么结构</h3><p>在我们创建的任何网站项目中，最常见的是一个主页 HTML 文件和包含图像、样式文件和脚本文件的文件夹。</p><ul><li><code>index.html</code>：这个文件一般会包含主页内容，也就是人们第一次进入网站时看到的文字和图片。<ul><li>使用文本编辑器，创建一个名为index.html的新文件，并将其保存在test-site文件夹内。</li></ul></li><li><code>images</code>文件夹：这个文件夹包含网站上使用的所有图片。<ul><li>在 test-site 文件夹内创建一个名为 images 的文件夹。</li></ul></li><li><code>styles</code> 文件夹：这个文件夹包含用于设置内容样式的 CSS 代码（例如，设置文本和背景颜色）。<ul><li>在你的 test-site 文件夹内创建一个名为 styles 的文件夹。</li></ul></li><li><code>scripts</code> 文件夹：这个文件夹包含所有用于向网站添加交互功能的 JavaScript 代码（例如，点击时加载数据的按钮）。<ul><li>在 test-site 文件夹内创建一个名为 scripts 的文件夹。</li></ul></li></ul><p>备注：在 Windows 上你可能看不到文件扩展名，因为 Windows 有一个默认开启的隐藏已知文件类型的扩展名的选项。一般来说，你可以通过 Windows 资源管理器，选择文件夹选项选项，取消勾选隐藏已知文件类型的扩展名复选框，然后点击确认将其关闭。</p><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>为使文件间正常交互，应为每个文件提供访问路径，所以一个文件知道另一个文件的位置。</p><p>文件路径的一些通用规则：</p><ul><li>若引用的目标文件与 HTML 文件同级，只需直接使用文件名，例如：my-image.jpg。</li><li>要引用子目录中的文件，请在路径前面写上目录名，再加上一个正斜杠。例如：subdirectory&#x2F;my-image.jpg。</li><li>若引用的目标文件位于 HTML 文件的上级，需要加上两个点。<ul><li>举个例子，如果 index.html 在 test-site 的一个子文件夹内，而 my-image.jpg 在 test-site 内，你可以使用..&#x2F;my-image.jpg 从 index.html 引用 my-image.jpg。</li></ul></li><li>以上方法可以随意组合，比如：..&#x2F;subdirectory&#x2F;another-subdirectory&#x2F;my-image.jpg。</li></ul><p>Windows 的文件系统使用反斜杠而不是正斜杠，例如：C:\Windows。这在 HTML 中并不重要——即使你在 Windows 系统上进行开发，你也应该在代码中使用正斜杠。</p><h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3><h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript学习指南</title>
    <link href="/2024/08/02/JavaScript%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2024/08/02/JavaScript%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>参照廖雪峰老师的教程，整理和记录JavaScript的学习过程~</p><span id="more"></span> <h1 id="速通语法"><a href="#速通语法" class="headerlink" title="速通语法"></a>速通语法</h1><ol><li><p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>&#123;...&#125;</code>。</p></li><li><p>{…}内的语句具有<code>缩进</code>，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。</p></li><li><p>注释：</p></li></ol><ul><li>行注释：&#x2F;&#x2F;</li><li>块注释：&#x2F;**&#x2F;</li></ul><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript不区分整数和浮点数，统一用Number表示。以下都是合法的Number类型：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">123</span>; <span class="hljs-regexp">//</span> 整数<span class="hljs-number">123</span><br><span class="hljs-number">0.456</span>; <span class="hljs-regexp">//</span> 浮点数<span class="hljs-number">0.456</span><br><span class="hljs-number">1.2345</span>e3; <span class="hljs-regexp">//</span> 科学计数法表示<span class="hljs-number">1.2345</span>x1000，等同于<span class="hljs-number">1234.5</span><br>-<span class="hljs-number">99</span>; <span class="hljs-regexp">//</span> 负数<br>NaN; <span class="hljs-regexp">//</span> NaN表示Not a Number，当无法计算结果时用NaN表示<br>Infinity; <span class="hljs-regexp">//</span> Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity<br></code></pre></td></tr></table></figure><p>Number可以直接做四则运算，规则和数学一致：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-comment">(1 + 2)</span> * <span class="hljs-number">5</span> / <span class="hljs-number">2</span>; <span class="hljs-comment">// 7.5</span><br><span class="hljs-number">2</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// Infinity</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span><br><span class="hljs-number">10</span> <span class="hljs-meta">%</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 1</span><br><span class="hljs-number">10.5</span> <span class="hljs-meta">%</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 1.5</span><br></code></pre></td></tr></table></figure><p>PS. </p><ul><li><code>%</code>是求余运算。</li><li>JavaScript的Number不区分整数和浮点数，也就是说，12.00 &#x3D;&#x3D;&#x3D; 12。（在大多数其他语言中，整数和浮点数不能直接比较）并且，JavaScript的整数最大范围不是±2的63次方，而是±2的53次方，因此，超过这个范围的整数就可能无法精确表示。</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。</p><ul><li>字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>，需要用转义字符<code>\</code>来标识。<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-symbol">&#x27;I</span>\<span class="hljs-symbol">&#x27;m</span> \<span class="hljs-string">&quot;OK\&quot;</span>!&#x27;; // I<span class="hljs-symbol">&#x27;m</span> <span class="hljs-string">&quot;OK&quot;</span>!<br></code></pre></td></tr></table></figure></li><li>一些常见的转义字符：<ul><li><code>\n</code>：换行</li><li><code>\t</code>表示制表符</li><li><code>\x##</code>表示ASCII字符  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;\x41&#x27;</span>; <span class="hljs-regexp">//</span> 完全等同于 <span class="hljs-string">&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure></li><li><code>\u####</code>表示一个Unicode字符  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;\u4e2d\u6587&#x27;</span>; <span class="hljs-regexp">//</span> 完全等同于 <span class="hljs-string">&#x27;中文&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><code>多行字符串</code>：由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号&#96;&#96;表示：  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`这是一个<br>多行<br>字符串`;<br></code></pre></td></tr></table></figure>  注意：反引号在键盘的ESC下方，数字键1的左边。</li><li><code>模板字符串</code>:<br>要把多个字符串连接起来，可以用+号连接：  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span><span class="hljs-built_in"> name</span> = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;你好, &#x27;</span> +<span class="hljs-built_in"> name</span> + <span class="hljs-string">&#x27;, 你今年&#x27;</span> + age + <span class="hljs-string">&#x27;岁了!&#x27;</span>;<br>alert(message);<br></code></pre></td></tr></table></figure>  ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">`你好, <span class="hljs-subst">$&#123;name&#125;</span>, 你今年<span class="hljs-subst">$&#123;age&#125;</span>岁了!`</span>;<br><span class="hljs-title function_">alert</span>(message);<br></code></pre></td></tr></table></figure></li></ul><h4 id="常用的字符串操作"><a href="#常用的字符串操作" class="headerlink" title="常用的字符串操作"></a>常用的字符串操作</h4><ul><li>获取字符串长度：  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let s = <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br>s.<span class="hljs-built_in">length</span>; <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure></li><li>获取字符串某个指定位置的字符:  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br><br>s[<span class="hljs-number">0</span>]; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;H&#x27;</span><br>s[<span class="hljs-number">6</span>]; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27; &#x27;</span><br>s[<span class="hljs-number">7</span>]; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;w&#x27;</span><br>s[<span class="hljs-number">12</span>]; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;!&#x27;</span><br>s[<span class="hljs-number">13</span>]; <span class="hljs-regexp">//</span> undefined 超出范围的索引不会报错，但一律返回undefined<br></code></pre></td></tr></table></figure></li><li>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。</li></ul><p>JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p><ul><li><code>toUpperCase()</code>:把一个字符串全部变为大写</li><li><code>toLowerCase()</code>:把一个字符串全部变为小写</li><li><code>indexOf()</code>:搜索指定字符串出现的位置  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let s = <span class="hljs-string">&#x27;hello, world&#x27;</span>;<br>s.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment">// 返回7</span><br>s.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;World&#x27;</span>); <span class="hljs-comment">// 没有找到指定的子串，返回-1</span><br></code></pre></td></tr></table></figure></li><li><code>substring()</code>:返回指定索引区间的子串  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> s = &#x27;hello, world&#x27;<br><span class="hljs-attribute">s</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); // 从索引<span class="hljs-number">0</span>开始到<span class="hljs-number">5</span>（不包括<span class="hljs-number">5</span>），返回&#x27;hello&#x27;<br><span class="hljs-attribute">s</span>.substring(<span class="hljs-number">7</span>); // 从索引<span class="hljs-number">7</span>开始到结束，返回&#x27;world&#x27;<br></code></pre></td></tr></table></figure></li></ul><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-literal">true</span>; <span class="hljs-regexp">//</span> 这是一个<span class="hljs-literal">true</span>值<br><span class="hljs-literal">false</span>; <span class="hljs-regexp">//</span> 这是一个<span class="hljs-literal">false</span>值<br><span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 这是一个<span class="hljs-literal">true</span>值<br><span class="hljs-number">2</span> &gt;= <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> 这是一个<span class="hljs-literal">false</span>值<br></code></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol><li>JavaScript允许对任意数据类型做比较：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; // true</span><br><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; // false</span><br></code></pre></td></tr></table></figure></li><li>JavaScript在设计时，有两种比较运算符：</li></ol><ul><li><code>==</code>：它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</li><li><code>===</code>:它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<ul><li>坚持使用&#x3D;&#x3D;&#x3D;比较！</li></ul></li></ul><ol start="3"><li><p>NaN和所有的其他值都不相等，包括它自己，需通过<code>isNaN()</code>函数判断是否为NaN。</p></li><li><p>浮点数的相等比较：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>/ <span class="hljs-number">3</span> === (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> / <span class="hljs-number">3</span>); // false<br></code></pre></td></tr></table></figure><p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.abs(<span class="hljs-number">1</span> / <span class="hljs-number">3</span> - (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> / <span class="hljs-number">3</span>)) &lt; <span class="hljs-number">0</span>.<span class="hljs-number">0000001</span>; // true<br></code></pre></td></tr></table></figure></li></ol><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>要精确表示比2的53次方还大的整数，可以使用内置的BigInt类型，它的表示方法是在整数后加一个n，例如9223372036854775808n，也可以使用BigInt()把Number和字符串转换成BigInt：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 使用BigInt:</span><br><span class="hljs-keyword">var</span> bi1 = <span class="hljs-number">9223372036854775807</span>n;<br><span class="hljs-keyword">var</span> bi2 = BigInt(<span class="hljs-number">12345</span>);<br><span class="hljs-keyword">var</span> bi3 = BigInt(<span class="hljs-string">&quot;0x7fffffffffffffff&quot;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bi1 === bi2); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bi1 === bi3); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bi1 + bi2);<br></code></pre></td></tr></table></figure><p>使用BigInt可以正常进行加减乘除等运算，结果仍然是一个BigInt，但不能把一个BigInt和一个Number放在一起运算。</p><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39; &#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p><p>在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。</p><p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。<code>undefined仅仅在判断函数参数是否传递的情况下有用</code>。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JavaScript的数组可以包括任意数据类型。</p><ul><li>数组用[]表示，元素之间用,分隔。<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>];<br></code></pre></td></tr></table></figure></li><li>另一种创建数组的方法是通过<code>Array()</code>函数实现：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">new</span> Array(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); // 创建了数组[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li></ul><p>数组的元素可以通过索引来访问。索引的起始值为0。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    age: <span class="hljs-number">20</span>,<br>    tags: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;web&#x27;</span>, <span class="hljs-string">&#x27;mobile&#x27;</span>],<br>    city: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>    hasCar: <span class="hljs-literal">true</span>,<br>    zipcode: <span class="hljs-literal">null</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’Bob’，zipcode属性为null。</p><p>要获取一个对象的属性，我们用对象变量.属性名的方式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">person.name; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;Bob&#x27;</span><br>person.zipcode; <span class="hljs-regexp">//</span> null<br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。</p><p>申明一个变量用var语句，比如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a; <span class="hljs-regexp">//</span> 申明了变量a，此时a的值为undefined<br>var <span class="hljs-variable">$b</span> = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 申明了变量<span class="hljs-variable">$b</span>，同时给<span class="hljs-variable">$b</span>赋值，此时<span class="hljs-variable">$b</span>的值为<span class="hljs-number">1</span><br>var s_007 = <span class="hljs-string">&#x27;007&#x27;</span>; <span class="hljs-regexp">//</span> s_007是一个字符串<br>var Answer = true; <span class="hljs-regexp">//</span> Answer是一个布尔值true<br>var t = null; <span class="hljs-regexp">//</span> t的值是null<br></code></pre></td></tr></table></figure><p>在JavaScript中，使用等号&#x3D;对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = <span class="hljs-number">123</span>; <span class="hljs-regexp">//</span> a的值是整数<span class="hljs-number">123</span><br>a = <span class="hljs-string">&#x27;ABC&#x27;</span>; <span class="hljs-regexp">//</span> a变为字符串<br></code></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a <span class="hljs-operator">=</span> <span class="hljs-number">123</span><span class="hljs-comment">; // a是整数类型变量，类型用int申明</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span><span class="hljs-comment">; // 错误：不能把字符串赋给整型变量</span><br></code></pre></td></tr></table></figure><p>要显示变量的内容，可以用<code>console.log(x)</code>，打开Chrome的控制台就可以看到结果。</p><ul><li>使用<code>console.log()</code>代替<code>alert()</code>的好处是可以避免弹出烦人的对话框。</li></ul><h3 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h3><ul><li>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量;</li><li>使用var申明的变量不是全局变量，它的范围被限制在该变量被申明的函数体内,同名变量在不同的函数体内互不冲突。</li><li>在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。<ul><li>启用strict模式的方法是在JavaScript代码的第一行写上：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li>另一种申明变量的方式是<code>let</code>，这也是现代JavaScript推荐的方式：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 用let申明变量:</span><br>let s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s);<br></code></pre></td></tr></table></figure>后续会补充介绍var和let的区别。</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p><p>例如：判断一个字符串是否是合法的Email</p><ol><li>创建一个匹配Email的正则表达式；</li><li>用该正则表达式去匹配用户的输入来判断是否合法。</li></ol><h3 id="如何用字符来描述字符"><a href="#如何用字符来描述字符" class="headerlink" title="如何用字符来描述字符"></a>如何用字符来描述字符</h3><p>在正则表达式中，如果直接给出字符，就是精确匹配。</p><ul><li><code>\d</code>：匹配一个数字</li><li><code>\w</code>：匹配一个字母or数字  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;00\d&#x27;可匹配&#x27;007&#x27;，但无法匹配&#x27;00A&#x27;；<br>&#x27;\d\d\d&#x27;可以匹配&#x27;010&#x27;；<br>&#x27;\w\w&#x27;可以匹配&#x27;js&#x27;；<br></code></pre></td></tr></table></figure></li><li><code>.</code>可以匹配任意字符<ul><li>‘js.’可以匹配’jsp’、’jss’、’js!’等等</li></ul></li><li><code>\s</code>匹配任何空白字符，包括空格、制表符（tab）、换行符等</li><li><code>\,</code>匹配逗号字符。逗号前面的反斜杠是用来转义逗号的，因为在字符集合中逗号没有特殊意义，但通常为了避免混淆，还是建议加上反斜杠</li><li>表示不定长字符：<ul><li>用<code>*</code>表示任意个字符（包括0个）</li><li>用<code>+</code>表示至少一个字符</li><li>用<code>?</code>表示0个or1个字符</li><li>用<code>&#123;n&#125;</code>表示n个字符</li><li>用<code>&#123;n，m&#125;</code>表示n-m个字符  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">\d&#123;<span class="hljs-number">3</span>&#125;\s+\d&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;<br><span class="hljs-comment">(1)</span> \d&#123;<span class="hljs-number">3</span>&#125;表示匹配<span class="hljs-number">3</span>个数字，例如<span class="hljs-string">&#x27;010&#x27;</span>；<br><span class="hljs-comment">(2)</span> \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配<span class="hljs-string">&#x27; &#x27;</span>，<span class="hljs-string">&#x27;\t\t&#x27;</span>等；<br><span class="hljs-comment">(3)</span> \d&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;表示<span class="hljs-number">3</span><span class="hljs-number">-8</span>个数字，例如<span class="hljs-string">&#x27;1234567&#x27;</span><br>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码<br></code></pre></td></tr></table></figure></li></ul></li><li>用[]表示范围<ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串,比如’a100’，’0_Z’，’js2015’等等</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线、组成的字符串，也就是JavaScript允许的变量名；</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）</li></ul></li><li><code>A|B</code>可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配’JavaScript’、’Javascript’、’javaScript’或者’javascript’</li><li><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头</li><li><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束</li></ul><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>JavaScript有两种方式创建一个正则表达式：</p><ul><li>第一种方式:直接通过&#x2F;正则表达式&#x2F;写出；</li><li>第二种方式:<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let re1 = <span class="hljs-regexp">/ABC\-001/</span>;<br>let re2 = new RegExp(<span class="hljs-string">&#x27;ABC\\-001&#x27;</span>);<br><br>re1; <span class="hljs-regexp">//</span> <span class="hljs-regexp">/ABC\-001/</span><br>re2; <span class="hljs-regexp">//</span> <span class="hljs-regexp">/ABC\-001/</span><br></code></pre></td></tr></table></figure></li></ul><p>RegExp对象的<code>test()</code>方法用于测试给定的字符串是否符合条件:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let re = <span class="hljs-regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;<br>re.test(<span class="hljs-string">&#x27;010-12345&#x27;</span>); <span class="hljs-regexp">//</span> true<br>re.test(<span class="hljs-string">&#x27;010-1234x&#x27;</span>); <span class="hljs-regexp">//</span> false<br>re.test(<span class="hljs-string">&#x27;010 12345&#x27;</span>); <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活。</p><ol><li>正常的切分代码<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;a b   c&#x27;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]无法识别连续的空格<br></code></pre></td></tr></table></figure></li><li>正则表达式<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;a b   c&#x27;</span>.split(<span class="hljs-regexp">/\s+/</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-string">&#x27;a,b, c  d&#x27;</span>.split(<span class="hljs-regexp">/[\s\,]+/</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-string">&#x27;a,b;; c  d&#x27;</span>.split(<span class="hljs-regexp">/[\s\,\;]+/</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br></code></pre></td></tr></table></figure>split 方法会根据正则表达式显示的匹配模式来分割字符串。</li></ol><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>正则表达式还可以用于提取子串。用<code>()</code>表示的就是要提取的分组（Group）。</p><p>eg.<code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let re = <span class="hljs-regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;<br>re.exec(<span class="hljs-string">&#x27;010-12345&#x27;</span>); <span class="hljs-regexp">//</span> [<span class="hljs-string">&#x27;010-12345&#x27;</span>, <span class="hljs-string">&#x27;010&#x27;</span>, <span class="hljs-string">&#x27;12345&#x27;</span>]<br>re.exec(<span class="hljs-string">&#x27;010 12345&#x27;</span>); <span class="hljs-regexp">//</span> null<br></code></pre></td></tr></table></figure><p>如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。</p><ul><li><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。<ul><li>在匹配失败时返回null</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> re = /^(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])\:(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])\:(<span class="hljs-number">0</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">4</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])$/;<br><span class="hljs-attribute">re</span>.exec(&#x27;<span class="hljs-number">19</span>:<span class="hljs-number">05</span>:<span class="hljs-number">30</span>&#x27;); //<span class="hljs-meta"> [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span><br></code></pre></td></tr></table></figure><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证,对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。</p><ul><li>为了统一解析，JSON的字符集必须是UTF-8，字符串规定必须用双引号<code>&quot;&quot;</code>,Object的键也必须用双引号<code>&quot;&quot;</code>。</li><li>几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。<ul><li>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</li><li>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</li></ul></li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>把小明这个对象序列化成JSON格式的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.65</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;  &#x27;</span>); <span class="hljs-comment">//要输出得好看一些，可以加上参数，按缩进输出</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure><ul><li>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">JSON</span>.stringify(xiaoming, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;skills&#x27;</span>], <span class="hljs-string">&#x27;  &#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//下面的代码把所有属性值都变成大写</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toUpperCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, convert, <span class="hljs-string">&#x27;  &#x27;</span>);   <br></code></pre></td></tr></table></figure></li><li>还可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.65</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>],<br>    <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 只输出name和age，并且改变了key：</span><br>            <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<br>            <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span><br>        &#125;;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming); <span class="hljs-comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">JSON</span>.parse(&#x27;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,true]&#x27;); //<span class="hljs-meta"> [1, 2, 3, true]</span><br><span class="hljs-attribute">JSON</span>.parse(&#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">14</span>&#125;&#x27;); // Object &#123;name: &#x27;小明&#x27;, age: <span class="hljs-number">14</span>&#125;<br><span class="hljs-attribute">JSON</span>.parse(&#x27;true&#x27;); // true<br><span class="hljs-attribute">JSON</span>.parse(&#x27;<span class="hljs-number">123</span>.<span class="hljs-number">45</span>&#x27;); // <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>JSON.parse()还可以接收一个函数，用来转换解析出的属性:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;name&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value + <span class="hljs-string">&#x27;同学&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象的两个基本概念：</p><ul><li>类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；</li><li>实例：实例是根据类创建的对象，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。</li></ul><p>在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象:</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.2</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// 基于Student原型创建一个新对象:</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Student</span>);<br>    <span class="hljs-comment">// 初始化新对象:</span><br>    s.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-title function_">createStudent</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 小明 is running...</span><br>xiaoming.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Student</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象。例如：Object.prototype 生成Student.prototype，它同时生成了一个Student对象 Student.protoytype，Student.prototype 可以生成xiaoming之类的对象（类似继承）。</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</p><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p><ul><li>Array是一个对象，它的原型是Array.prototype，是由Object.prototype构建的，Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。</li><li>函数也是一个对象，它的原型是Function.prototype，是由Object.prototype构建的，由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>除了直接用{ … }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(name)</span> &#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.hello = <span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;<br>        alert(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用关键字new来调用这个函数，并返回一个对象：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let xiaoming = new Student(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.name; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;小明&#x27;</span><br>xiaoming.hello(); <span class="hljs-regexp">//</span> Hello, 小明!<br></code></pre></td></tr></table></figure><p>注意，如果<code>不写new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的this指向新创建的对象，并<code>默认返回this</code>，也就是说，不需要在最后写return this;。</p><ul><li>用new Student()创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数Student本身</li><li>如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要<code>共享同一个函数</code>就可以了，这样可以节省很多内存。<br>  -要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的new操作。一个常用的编程模式像这样：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;匿名&#x27;</span>; <span class="hljs-comment">// 默认值为&#x27;匿名&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>; <span class="hljs-comment">// 默认值为1</span><br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(props || &#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let xiaoming = createStudent(&#123;<br>    name: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;);<br><br>xiaoming.grade; <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。</li></ul><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>JavaScript的原型继承实现方式就是：</p><ol><li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li><li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li><li>继续在新的构造函数的原型上定义新方法。</li></ol><p>例如：<br>基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span><span class="hljs-params">(props)</span> &#123;<br>    <span class="hljs-comment">// 调用Student构造函数，绑定this变量:</span><br>    Student.call(<span class="hljs-keyword">this</span>, props);<br>    <span class="hljs-keyword">this</span>.grade = props.grade || <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">new</span> PrimaryStudent<span class="hljs-function"><span class="hljs-params">()</span> --&gt;</span> PrimaryStudent.prototype --&gt; <span class="hljs-built_in">Object</span>.prototype --&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>满足要求的原型链是:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">new</span> PrimaryStudent<span class="hljs-function"><span class="hljs-params">()</span> --&gt;</span> PrimaryStudent.prototype --&gt; Student.prototype --&gt; <span class="hljs-built_in">Object</span>.prototype --&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。</p><p>我们必须借助一个<code>中间对象</code>来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个<code>空函数F</code>来实现：</p><ul><li><p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// PrimaryStudent构造函数:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 空函数F:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-comment">// 把F的原型指向Student.prototype:</span><br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><br><span class="hljs-comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br><br><span class="hljs-comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">PrimaryStudent</span>;<br><br><span class="hljs-comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getGrade</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>&#125;;<br><br><span class="hljs-comment">// 创建xiaoming:</span><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimaryStudent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-number">2</span><br>&#125;);<br>xiaoming.<span class="hljs-property">name</span>; <span class="hljs-comment">// &#x27;小明&#x27;</span><br>xiaoming.<span class="hljs-property">grade</span>; <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 验证原型:</span><br>xiaoming.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>xiaoming.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 验证继承关系:</span><br>xiaoming <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PrimaryStudent</span>; <span class="hljs-comment">// true</span><br>xiaoming <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-keyword">let</span> F = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个inherits()函数可以复用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unnamed&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现原型继承链:</span><br><span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">PrimaryStudent</span>, <span class="hljs-title class_">Student</span>);<br><br><span class="hljs-comment">// 绑定其他方法到PrimaryStudent原型:</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getGrade</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h3><p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>class的定义包含了构造函数<code>constructor</code>和定义在<code>原型对象上的函数hello()</code>（注意没有function关键字），这样就避免了<code>Student.prototype.hello = function () &#123;...&#125;</code>这样分散的代码。</p></li><li><p>通过<code>extend</code>实现类的继承：</p><ul><li><p>PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。</p></li><li><p>PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。</p></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimaryStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;<br>    constructor(name, grade) &#123;<br>        <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">// 记得用super调用父类的构造方法!</span><br>        <span class="hljs-keyword">this</span>.grade = grade;<br>    &#125;<br><br>    myGrade() &#123;<br>        alert(&#x27;<span class="hljs-type">I</span> am at grade &#x27; + <span class="hljs-keyword">this</span>.grade);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。</p><p>在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。</p><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>window对象不但充当<code>全局作用域</code>，而且表示<code>浏览器窗口</code>。</p><ul><li>window对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。<ul><li>对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;window inner size: &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> + <span class="hljs-string">&#x27; x &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>navigator对象表示浏览器的信息，最常用的属性包括：</p><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的User-Agent字符串。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;appName = &#x27;</span> + navigator.appName);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;appVersion = &#x27;</span> + navigator.appVersion);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;language = &#x27;</span> + navigator.language);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;platform = &#x27;</span> + navigator.platform);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;userAgent = &#x27;</span> + navigator.userAgent);<br></code></pre></td></tr></table></figure>navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。</li><li>充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="判断浏览器版本"><a href="#判断浏览器版本" class="headerlink" title="判断浏览器版本"></a>判断浏览器版本</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">IEVersion(<span class="hljs-params">navigator</span>.<span class="hljs-params">userAgent</span>)</span><br></code></pre></td></tr></table></figure><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>screen对象表示屏幕的信息，常用的属性有：</p><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>location对象表示当前页面的URL信息。</p><ul><li>可以用<code>location.href</code>获取当前页面的URL。</li><li>要获得URL各个部分的值，可以这么写：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">location.protocol; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;http&#x27;</span><br>location.host; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;www.example.com&#x27;</span><br>location.port; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;8080&#x27;</span><br>location.pathname; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;/path/index.html&#x27;</span><br>location.search; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;?a=1&amp;b=2&#x27;</span><br>location.hash; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;TOP&#x27;</span><br></code></pre></td></tr></table></figure></li><li>要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用<code>location.reload()</code>方法非常方便。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> (confirm(<span class="hljs-string">&#x27;重新加载当前页&#x27;</span> + <span class="hljs-keyword">location</span>.href + <span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">location</span>.reload();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">location</span>.assign(<span class="hljs-string">&#x27;/&#x27;</span>); // 设置一个新的URL地址<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p><ul><li><p>document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.title</span> = <span class="hljs-string">&#x27;努力学习JavaScript!&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>用document对象提供的<code>getElementById()</code>和<code>getElementsByTagName()</code>可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> menu = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drink-menu&#x27;</span>);<br><span class="hljs-keyword">let</span> drinks = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;dt&#x27;</span>);<br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;提供的饮料有:&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;drinks.<span class="hljs-property">length</span>; i++) &#123;<br>    s = s + drinks[i].<span class="hljs-property">innerHTML</span> + <span class="hljs-string">&#x27;,&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure></li><li><p>document对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。</p><ul><li>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</li><li>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</li><li>JavaScript可以通过document.cookie读取到当前页面的Cookie：  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">document.cookie; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;v=123; remember=true; prefer=zh&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 当前页面在wwwexample.com --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.foo.com/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<a href="http://www.example.com网站的用户登录信息.服务器在设置cookie时可以使用`httponly`,设定了httponly的cookie将不能被javascript读取.这个行为由浏览器实现,主流浏览器均支持httponly选项,ie从ie6/">www.example.com网站的用户登录信息。服务器在设置Cookie时可以使用`httpOnly`，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6</a> SP1开始支持。</p></li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history对象保存了浏览器的历史记录，JavaScript可以调用<code>history.back()</code>或<code>history.forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p><p>对使用AJAX动态加载的页面，如果希望页面更新时同时更新history对象，应当使用history.pushState()方法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">// when AJAX is done:<br>let <span class="hljs-keyword">state</span> = &#x27;any-data&#x27;;<br>let newUrl = &#x27;/ajax.html<span class="hljs-comment">#signin&#x27;;</span><br>history.pushState(<span class="hljs-keyword">state</span>, &#x27;&#x27;, newUrl);<br></code></pre></td></tr></table></figure><p>当用户点击“后退”时，浏览器并不会刷新页面，而是触发popstate事件，可由JavaScript捕获并更新相应的部分页面内容。</p><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p><p>始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p><ul><li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li><li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li><li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li><li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li></ul><h3 id="拿到一个DOM节点"><a href="#拿到一个DOM节点" class="headerlink" title="拿到一个DOM节点"></a>拿到一个DOM节点</h3><p>（1）第一种方法：</p><ul><li>document.getElementById()</li><li>document.getElementsByTagName()</li><li>document.getElementsByClassName() （CSS选择器）</li></ul><p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 返回ID为&#x27;test&#x27;的节点：</span><br><span class="hljs-keyword">let</span> test = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>&#x27;)</span>;<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span><br><span class="hljs-keyword">let</span> trs = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>-<span class="hljs-params">table</span>&#x27;)</span>.get<span class="hljs-constructor">ElementsByTagName(&#x27;<span class="hljs-params">tr</span>&#x27;)</span>;<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span><br><span class="hljs-keyword">let</span> reds = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>-<span class="hljs-params">div</span>&#x27;)</span>.get<span class="hljs-constructor">ElementsByClassName(&#x27;<span class="hljs-params">red</span>&#x27;)</span>;<br><br><span class="hljs-comment">// 获取节点test下的所有直属子节点:</span><br><span class="hljs-keyword">let</span> cs = test.children;<br><br><span class="hljs-comment">// 获取节点test下第一个、最后一个子节点：</span><br><span class="hljs-keyword">let</span> first = test.firstElementChild;<br><span class="hljs-keyword">let</span> last = test.lastElementChild;<br></code></pre></td></tr></table></figure><p>（2）第二种方法：需要了解selector语法，然后使用条件来获取节点，更加方便</p><ul><li>querySelector()</li><li>querySelectorAll()<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 通过querySelector获取ID为q1的节点：</span><br><span class="hljs-keyword">let</span> q1 = document.query<span class="hljs-constructor">Selector(&#x27;#<span class="hljs-params">q1</span>&#x27;)</span>;<br><br><span class="hljs-comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span><br><span class="hljs-keyword">let</span> ps = q1.query<span class="hljs-constructor">SelectorAll(&#x27;<span class="hljs-params">div</span>.<span class="hljs-params">highlighted</span> &gt; <span class="hljs-params">p</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure></li></ul><p>严格地讲，我们这里的DOM节点是指<code>Element</code>，但是DOM节点实际上是<code>Node</code>，在HTML中，<code>Node包括Element、Comment、CDATA_SECTION等</code>很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。<code>根节点Document已经自动绑定为全局变量document</code>。</p><p>练习(通过！)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-div&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-p&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-red c-green&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Ruby<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Swift<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-green&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请选择出指定条件的节点：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 选择<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>:<br><span class="hljs-keyword">let</span> js =<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;test-p&#x27;</span>);<br><br>// 选择<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Ruby<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>,<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Swift<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>:<br><span class="hljs-keyword">let</span> arr =<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;test-div&#x27;</span>).getElementsByClassName(<span class="hljs-string">&#x27;c-red c-green&#x27;</span>)[<span class="hljs-number">0</span>].children;<br><br>// 选择<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>:<br><span class="hljs-keyword">let</span> haskell =<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;test-div&#x27;</span>).getElementsByClassName(<span class="hljs-string">&#x27;c-green&#x27;</span>)[<span class="hljs-number">1</span>].lastElementChild;<br><br>// 测试:<br><span class="hljs-keyword">if</span> (!js || js.innerText !== <span class="hljs-string">&#x27;JavaScript&#x27;</span>) &#123;<br>    alert(<span class="hljs-string">&#x27;选择JavaScript失败!&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!arr || arr.length !== <span class="hljs-number">3</span> || !arr[<span class="hljs-number">0</span>] || !arr[<span class="hljs-number">1</span>] || !arr[<span class="hljs-number">2</span>] || arr[<span class="hljs-number">0</span>].innerText !== <span class="hljs-string">&#x27;Python&#x27;</span> || arr[<span class="hljs-number">1</span>].innerText !== <span class="hljs-string">&#x27;Ruby&#x27;</span> || arr[<span class="hljs-number">2</span>].innerText !== <span class="hljs-string">&#x27;Swift&#x27;</span>) &#123;<br>    console.log(<span class="hljs-string">&#x27;选择Python,Ruby,Swift失败!&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!haskell || haskell.innerText !== <span class="hljs-string">&#x27;Haskell&#x27;</span>) &#123;<br>    console.log(<span class="hljs-string">&#x27;选择Haskell失败!&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;测试通过!&#x27;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><p>拿到一个DOM节点后，我们可以对它进行更新。</p><p>可以直接修改节点的文本，方法有两种：</p><ul><li><p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取&lt;p id=<span class="hljs-string">&quot;p-id&quot;</span>&gt;...&lt;/p&gt;<br>let p = document.getElementById(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置文本为abc:<br>p.innerHTML = <span class="hljs-string">&#x27;ABC&#x27;</span>; <span class="hljs-regexp">//</span> &lt;p id=<span class="hljs-string">&quot;p-id&quot;</span>&gt;ABC&lt;/p&gt;<br><span class="hljs-regexp">//</span> 设置HTML:<br>p.innerHTML = <span class="hljs-string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;<br><span class="hljs-regexp">//</span> &lt;p&gt;...&lt;/p&gt;的内部结构已修改<br></code></pre></td></tr></table></figure><p>用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到的，要注意对字符编码来避免XSS攻击。</p></li><li><p>第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 获取<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p-id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="hljs-keyword">let</span> p =<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br>// 设置文本:<br>p.innerText = <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;<br>// HTML被自动编码，无法设置一个<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">节点:</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// </span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p-id&quot;</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(&quot;Hi&quot;)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span></span><br></code></pre></td></tr></table></figure><p>两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。</p></li></ul><h4 id="修改CSS"><a href="#修改CSS" class="headerlink" title="修改CSS"></a>修改CSS</h4><p>修改CSS也是经常需要的操作。DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为<code>驼峰式命名fontSize</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取&lt;p id=<span class="hljs-string">&quot;p-id&quot;</span>&gt;...&lt;/p&gt;<br>let p = document.getElementById(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置CSS:<br>p.style.color = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>p.style.fontSize = <span class="hljs-string">&#x27;20px&#x27;</span>;<br>p.style.paddingTop = <span class="hljs-string">&#x27;2em&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本小节练习：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 获取&lt;p&gt;javascript&lt;/p&gt;节点:</span><br>let js = document.getElementById(<span class="hljs-string">&#x27;test-js&#x27;</span>);<br><br><span class="hljs-comment">// 修改文本为JavaScript:</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>js.innerHTML= <span class="hljs-string">&#x27;JavaScript&#x27;</span>;<br><span class="hljs-comment">// 修改CSS为: color: #ff0000, font-weight: bold</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>js.style.<span class="hljs-keyword">color</span> = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>js.style.fontWeight= <span class="hljs-string">&#x27;bold&#x27;</span>;<br><span class="hljs-comment">// 测试:</span><br><span class="hljs-keyword">if</span> (js &amp;&amp; js.parentNode &amp;&amp; js.parentNode.id === <span class="hljs-string">&#x27;test-div&#x27;</span> &amp;&amp; js.id === <span class="hljs-string">&#x27;test-js&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (js.innerText === <span class="hljs-string">&#x27;JavaScript&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (js.style &amp;&amp; js.style.fontWeight === <span class="hljs-string">&#x27;bold&#x27;</span> &amp;&amp; (js.style.<span class="hljs-keyword">color</span> === <span class="hljs-string">&#x27;red&#x27;</span> || js.style.<span class="hljs-keyword">color</span> === <span class="hljs-string">&#x27;#ff0000&#x27;</span> || js.style.<span class="hljs-keyword">color</span> === <span class="hljs-string">&#x27;#f00&#x27;</span> || js.style.<span class="hljs-keyword">color</span> === <span class="hljs-string">&#x27;rgb(255, 0, 0)&#x27;</span>)) &#123;<br>            console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;测试通过!&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;CSS样式测试失败!&#x27;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;文本测试失败!&#x27;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;节点测试失败!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><p>当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？</p><ul><li><p>如果这个DOM节点是空的，例如，<div></div>，那么，直接使用<code>innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。</p></li><li><p>如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。</p><ul><li>使用<code>appendChild</code>，把一个子节点添加到父节点的最后一个子节点。  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  把<code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id=&quot;list&quot;&gt;</code>的最后一项：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span><br>    js = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">js</span>&#x27;)</span>,<br>    <span class="hljs-built_in">list</span> = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">list</span>&#x27;)</span>;<br><span class="hljs-built_in">list</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">js</span>)</span>;<br></code></pre></td></tr></table></figure>  因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。</li><li>从零创建一个新的节点，然后插入到指定位置：  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span><br>    list =<span class="hljs-built_in"> document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>),<br>    haskell =<span class="hljs-built_in"> document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br>haskell<span class="hljs-built_in">.id</span> = <span class="hljs-string">&#x27;haskell&#x27;</span>;<br>haskell.innerText = <span class="hljs-string">&#x27;Haskell&#x27;</span>;<br>list.appendChild(haskell);<br></code></pre></td></tr></table></figure>  这样我们就动态添加了一个新的节点：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;haskell&quot;</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个<code>&lt;style&gt;</code>节点，然后把它添加到<code>&lt;head&gt;</code>节点的末尾，这样就动态地给文档添加了新的CSS定义：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> d = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">style</span>&#x27;)</span>;<br>d.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">type</span>&#x27;, &#x27;<span class="hljs-params">text</span><span class="hljs-operator">/</span><span class="hljs-params">css</span>&#x27;)</span>; <br>d.innerHTML = &#x27;p &#123; color: red &#125;&#x27;;<br>document.get<span class="hljs-constructor">ElementsByTagName(&#x27;<span class="hljs-params">head</span>&#x27;)</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.append<span class="hljs-constructor">Child(<span class="hljs-params">d</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>使用<code>insertBefore</code>将子节点插入到指定的位置：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">parentElement.insert<span class="hljs-constructor">Before(<span class="hljs-params">newElement</span>, <span class="hljs-params">referenceElement</span>)</span>;<br></code></pre></td></tr></table></figure>  子节点会插入到referenceElement之前。<br>  还是以上面的HTML为例，假定我们要把Haskell插入到Python之前：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  可以这么写：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span><br>    <span class="hljs-built_in">list</span> = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">list</span>&#x27;)</span>,<br>    <span class="hljs-built_in">ref</span> = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">python</span>&#x27;)</span>,<br>    haskell = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">p</span>&#x27;)</span>;<br>haskell.id = &#x27;haskell&#x27;;<br>haskell.innerText = &#x27;Haskell&#x27;;<br><span class="hljs-built_in">list</span>.insert<span class="hljs-constructor">Before(<span class="hljs-params">haskell</span>, <span class="hljs-params">ref</span>)</span>;<br></code></pre></td></tr></table></figure>  可见，使用insertBefore重点是要拿到一个<code>参考子节点</code>的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>    i, c,<br>    list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    c = list.<span class="hljs-property">children</span>[i]; <span class="hljs-comment">// 拿到第i个子节点</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p>对于一个已有的HTML结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Ruby<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>按字符串顺序重新排序DOM节点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// sort list:</span><br>list = document.getElementById(<span class="hljs-string">&#x27;test-list&#x27;</span>);<br><span class="hljs-built_in">sort</span> = <span class="hljs-built_in">Array</span>.from(list.children).<span class="hljs-built_in">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.innerText &gt; b.innerText ? <span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span> (let e of <span class="hljs-built_in">sort</span>) list.appendChild(e);<br><br><span class="hljs-comment">// 测试:</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    let<br>        arr, i,<br>        t = document.getElementById(<span class="hljs-string">&#x27;test-list&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (t &amp;&amp; t.children &amp;&amp; t.children.<span class="hljs-built_in">length</span> === <span class="hljs-number">5</span>) &#123;<br>        arr = [];<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;t.children.<span class="hljs-built_in">length</span>; i++) &#123;<br>            arr.<span class="hljs-built_in">push</span>(t.children[i].innerText);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr.toString() === [<span class="hljs-string">&#x27;Haskell&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Scheme&#x27;</span>].toString()) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;测试通过!&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;测试失败: &#x27;</span> + arr.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 拿到待删除节点:</span><br><span class="hljs-keyword">let</span> self = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">to</span>-<span class="hljs-params">be</span>-<span class="hljs-params">removed</span>&#x27;)</span>;<br><span class="hljs-comment">// 拿到父节点:</span><br><span class="hljs-keyword">let</span> parent = self.parentElement;<br><span class="hljs-comment">// 删除:</span><br><span class="hljs-keyword">let</span> removed = parent.remove<span class="hljs-constructor">Child(<span class="hljs-params">self</span>)</span>;<br>removed<span class="hljs-operator"> === </span>self; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><p>注意:删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p></li><li><p>遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。</p><ul><li>例如，对于如下HTML结构：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>  当我们用如下代码删除子节点时：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> parent = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">parent</span>&#x27;)</span>;<br>parent.remove<span class="hljs-constructor">Child(<span class="hljs-params">parent</span>.<span class="hljs-params">children</span>[0])</span>;<br>parent.remove<span class="hljs-constructor">Child(<span class="hljs-params">parent</span>.<span class="hljs-params">children</span>[1])</span>; <span class="hljs-comment">// &lt;-- 浏览器报错</span><br></code></pre></td></tr></table></figure>  浏览器报错：<code>parent.children[1]</code>不是一个有效的节点。原因就在于，当<code>&lt;p&gt;First&lt;/p&gt;</code>节点被删除后，<code>parent.children</code>的节点数量已经从2变为了1，索引[1]已经不存在了。</li></ul><p>  因此，删除多个节点时，要注意children属性时刻都在变化。</p></li></ul><h2 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h2><p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p><p>不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p><p>HTML表单的输入控件主要有以下几种：</p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器</li></ul><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><p>如果我们获得了一个<code>&lt;input&gt;</code>节点的引用，就可以直接调用<code>value</code>获得对应的用户输入值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">// &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;<br>let <span class="hljs-built_in">input</span> = document.getElementById(<span class="hljs-string">&#x27;email&#x27;</span>);<br><span class="hljs-built_in">input</span>.value; // <span class="hljs-string">&#x27;用户输入的值&#x27;</span><br></code></pre></td></tr></table></figure><p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。</p><ul><li>但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> &lt;label&gt;&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;weekday&quot;</span> id=<span class="hljs-string">&quot;monday&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span>&gt; Monday&lt;/label&gt;<br><span class="hljs-regexp">//</span> &lt;label&gt;&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;weekday&quot;</span> id=<span class="hljs-string">&quot;tuesday&quot;</span> value=<span class="hljs-string">&quot;2&quot;</span>&gt; Tuesday&lt;/label&gt;<br>let mon = document.getElementById(<span class="hljs-string">&#x27;monday&#x27;</span>);<br>let tue = document.getElementById(<span class="hljs-string">&#x27;tuesday&#x27;</span>);<br>mon.value; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;1&#x27;</span><br>tue.value; <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;2&#x27;</span><br>mon.checked; <span class="hljs-regexp">//</span> true或者false<br>tue.checked; <span class="hljs-regexp">//</span> true或者false<br></code></pre></td></tr></table></figure></li></ul><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><p>设置值和获取值类似，对于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">// &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;<br>let <span class="hljs-built_in">input</span> = document.getElementById(<span class="hljs-string">&#x27;email&#x27;</span>);<br><span class="hljs-built_in">input</span>.value = <span class="hljs-string">&#x27;test@example.com&#x27;</span>; // 文本框的内容已更新<br></code></pre></td></tr></table></figure><ul><li>对于单选框和复选框，设置<code>checked</code>为true或false即可。</li></ul><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;2021-12-02&quot;</span>&gt;<br></code></pre></td></tr></table></figure><input type="date" value="2021-12-02"><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;2021-12-02T20:21:12&quot;</span>&gt;<br></code></pre></td></tr></table></figure><input type="datetime-local" value="2021-12-02T20:21:12"><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;#ff0000&quot;</span>&gt;<br></code></pre></td></tr></table></figure><input type="color" value="#ff0000"><ul><li>不支持HTML5的浏览器无法识别新的控件，会把它们当做<code>type=&quot;text&quot;</code>来显示。</li><li>支持HTML5的浏览器将获得格式化的字符串。<ul><li>例如，type&#x3D;”date”类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。</li></ul></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。</p><ul><li><p>方式一是通过<code>&lt;form&gt;</code>元素的submit()方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的click事件，在JavaScript代码中提交表单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-form&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSubmitForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 可以在此修改form的input...</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 提交form:</span></span><br><span class="language-javascript">    form.<span class="hljs-title function_">submit</span>();</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。</p></li><li><p>第二种方式是响应<code>&lt;form&gt;</code>本身的onsubmit事件，在提交form时作修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 可以在此修改form的input...</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意要<code>return true</code>来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p></li><li><p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p><ul><li>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<code>&lt;input&gt;</code>：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>  这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<em>变成32个</em>（因为MD5有32个字符）。</li><li>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input-password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;md5-password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> input_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> md5_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;md5-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    md5_pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(input_pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>  注意到id为md5-password的<code>&lt;input&gt;</code>标记了name&#x3D;”password”，而用户输入的id为input-password的<code>&lt;input&gt;</code>没有name属性。没有name属性的<code>&lt;input&gt;</code>的数据不会被提交。</li></ul></li></ul><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p><ul><li>注意：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。</li><li>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> f = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>-<span class="hljs-params">file</span>-<span class="hljs-params">upload</span>&#x27;)</span>;<br><span class="hljs-keyword">let</span> filename = f.value; <span class="hljs-comment">// &#x27;C:\fakepath\test.png&#x27;</span><br><span class="hljs-keyword">if</span> (!filename<span class="hljs-operator"> || </span>!(filename.ends<span class="hljs-constructor">With(&#x27;.<span class="hljs-params">jpg</span>&#x27;)</span><span class="hljs-operator"> || </span>filename.ends<span class="hljs-constructor">With(&#x27;.<span class="hljs-params">png</span>&#x27;)</span><span class="hljs-operator"> || </span>filename.ends<span class="hljs-constructor">With(&#x27;.<span class="hljs-params">gif</span>&#x27;)</span>)) &#123;<br>    alert(&#x27;Can only upload image file.&#x27;);<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。</p><p>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。</p><p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。</p><p>下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>    fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-file&#x27;</span>),<br>    info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-info&#x27;</span>),<br>    preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-preview&#x27;</span>);<br><span class="hljs-comment">// 监听change事件:</span><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 清除背景图片:</span><br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 检查文件是否选择:</span><br>    <span class="hljs-keyword">if</span> (!fileInput.<span class="hljs-property">value</span>) &#123;<br>        info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;没有选择文件&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取File引用:</span><br>    <span class="hljs-keyword">let</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取File信息:</span><br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;文件: &#x27;</span> + file.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;大小: &#x27;</span> + file.<span class="hljs-property">size</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;修改: &#x27;</span> + file.<span class="hljs-property">lastModified</span>;<br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/gif&#x27;</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;不是有效的图片文件!&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取文件:</span><br>    <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>    reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-keyword">let</span><br>            data = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span><br>        preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&#x27;</span> + data + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;;<br>    <span class="hljs-comment">// 以DataURL的形式读取文件:</span><br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>上面的代码演示了如何通过HTML5的File API读取文件内容。以<code>DataURL</code>的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。<ul><li>如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</li></ul></li></ul><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>上面的代码还演示了JavaScript的一个重要的特性就是<code>单线程执行模式</code>。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p><p>单线程模式执行的JavaScript，如何处理多任务？</p><p>在JavaScript中，执行多任务实际上都是<code>异步调用</code>，比如上面的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">reader.read<span class="hljs-constructor">AsDataURL(<span class="hljs-params">file</span>)</span>;<br></code></pre></td></tr></table></figure><p>就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个<code>回调函数</code>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">reader</span>.<span class="hljs-property">onload</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 当文件读取完成后，自动调用此函数:</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX：<code>Asynchronous JavaScript and XML</code>，意思就是用JavaScript执行异步网络请求。</p><p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：<code>一次HTTP请求对应一个页面</code>。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p><p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：</p><ul><li>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</li></ul><p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，如果不考虑早期浏览器的兼容性问题，现代浏览器还提供了原生支持的Fetch API，以Promise方式提供。使用Fetch API发送HTTP请求代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">text</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 发送异步请求:</span><br><span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;./content.html&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fetch-response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = data;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>使用<code>Fetch API</code>配合<code>async</code>写法，代码更加简单。</p><p>Fetch API的详细用法可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">MDN</a>文档。</p><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>上面代码的URL使用的是相对路径。如果你把它改为<code>&#39;https://www.sina.com.cn/&#39;</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</p><p>这是因为浏览器的<code>同源策略</code>导致的。默认情况下，JavaScript在发送AJAX请求时，<code>URL的域名必须和当前页面完全一致</code>。</p><p>完全一致的意思是，域名要相同（<code>www.example.com</code>和<code>example.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口号要相同（http默认是<code>:80</code>端口，它和<code>:8080</code>就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</p><p>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：</p><ul><li><p>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p></li><li><p>通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&#x27;<span class="hljs-string">/proxy</span>?url=https:<span class="hljs-string">//www.sina.com.cn</span>&#x27;<br></code></pre></td></tr></table></figure></li></ul><p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p><ul><li>第三种方式称为JSONP，它有个限制，只能用<code>GET</code>请求，并且要求返回JavaScript。这种方式跨域实际上是利用了<code>浏览器允许跨域引用JavaScript资源</code>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://example.com/abc.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">foo</span>(&#x27;<span class="hljs-class"><span class="hljs-keyword">data</span>&#x27;);</span><br></code></pre></td></tr></table></figure>这样一来，我们如果在页面中先准备好<code>foo()</code>函数，然后给页面动态加一个<code>&lt;script&gt;</code>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：<code>CORS</code>了。</p><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p><p>了解CORS前，我们先搞明白概念：</p><p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p><p><img src="/images/JavaScript%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/1.png" alt="CORS"></p><p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p><ul><li>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</li></ul><p>上面这种跨域请求，称之为“<code>简单请求</code>”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data和text&#x2F;plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p><p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。</p><ul><li>在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* CSS */</span><br><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;FontAwesome&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。</li></ul><p>对于<code>PUT</code>、<code>DELETE</code>以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个<code>OPTIONS</code>请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">OPTIONS /path/<span class="hljs-keyword">to</span>/resource HTTP/<span class="hljs-number">1.1</span><br>Host: bar.com<br>Origin: http:<span class="hljs-comment">//my.com</span><br>Access-Control-Request-<span class="hljs-keyword">Method</span>: POST<br></code></pre></td></tr></table></figure><p>服务器必须响应并明确指出允许的Method：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://my.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, PUT, OPTIONS<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400<br></code></pre></td></tr></table></figure><p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p><p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p><p>深入了解CORS请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN文档</a>和<a href="https://fetch.spec.whatwg.org/">W3C文档</a>。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>在JavaScript的世界中，所有代码都是单线程执行的。</p><p>由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Done&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;before setTimeout()&#x27;</span>);<br>setTimeout(callback, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒钟后调用callback函数</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;after setTimeout()&#x27;</span>);<br></code></pre></td></tr></table></figure><p>观察上述代码执行，在Chrome的控制台输出可以看到：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">before <span class="hljs-built_in">setTimeout</span>()<br>after <span class="hljs-built_in">setTimeout</span>()<br>(等待<span class="hljs-number">1</span>秒后)<br>Done<br></code></pre></td></tr></table></figure><p>可见，<code>异步操作会在将来的某个时间点触发一个函数调用</code>。</p><p>AJAX就是典型的异步操作：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">request.onreadystatechange <span class="hljs-operator">=</span> function () &#123;<br>    if (request.readyState <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">4</span>) &#123;<br>        if (request.status <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">200</span>) &#123;<br>            return success(request.responseText)<span class="hljs-comment">;</span><br>        &#125; else &#123;<br>            return fail(request.status)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。</p><p>有没有更好的写法？比如写成这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> ajax = ajax<span class="hljs-constructor">Get(&#x27;<span class="hljs-params">http</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">...</span>&#x27;)</span>;<br>ajax.<span class="hljs-keyword">if</span><span class="hljs-constructor">Success(<span class="hljs-params">success</span>)</span><br>    .<span class="hljs-keyword">if</span><span class="hljs-constructor">Fail(<span class="hljs-params">fail</span>)</span>;<br></code></pre></td></tr></table></figure><p>这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。</p><p>古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为<code>Promise</code>对象。</p><p>栗子：</p><ul><li>生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    let timeOut = Math.<span class="hljs-built_in">random</span>() * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;set timeout to: &#x27;</span> + timeOut + <span class="hljs-string">&#x27; seconds.&#x27;</span>);<br>    setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;call resolve()...&#x27;</span>);<br>            resolve(<span class="hljs-string">&#x27;200 OK&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;call reject()...&#x27;</span>);<br>            reject(<span class="hljs-string">&#x27;timeout in &#x27;</span> + timeOut + <span class="hljs-string">&#x27; seconds.&#x27;</span>);<br>        &#125;<br>    &#125;, timeOut * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用<code>resolve(&#39;200 OK&#39;)</code>，如果执行失败，我们将调用<code>reject(&#39;timeout in &#39; + timeOut + &#39; seconds.&#39;)</code>。</li><li>可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。</li></ul><p>有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(test);<br><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>&#125;);<br><span class="hljs-keyword">let</span> p3 = p2.<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + reason);<br>&#125;);<br></code></pre></td></tr></table></figure><p>变量p1是一个Promise对象，它负责执行test函数。</p><ul><li>由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 如果成功，执行这个函数：</span><br>p1.then(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>当test函数执行失败时，我们告诉Promise对象：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">p2.catch(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + reason);<br>&#125;);<br></code></pre></td></tr></table></figure>Promise对象可以串联起来，所以上述代码可以简化为：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Promise(test).then(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>&#125;).catch(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + reason);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了。</li></ul><h3 id="resolve函数"><a href="#resolve函数" class="headerlink" title="resolve函数"></a>resolve函数</h3><p>resolve函数是JavaScript中的Promise对象的一部分，用于将Promise从“待定（pending）”状态变为“已解决（fulfilled）”状态，并传递一个值。</p><ul><li>这个值可以是任何类型，包括基本类型（如数字、字符串等）和对象、数组、另一个Promise等。</li></ul><p>resolve函数通常在异步操作成功完成时调用，以表示操作的成功和结果。</p><p>Promise有三种状态：</p><ul><li>待定（pending）：初始状态，既不是成功也不是失败。</li><li>已解决（fulfilled）：表示操作成功完成。</li><li>已拒绝（rejected）：表示操作失败。</li></ul><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个新的Promise对象</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 操作成功，调用resolve函数</span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功&quot;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 使用then方法处理已解决状态的Promise</span><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: 操作成功</span><br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="reject函数"><a href="#reject函数" class="headerlink" title="reject函数"></a>reject函数</h3><p>reject函数是JavaScript中的Promise对象的一部分，用于将Promise从“待定（pending）”状态变为“已拒绝（rejected）”状态，并传递一个错误原因。</p><ul><li>这个原因通常是一个Error对象或其他描述错误的值。reject函数通常在异步操作失败时调用，以表示操作的失败和错误信息。</li></ul><h3 id="then方法和catch方法"><a href="#then方法和catch方法" class="headerlink" title="then方法和catch方法"></a>then方法和catch方法</h3><p>在JavaScript中，处理异步操作结果通常使用Promise对象的then方法和catch方法。</p><ul><li>then方法用于处理Promise成功完成（fulfilled）后的结果</li><li>catch方法用于处理Promise失败（rejected）后的错误</li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas">asyncOperatio<span class="hljs-meta">n</span>(<span class="hljs-string">&#x27;Test Input&#x27;</span>)<br>    .the<span class="hljs-meta">n</span>(functio<span class="hljs-meta">n</span>(result) &#123;<br>        console.<span class="hljs-meta">log</span>(result);<br>    &#125;)<br>    .catch(functio<span class="hljs-meta">n</span>(<span class="hljs-keyword">error</span>) &#123;<br>        console.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">error</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure><ul><li>function(result)：是一个回调函数，result参数是resolve传递的值;error是reject函数传递的值。<ul><li>在下面示例的asyncOperation函数中，resolve可能传递字符串 ‘Operation successful: Test Input’。这个值将被作为参数传递给then方法的回调函数。</li></ul></li></ul><h3 id="Promise使用示例"><a href="#Promise使用示例" class="headerlink" title="Promise使用示例"></a>Promise使用示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟一个异步操作的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-params">input</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Starting async operation...&#x27;</span>);<br><br>        <span class="hljs-comment">// 模拟异步操作，延迟1秒</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 使用随机数模拟成功或失败</span><br>            <span class="hljs-keyword">let</span> success = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>;<br><br>            <span class="hljs-keyword">if</span> (success) &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Operation successful: &#x27;</span> + input);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Operation failed: &#x27;</span> + input));<br>            &#125;<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 使用then和catch方法处理Promise</span><br><span class="hljs-title function_">asyncOperation</span>(<span class="hljs-string">&#x27;Test Input&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    &#125;);<br><br></code></pre></td></tr></table></figure><h3 id="Promise串行实现异步任务"><a href="#Promise串行实现异步任务" class="headerlink" title="Promise串行实现异步任务"></a>Promise串行实现异步任务</h3><p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p><p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">job1<span class="hljs-selector-class">.then</span>(job2)<span class="hljs-selector-class">.then</span>(job3)<span class="hljs-selector-class">.catch</span>(handleError);<br></code></pre></td></tr></table></figure><p>其中，<code>job1</code>、<code>job2</code>和<code>job3</code>都是Promise对象。</p><p>栗子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//清空日志区域</span><br><span class="hljs-keyword">let</span> logging = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>-<span class="hljs-params">promise2</span>-<span class="hljs-params">log</span>&#x27;)</span>;<br><span class="hljs-keyword">while</span> (logging.children.length &gt; <span class="hljs-number">1</span>) &#123;<br>    logging.remove<span class="hljs-constructor">Child(<span class="hljs-params">logging</span>.<span class="hljs-params">children</span>[<span class="hljs-params">logging</span>.<span class="hljs-params">children</span>.<span class="hljs-params">length</span> - 1])</span>;<br>&#125;<br><span class="hljs-comment">//定义日志记录函数</span><br><span class="hljs-keyword">function</span> log(s) &#123;<br>    <span class="hljs-keyword">let</span> p = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">p</span>&#x27;)</span>;<br>    p.innerHTML = s;<br>    logging.append<span class="hljs-constructor">Child(<span class="hljs-params">p</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//定义异步计算函数</span><br><span class="hljs-comment">// 0.5秒后返回input*input的计算结果:</span><br><span class="hljs-keyword">function</span> multiply(input) &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>        <span class="hljs-comment">//调用 log 函数，记录正在进行的计算操作。这是一个同步操作，立即执行</span><br>        log(&#x27;calculating &#x27; + input + &#x27; x &#x27; + input + &#x27;...&#x27;);<br>        set<span class="hljs-constructor">Timeout(<span class="hljs-params">resolve</span>, 500, <span class="hljs-params">input</span> <span class="hljs-operator">*</span> <span class="hljs-params">input</span>)</span>;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 0.5秒后返回input+input的计算结果:</span><br><span class="hljs-keyword">function</span> add(input) &#123;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>        log(&#x27;calculating &#x27; + input + &#x27; + &#x27; + input + &#x27;...&#x27;);<br>        set<span class="hljs-constructor">Timeout(<span class="hljs-params">resolve</span>, 500, <span class="hljs-params">input</span> + <span class="hljs-params">input</span>)</span>;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    log(&#x27;start <span class="hljs-keyword">new</span> Promise...&#x27;);<br>    resolve(<span class="hljs-number">123</span>);<br>&#125;);<br><br>p.<span class="hljs-keyword">then</span>(multiply)<br> .<span class="hljs-keyword">then</span>(add)<br> .<span class="hljs-keyword">then</span>(multiply)<br> .<span class="hljs-keyword">then</span>(add)<br> .<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (result) &#123;<br>    log(&#x27;Got value: &#x27; + result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>setTimeout可以看成一个<code>模拟网络等异步执行</code>的函数。</p><ul><li>setTimeout 第一个参数是回调函数，这里是 resolve。</li><li>setTimeout 第二个参数是延迟时间，这里是500毫秒。</li><li>setTimeout 第三个参数是传递给回调函数的值，这里是 input * input。</li></ul><h3 id="Promise并行实现异步任务"><a href="#Promise并行实现异步任务" class="headerlink" title="Promise并行实现异步任务"></a>Promise并行实现异步任务</h3><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p><p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用<code>Promise.all()</code>实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;P1&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">600</span>, <span class="hljs-string">&#x27;P2&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 同时执行p1和p2，并在它们都完成后执行then:</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results); <span class="hljs-comment">// 获得一个Array: [&#x27;P1&#x27;, &#x27;P2&#x27;]</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;P1&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">600</span>, <span class="hljs-string">&#x27;P2&#x27;</span>);<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// &#x27;P1&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。</p><p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>avaScript异步操作需要通过Promise实现，一个Promise对象在操作网络时是异步的，等到返回后再调用回调函数，执行正确就调用then()，执行错误就调用catch()，虽然异步实现了，不会让用户感觉到页面“卡住”了，但是一堆then()、catch()写起来麻烦看起来也乱。</p><p>有没有更简单的写法？</p><p>可以用关键字<code>async</code>配合<code>await</code>调用Promise，实现异步操作，但代码却和同步写法类似：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">url</span>);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.json();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>async function</code>可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用<code>await</code>调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">url</span>);<br></code></pre></td></tr></table></figure><p>自动实现了异步调用，它和下面的Promise代码等价：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let promise <span class="hljs-operator">=</span> fetch(url)<span class="hljs-comment">;</span><br>promise.then((resp) <span class="hljs-operator">=</span>&gt; &#123;<br>    // 拿到resp<br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>如果我们要实现catch()怎么办？用Promise的写法如下：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let promise = fetch(url);<br>promise.then(<span class="hljs-function">(<span class="hljs-params">resp</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 拿到resp</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 出错了</span><br>&#125;);<br></code></pre></td></tr></table></figure>用await调用时，直接用传统的<code>try &#123; ... &#125; catch</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">json</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-comment">// 出错了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>用async定义异步函数，用await调用异步函数，写起来和同步代码差不多，但可读性大大提高。</li></ul><h3 id="同步function调用async-function"><a href="#同步function调用async-function" class="headerlink" title="同步function调用async function"></a>同步function调用async function</h3><p>await调用必须在async function中，不能在传统的同步代码中调用。那么问题来了，一个同步function怎么调用async function呢？</p><p>首先，普通function直接用await调用异步函数将报错：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">url</span>);<br>    <span class="hljs-keyword">return</span> resp.json();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doGet</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> get(<span class="hljs-string">&#x27;/api/categories&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(data);<br>&#125;<br><br>doGet();<br></code></pre></td></tr></table></figure><ul><li>如果把await去掉，调用实际上发生了，但我们拿不到结果，因为我们拿到的并不是异步结果，而是一个Promise对象：<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">url</span>);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.text();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doGet</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> promise = get(<span class="hljs-string">&#x27;./content.html&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(promise);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>因此，在普通function中调用async function，不能使用await，但可以直接调用async function拿到Promise对象，后面加上then()和catch()就可以拿到结果或错误了：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">text</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doGet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;./content.html&#x27;</span>);<br>    promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 拿到data</span><br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-response-text&#x27;</span>).<span class="hljs-property">value</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data);<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">doGet</span>();<br></code></pre></td></tr></table></figure>因此，定义异步任务时，使用async function比Promise简单，调用异步任务时，使用await比Promise简单，捕获错误时，按传统的try…catch写法，也比Promise简单。只要浏览器支持，完全可以用async简洁地实现异步操作。</li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。</p><p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;test-canvas&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;&lt;/canvas&gt;<br></code></pre></td></tr></table></figure><h3 id="测试浏览器是否支持Canvas"><a href="#测试浏览器是否支持Canvas" class="headerlink" title="测试浏览器是否支持Canvas"></a>测试浏览器是否支持Canvas</h3><p>在使用Canvas前，用<code>canvas.getContext</code>来测试浏览器是否支持Canvas：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let canvas = document.getElementById(<span class="hljs-string">&#x27;test-canvas&#x27;</span>);<br><span class="hljs-keyword">if</span> (canvas.getContext) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;你的浏览器支持Canvas!&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;你的浏览器不支持Canvas!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用Canvas绘制2D图像"><a href="#使用Canvas绘制2D图像" class="headerlink" title="使用Canvas绘制2D图像"></a>使用Canvas绘制2D图像</h3><p><code>getContext(&#39;2d&#39;)</code>方法让我们拿到一个<code>CanvasRenderingContext2D</code>对象，所有的绘图操作都需要通过这个对象完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">gl</span> <span class="hljs-operator">=</span> canvas.getContext(<span class="hljs-string">&quot;webgl&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>本节我们只专注于绘制2D图形。</li></ul><h4 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h4><p>我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：</p><p><img src="/images/JavaScript%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/2.png" alt="Canvas的坐标系统"></p><p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p><p><code>CanvasRenderingContext2D</code>对象有若干方法来绘制图形：<br>举个栗子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span><br>    canvas = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">test</span>-<span class="hljs-params">shape</span>-<span class="hljs-params">canvas</span>&#x27;)</span>,<br>    ctx = canvas.get<span class="hljs-constructor">Context(&#x27;2d&#x27;)</span>;<br><br>ctx.clear<span class="hljs-constructor">Rect(0, 0, 200, 200)</span>; <span class="hljs-comment">// 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明</span><br>ctx.fillStyle = &#x27;#dddddd&#x27;; <span class="hljs-comment">// 设置颜色</span><br>ctx.fill<span class="hljs-constructor">Rect(10, 10, 130, 130)</span>; <span class="hljs-comment">// 把(10,10)位置大小为130x130的矩形涂色</span><br><span class="hljs-comment">// 利用Path绘制复杂路径:</span><br><span class="hljs-keyword">let</span> path=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Path2D()</span>;<br>path.arc(<span class="hljs-number">75</span>, <span class="hljs-number">75</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, Math.PI*<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>path.move<span class="hljs-constructor">To(110,75)</span>;<br>path.arc(<span class="hljs-number">75</span>, <span class="hljs-number">75</span>, <span class="hljs-number">35</span>, <span class="hljs-number">0</span>, Math.PI, <span class="hljs-literal">false</span>);<br>path.move<span class="hljs-constructor">To(65, 65)</span>;<br>path.arc(<span class="hljs-number">60</span>, <span class="hljs-number">65</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Math.PI*<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>path.move<span class="hljs-constructor">To(95, 65)</span>;<br>path.arc(<span class="hljs-number">90</span>, <span class="hljs-number">65</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Math.PI*<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>ctx.strokeStyle = &#x27;#<span class="hljs-number">0000</span>ff&#x27;;<br>ctx.stroke(path);<br></code></pre></td></tr></table></figure><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ctx</span>.fillStyle = &#x27;#fff&#x27;;<br><span class="hljs-attribute">ctx</span>.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>);<br><span class="hljs-attribute">ctx</span>.shadowOffsetX = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">ctx</span>.shadowOffsetY = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">ctx</span>.shadowBlur = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">ctx</span>.shadowColor = &#x27;#ccc&#x27;;<br><span class="hljs-attribute">ctx</span>.font = &#x27;<span class="hljs-number">28</span>px Arial&#x27;;<br><span class="hljs-attribute">ctx</span>.fillStyle = &#x27;#<span class="hljs-number">999</span>&#x27;;<br><span class="hljs-attribute">ctx</span>.fillText(&#x27;带阴影的文字&#x27;, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p><p>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</p><ul><li>尽量使用整数坐标而不是浮点数；</li><li>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</li><li>背景图片如果不变可以直接用<code>&lt;img&gt;</code>标签并放到最底层。</li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> data = <span class="hljs-literal">[</span><br><span class="hljs-literal">    &#123; <span class="hljs-identifier">high</span>: <span class="hljs-number">35</span>, <span class="hljs-identifier">low</span>: <span class="hljs-number">22</span> &#125;,</span><br><span class="hljs-literal">    &#123; <span class="hljs-identifier">high</span>: <span class="hljs-number">37</span>, <span class="hljs-identifier">low</span>: <span class="hljs-number">24</span> &#125;,</span><br><span class="hljs-literal">    &#123; <span class="hljs-identifier">high</span>: <span class="hljs-number">37</span>, <span class="hljs-identifier">low</span>: <span class="hljs-number">25</span> &#125;,</span><br><span class="hljs-literal">    &#123; <span class="hljs-identifier">high</span>: <span class="hljs-number">34</span>, <span class="hljs-identifier">low</span>: <span class="hljs-number">24</span> &#125;,</span><br><span class="hljs-literal">    &#123; <span class="hljs-identifier">high</span>: <span class="hljs-number">33</span>, <span class="hljs-identifier">low</span>: <span class="hljs-number">23</span> &#125;</span><br><span class="hljs-literal">]</span>;<br><br><span class="hljs-keyword">let</span> canvas = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">weather</span>-<span class="hljs-params">canvas</span>&#x27;)</span>;<br><span class="hljs-keyword">let</span> ctx = canvas.get<span class="hljs-constructor">Context(&#x27;2d&#x27;)</span>;<br><br><span class="hljs-comment">// 清空画布</span><br>ctx.clear<span class="hljs-constructor">Rect(0, 0, <span class="hljs-params">canvas</span>.<span class="hljs-params">width</span>, <span class="hljs-params">canvas</span>.<span class="hljs-params">height</span>)</span>;<br><br><span class="hljs-comment">// 定义绘制参数</span><br><span class="hljs-keyword">let</span> margin = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">let</span> width = canvas.width - margin<span class="hljs-operator"> * </span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> height = canvas.height - margin<span class="hljs-operator"> * </span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> maxTemp = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(...data.map(d =&gt; d.high));<br><span class="hljs-keyword">let</span> minTemp = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(...data.map(d =&gt; d.low));<br><br><span class="hljs-comment">// 绘制高温折线图</span><br>ctx.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Path()</span>;<br>ctx.move<span class="hljs-constructor">To(<span class="hljs-params">margin</span>, <span class="hljs-params">height</span> - (<span class="hljs-params">data</span>[0].<span class="hljs-params">high</span> - <span class="hljs-params">minTemp</span>)</span><span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; data.length; i++) &#123;<br>    ctx.line<span class="hljs-constructor">To(<span class="hljs-params">margin</span> + <span class="hljs-params">i</span> <span class="hljs-operator">*</span> (<span class="hljs-params">width</span> <span class="hljs-operator">/</span> (<span class="hljs-params">data</span>.<span class="hljs-params">length</span> - 1)</span>), height - (data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.high - minTemp)<span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin);<br>&#125;<br>ctx.strokeStyle = &#x27;red&#x27;;<br>ctx.lineWidth = <span class="hljs-number">2</span>;<br>ctx.stroke<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// 绘制低温折线图</span><br>ctx.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Path()</span>;<br>ctx.move<span class="hljs-constructor">To(<span class="hljs-params">margin</span>, <span class="hljs-params">height</span> - (<span class="hljs-params">data</span>[0].<span class="hljs-params">low</span> - <span class="hljs-params">minTemp</span>)</span><span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; data.length; i++) &#123;<br>    ctx.line<span class="hljs-constructor">To(<span class="hljs-params">margin</span> + <span class="hljs-params">i</span> <span class="hljs-operator">*</span> (<span class="hljs-params">width</span> <span class="hljs-operator">/</span> (<span class="hljs-params">data</span>.<span class="hljs-params">length</span> - 1)</span>), height - (data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.low - minTemp)<span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin);<br>&#125;<br>ctx.strokeStyle = &#x27;blue&#x27;;<br>ctx.lineWidth = <span class="hljs-number">2</span>;<br>ctx.stroke<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// 添加高温点</span><br>ctx.fillStyle = &#x27;red&#x27;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>    ctx.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Path()</span>;<br>    ctx.arc(margin + i<span class="hljs-operator"> * </span>(width<span class="hljs-operator"> / </span>(data.length - <span class="hljs-number">1</span>)), height - (data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.high - minTemp)<span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Math.PI<span class="hljs-operator"> * </span><span class="hljs-number">2</span>);<br>    ctx.fill<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 添加低温点</span><br>ctx.fillStyle = &#x27;blue&#x27;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>    ctx.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Path()</span>;<br>    ctx.arc(margin + i<span class="hljs-operator"> * </span>(width<span class="hljs-operator"> / </span>(data.length - <span class="hljs-number">1</span>)), height - (data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.low - minTemp)<span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Math.PI<span class="hljs-operator"> * </span><span class="hljs-number">2</span>);<br>    ctx.fill<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 添加下载链接</span><br><span class="hljs-keyword">let</span> download = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">weather</span>-<span class="hljs-params">download</span>&#x27;)</span>;<br>download.href = canvas.<span class="hljs-keyword">to</span><span class="hljs-constructor">DataURL()</span>;<br></code></pre></td></tr></table></figure><ul><li>函数用法积累：  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> maxTemp = Math.<span class="hljs-keyword">max</span>(<span class="hljs-params">...</span><span class="hljs-built_in">data</span>.<span class="hljs-built_in">map</span>(d =&gt; d.high));<br><span class="hljs-keyword">let</span> minTemp = Math.<span class="hljs-keyword">min</span>(<span class="hljs-params">...</span><span class="hljs-built_in">data</span>.<span class="hljs-built_in">map</span>(d =&gt; d.low));<br></code></pre></td></tr></table></figure><ul><li><code>data</code> 是一个包含天气数据的数组，每个元素都是一个对象，包含高温 (high) 和低温 (low) 信息。</li><li><code>data.map(d =&gt; d.high)</code>:<ul><li>map 方法会创建一个新数组，其元素是调用一次提供的函数对原数组中的每个元素执行结果。</li><li>这里的 d &#x3D;&gt; d.high 是一个箭头函数，它从 data 数组中的每个对象提取 <code>high</code> 属性，生成一个新的数组，包含所有高温值。</li><li>结果是一个高温值数组 [35, 37, 37, 34, 33]。</li></ul></li><li><code>Math.max(...[35, 37, 37, 34, 33])</code>:<ul><li>Math.max 函数返回给定数字中的最大值。</li><li>使用展开运算符<code> ...</code> 将数组展开成一系列参数传递给 Math.max。</li><li>最终结果是最高温度 37。</li></ul></li><li>这两行代码的作用是从天气数据中提取出最高温度和最低温度。这对于后续在Canvas上绘制温度折线图非常重要，因为我们需要这些最大和最小值来正确地缩放和定位温度点。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ctx.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Path()</span><br></code></pre></td></tr></table></figure></li><li>功能：开始一条新的路径，或重置当前路径。</li><li>作用：在Canvas中绘制一条新的折线图前，调用这个方法来开始一条新的路径。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ctx.move<span class="hljs-constructor">To(<span class="hljs-params">margin</span>, <span class="hljs-params">height</span> - (<span class="hljs-params">data</span>[0].<span class="hljs-params">high</span> - <span class="hljs-params">minTemp</span>)</span><span class="hljs-operator"> / </span>(maxTemp - minTemp)<span class="hljs-operator"> * </span>height + margin);<br></code></pre></td></tr></table></figure></li><li>功能：将绘图的起始点移动到指定的坐标。</li><li>参数解释：<ul><li>margin：x坐标，绘制区域的左边距。</li><li>height - (data[0].high - minTemp) &#x2F; (maxTemp - minTemp) * height + margin：<br>  y坐标，计算方式如下：<ul><li>data[0].high：第一天的高温值。</li><li>minTemp 和 maxTemp：整个数据集中的最低温度和最高温度。</li><li>(data[0].high - minTemp) &#x2F; (maxTemp - minTemp)：将当前温度值归一化到0到1的范围内。</li></ul><ul><li>height：将归一化的值映射到绘图区域的高度。</li></ul><ul><li>height - …：<code>反转y轴</code>，因为Canvas的y坐标是从上到下增加的。</li></ul><ul><li>margin：加上顶部边距，保证图形不紧贴画布边缘。</li></ul></li></ul></li></ul>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ctx<span class="hljs-selector-class">.lineTo</span>(<span class="hljs-attribute">margin</span> + <span class="hljs-selector-tag">i</span> * (<span class="hljs-attribute">width</span> / (data<span class="hljs-selector-class">.length</span> - <span class="hljs-number">1</span>)), <span class="hljs-attribute">height</span> - (data<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.high</span> - minTemp) / (maxTemp - minTemp) * <span class="hljs-attribute">height</span> + <span class="hljs-attribute">margin</span>);<br></code></pre></td></tr></table></figure><ul><li>功能：将当前绘图位置连接到指定坐标处的一个新点，绘制一条直线。</li><li>参数解释：<ul><li><code>margin + i * (width / (data.length - 1))</code>：<br>  x坐标，计算方式如下：<ul><li>i：当前循环的索引，表示第几天的数据。</li><li>width &#x2F; (data.length - 1)：<br>  计算每一天之间的水平距离，width 是绘图区域的宽度，data.length - 1 是总天数减去1，因为折线需要绘制 data.length - 1 段。</li><li>margin + i * (width &#x2F; (data.length - 1))：加上左边距，计算出当前数据点的x坐标。</li><li>height - (data[i].high - minTemp) &#x2F; (maxTemp - minTemp) * height + margin：<br>  y坐标，与之前解释的moveTo方法中的计算相同，只是使用当前索引 i 对应的高温值。</li></ul></li></ul></li></ul>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ctx.stroke()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>功能：绘制当前路径。</li><li>作用：在Canvas上绘制之前定义的折线。调用stroke()方法后，前面用 moveTo 和 lineTo 定义的路径将被实际绘制到画布上。</li></ul></li></ul><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>JavaScript 中的箭头函数（Arrow Function）是 ECMAScript 6（ES6）引入的一种更简洁的函数表示法。它在函数表达式的语法上做了简化，尤其适合编写简短的匿名函数。</p><ul><li>语法：<code>(param1, param2, ..., paramN) =&gt; expression</code><br>其中 <code>param1</code>, <code>param2</code>, …, <code>paramN</code> 是函数的参数，<code>expression</code>是函数的返回值。<ul><li>如果函数体只有一个表达式，那么可以省略大括号和 return 关键字，箭头函数会隐式地返回该表达式的结果。</li></ul></li><li>示例：<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 传统函数表达式</span><br>const add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 等效的箭头函数</span><br>const add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 5</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电气仿真学习记录</title>
    <link href="/2024/07/16/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/16/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>使用PSCAD和COMSOL进行电气仿真。</p><span id="more"></span> <h1 id="PSCAD简介"><a href="#PSCAD简介" class="headerlink" title="PSCAD简介"></a>PSCAD简介</h1><ul><li>PSCAD&#x2F;EMTDC是一种广泛应用的电磁暂态仿真软件，可基于微分方程完整且精确地进行毫秒级甚至微秒级步长的时域和频域仿真计算，能较好地反映电力系统运行的动态过程。</li><li>EMTDC(Electromagnetic Transients includingDC):是PSCAD产品系列的电磁暂态求解引擎。对电磁和机电系统采用时域内微分方程进行描述并求解，方程求解中采用固定步长。</li></ul><p>仿真工作流程：</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png" alt="仿真工作流程"></p><div style="text-align: center;"><table>    <tr>        <td colspan="2">暂态仿真软件举例</td>    </tr>    <tr>        <td>机电暂态仿真软件</td>        <td>电磁暂态仿真软件</td>    </tr>    <tr>        <td>PSD-BPA（步长0.5-1周波）</td>        <td>PSCAD/EMTDC（默认步长50微秒）</td>    </tr>    <tr>        <td>PSASP</td>        <td>Matlab-Simulink</td>    </tr>     <tr>        <td>PSS/E</td>        <td>EMTP</td>    </tr></table></div><h2 id="工作界面和元件库介绍"><a href="#工作界面和元件库介绍" class="headerlink" title="工作界面和元件库介绍"></a>工作界面和元件库介绍</h2><h3 id="页面介绍"><a href="#页面介绍" class="headerlink" title="页面介绍"></a>页面介绍</h3><h4 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h4><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png" alt="PSCAD主页面"></p><h4 id="菜单窗口"><a href="#菜单窗口" class="headerlink" title="菜单窗口"></a>菜单窗口</h4><p>(1)Home 菜单栏</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png" alt="Home 菜单栏"></p><ol><li>Run，Stop，Pause</li><li>仿真步长和输出步长（Plot step）：输出步长可以比仿真步长大一些。</li><li>undo，Redo</li><li>划线，视图放大和缩小</li></ol><p>(2)Project 菜单栏</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.1.png" alt="Project 菜单栏"></p><ol><li>三栏分别是仿真时间、仿真步长（单位为微秒），作图步长（单位为微秒）</li><li>General Settings可以具体设置，包括运行模式。</li></ol><ul><li>有个快照模式</li></ul><p>(3)View 视图模式<br>窗口按钮，可以添加选择数据窗口</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.2.png" alt="视图模式"></p><p>(4)Components 常用元件栏</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.3.png" alt="Project 菜单栏"></p><h4 id="Workspace窗口"><a href="#Workspace窗口" class="headerlink" title="Workspace窗口"></a>Workspace窗口</h4><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png" alt="Workspace窗口"></p><h4 id="Output窗口"><a href="#Output窗口" class="headerlink" title="Output窗口"></a>Output窗口</h4><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png" alt="Output窗口"></p><h4 id="工作窗口"><a href="#工作窗口" class="headerlink" title="工作窗口"></a>工作窗口</h4><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/6.png" alt="工作窗口"></p><ol><li>提供了Library基础元件库</li></ol><h3 id="元件库介绍"><a href="#元件库介绍" class="headerlink" title="元件库介绍"></a>元件库介绍</h3><p>PSCAD提供了18个自带元件库。</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.png" alt="元件库"></p><h4 id="Sources元件库"><a href="#Sources元件库" class="headerlink" title="Sources元件库"></a>Sources元件库</h4><p>包括3种三相电压源模型，2种单项电压源模型，电流源模型以及谐波电流源模型。</p><h5 id="三种常用的电压源模型"><a href="#三种常用的电压源模型" class="headerlink" title="三种常用的电压源模型"></a>三种常用的电压源模型</h5><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.1.png" alt="电压源模型"></p><h4 id="Passive-Elements-元件库"><a href="#Passive-Elements-元件库" class="headerlink" title="Passive Elements 元件库"></a>Passive Elements 元件库</h4><p>包括电阻R、电感L、电容C、GND、负荷、三线单线转换器等。</p><h5 id="固定负荷模型"><a href="#固定负荷模型" class="headerlink" title="固定负荷模型"></a>固定负荷模型</h5><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.2.png" alt="固定负荷模型"></p><h5 id="三相负载元件"><a href="#三相负载元件" class="headerlink" title="三相负载元件"></a>三相负载元件</h5><p>三相负载元件模型等效于电感星型不接地接法作为补偿。</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.3.png" alt="固定负荷模型"></p><h5 id="Miscellaneous、I-O、Breakers-Faults、Meters元件库"><a href="#Miscellaneous、I-O、Breakers-Faults、Meters元件库" class="headerlink" title="Miscellaneous、I&#x2F;O、Breakers&amp;Faults、Meters元件库"></a>Miscellaneous、I&#x2F;O、Breakers&amp;Faults、Meters元件库</h5><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.4.png" alt="Miscellaneous、I/O、Breakers&amp;Faults、Meters元件库"></p><ol><li>短路故障和短路故障的定时控制逻辑不一样，所以有区分。</li></ol><h5 id="CSMF元件库"><a href="#CSMF元件库" class="headerlink" title="CSMF元件库"></a>CSMF元件库</h5><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.5.png" alt="CSMF元件库"></p><h5 id="machines元件库"><a href="#machines元件库" class="headerlink" title="machines元件库"></a>machines元件库</h5><ol><li>电动机和发电机是同一个模型，改变参数进行切换。</li></ol><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.6.png" alt="machines元件库"></p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.7.png" alt="machines元件库"></p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.8.png" alt="machines元件库"></p><h5 id="Transformers元件库"><a href="#Transformers元件库" class="headerlink" title="Transformers元件库"></a>Transformers元件库</h5><p>一般使用经典模型可满足大部分情况的需要。</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.9.png" alt="Transformers元件库"></p><h5 id="Transmission-Lines元件库"><a href="#Transmission-Lines元件库" class="headerlink" title="Transmission Lines元件库"></a>Transmission Lines元件库</h5><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.99.png" alt="Transmission Lines元件库"></p><h2 id="算例1：火电机组单机建模仿真"><a href="#算例1：火电机组单机建模仿真" class="headerlink" title="算例1：火电机组单机建模仿真"></a>算例1：火电机组单机建模仿真</h2><h4 id="同步电机元件属性"><a href="#同步电机元件属性" class="headerlink" title="同步电机元件属性"></a>同步电机元件属性</h4><ol><li><p>同调运行：一台等效多台运行，设置台数。</p></li><li><p>同步电机需要进行两步初始化：</p></li></ol><ul><li><p><code>Source [0] to Machine [1] Transition</code>:</p><ul><li>0:电动机模拟为简单的三相电压源;</li><li>1:电动机运行于恒转速模式。</li></ul></li><li><p><code>Lock-rotor[0] to Normal Mode [1] Transition</code>:</p><ul><li>0:电动机运行于恒转速模式;</li><li>1:电动机以完全自由的模式运行。</li><li>这一步结束之后，同步电机初始化结束，进入稳定运行状态。</li></ul></li><li><p>S2M和L2N通常以0与1之间切换的变量进行控制。</p></li><li><p>阶跃时刻顺序<code>DIST_PSS&gt;L2N&gt;S2M</code><br>等同步电机初始化结束，稳定运行之后再投入PSS。</p></li></ul><ol start="3"><li>PSCAD同步电机模型没有额定功率选项，需要通过<code>额定相电压</code>、<code>额定线电流</code>决定功率。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意相和线的区别！！！<br></code></pre></td></tr></table></figure>$$I=\frac{S}{3}\cdot \frac{\sqrt{3}}{U}$$</li></ol><ul><li>I为额定线电流，U为额定相电压。</li></ul><ol start="4"><li>Inertia Constant惯量常数H和惯性时间常数$T_j$不同，需要转换。</li></ol>$$H=\frac{T_j}{2}$$<ol start="5"><li><p>同步电机元件内部输出的有功功率、无功功率、电压参数和机端多表计测量值不同。</p></li><li><p>PSCAD中同步电机元件的电抗参数标幺值都是以<code>自身额定容量为基准容量</code>的。</p></li><li><p>PSCAD中没有定子漏抗$X_L$的参数项，只有保梯电抗$X_P$可以填写。</p></li></ol><ul><li><code>气隙因子(AirGrapFactor)取1.0的时候</code> $X_L&#x3D;X_P$。</li></ul><ol start="8"><li>仿真需要满足一些隐形的运行前提。</li></ol><ul><li>交轴次暂态电抗值必须小于交轴不饱和同步电抗值，否则无法运行仿真。</li></ul><ol start="9"><li>国内的基频是50HZ，因此在Basic Data中需要修改: $2 \pi f$</li></ol><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.png" alt="参数设置"></p><h1 id="实验项目：PP电缆仿真"><a href="#实验项目：PP电缆仿真" class="headerlink" title="实验项目：PP电缆仿真"></a>实验项目：PP电缆仿真</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><h3 id="1-1-中压运行环境下聚丙烯电缆的线路建模及仿真研究"><a href="#1-1-中压运行环境下聚丙烯电缆的线路建模及仿真研究" class="headerlink" title="1.1 中压运行环境下聚丙烯电缆的线路建模及仿真研究"></a>1.1 中压运行环境下聚丙烯电缆的线路建模及仿真研究</h3><ul><li>了解聚丙烯电缆内部线路结构，根据其内部的电气参数，建立电缆详细的电磁暂态模型；</li><li>计算中压情况下电缆模型的阻抗参数，在ANSYS&#x2F;EMTDC有限元分析软件中进行非线性分析并搭建电缆线路仿真模型加以验证。</li></ul><h3 id="1-2-对不同工况下聚丙烯电缆的模拟测试"><a href="#1-2-对不同工况下聚丙烯电缆的模拟测试" class="headerlink" title="1.2 对不同工况下聚丙烯电缆的模拟测试"></a>1.2 对不同工况下聚丙烯电缆的模拟测试</h3><ul><li>明确聚丙烯的电气性能，模拟聚丙烯电缆在不同温度情况下的工作情况；</li><li>研究空间电荷效应在聚丙烯电缆中的绝缘老化现象；</li><li>研究聚丙烯电缆在不同机械应力强度和化学环境下的绝缘特性；</li><li>模拟聚丙烯电缆在不同环境情况下的运行状况，建立其绝缘老化模型。</li></ul><h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><h3 id="2-1-聚丙烯电缆建模"><a href="#2-1-聚丙烯电缆建模" class="headerlink" title="2.1 聚丙烯电缆建模"></a>2.1 聚丙烯电缆建模</h3><h4 id="2-1-1-建立电缆详细的电磁暂态模型"><a href="#2-1-1-建立电缆详细的电磁暂态模型" class="headerlink" title="2.1.1 建立电缆详细的电磁暂态模型"></a>2.1.1 建立电缆详细的电磁暂态模型</h4><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.2.png" alt="电缆建模"></p><p>（1） Cable Summary</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Cable Name</td><td>Cable_1</td></tr><tr><td>Cable Length</td><td>40.0</td></tr><tr><td>Steady State Frequency</td><td>50.0</td></tr></tbody></table><p>（2）Frequency Dep. (Phase) Model Options</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Interpolate Travel Times</td><td>1</td></tr><tr><td>Infinite Line Length</td><td>0</td></tr><tr><td>Curve Fitting Start Frequency</td><td>0.5</td></tr><tr><td>Curve Fitting End Frequency</td><td>1000000.0</td></tr><tr><td>Total Number of Frequency Increments</td><td>100</td></tr><tr><td>Maximum # of Poles for Surge Admittance Fit</td><td>20</td></tr><tr><td>Maximum # of Poles for Attenuation Constant Fit</td><td>20</td></tr><tr><td>Maximum Fitting Error (%) for Surge Admittance</td><td>0.2</td></tr><tr><td>Maximum Fitting Error (%) for Attenuation Constant</td><td>0.2</td></tr><tr><td>Maximum Residue&#x2F;Pole Ratio Tolerance</td><td>2000000.0</td></tr><tr><td>Weighting Factor 1</td><td>1.0</td></tr><tr><td>Weighting Factor 2</td><td>1000.0</td></tr><tr><td>Weighting Factor 3</td><td>1.0</td></tr><tr><td>Write Detailed Output Files</td><td>0</td></tr></tbody></table><p>（3）Line Constants Ground Data</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Ground Resistivity Type</td><td>0</td></tr><tr><td>Ground Resistivity</td><td>100.0</td></tr><tr><td>Ground Permeability</td><td>1.0</td></tr><tr><td>Earth Impedance Formula</td><td>0</td></tr><tr><td>Earth U Impedance Formula</td><td>2</td></tr><tr><td>Earth M Impedance Formula</td><td>2</td></tr></tbody></table><p>（4）Output File Display Options</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Frequency for Calculation</td><td>50.0</td></tr><tr><td>Zero Tolerance for Display</td><td>1.0e-19</td></tr><tr><td>Base Voltage for Display</td><td>110.0</td></tr><tr><td>Base MVA for Display</td><td>1.0</td></tr><tr><td>Create PI-Section</td><td>0</td></tr></tbody></table><p>（5）Pipe-Type Cable</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Pipe Number</td><td>1</td></tr><tr><td>P1</td><td>0.0 3.0</td></tr><tr><td>Number of Inner Cables</td><td>3</td></tr><tr><td>Inner Insulator Outer Radius</td><td>0.035</td></tr><tr><td>Inner Ins. Relative Permittivity</td><td>3.0</td></tr><tr><td>Inner Ins. Relative Permeability</td><td>1.0</td></tr><tr><td>Conductor Outer Radius</td><td>0.037</td></tr><tr><td>Conductor Resistivity</td><td>1.71e-07</td></tr><tr><td>Conductor Permeability</td><td>200.0</td></tr><tr><td>Identical Cables</td><td>0</td></tr><tr><td>Outer Insulator Outer Radius</td><td>0.036</td></tr><tr><td>Outer Ins. Relative Permittivity</td><td>2.3</td></tr><tr><td>Outer Ins. Relative Permeability</td><td>1.0</td></tr><tr><td>Outer Insulator Layer</td><td>1</td></tr><tr><td>Ground Pipe</td><td>0</td></tr><tr><td>Overhead Pipe</td><td>1</td></tr></tbody></table><p>（6）Coax Cables</p><table><thead><tr><th>参数</th><th>Coax Cable 1</th><th>Coax Cable 2</th><th>Coax Cable 3</th></tr></thead><tbody><tr><td>Cable Number</td><td>1</td><td>2</td><td>3</td></tr><tr><td>P1</td><td>-2.97589172193e-18 -0.0162 0.0162 270.0</td><td>0.0140296115413 0.0081 0.0162 30.0</td><td>-0.0140296115413 0.0081 0.0162 150.0</td></tr><tr><td>Overhead Cable</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Layers</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Ground Last Layer</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Conductor Inner Radius</td><td>0.0</td><td>0.0</td><td>0.0</td></tr><tr><td>Conductor Outer Radius</td><td>0.003</td><td>0.003</td><td>0.003</td></tr><tr><td>Conductor Resistivity</td><td>1.72e-08</td><td>1.72e-08</td><td>1.72e-08</td></tr><tr><td>Conductor Permeability</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Insulator 1 Outer Radius</td><td>0.006</td><td>0.006</td><td>0.006</td></tr><tr><td>Insulator 1 Relative Permittivity</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Insulator 1 Relative Permeability</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Sheath Outer Radius</td><td>0.0105</td><td>0.0105</td><td>0.0105</td></tr><tr><td>Sheath Resistivity</td><td>1.72e-08</td><td>1.72e-08</td><td>1.72e-08</td></tr><tr><td>Sheath Permeability</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Insulator 2 Outer Radius</td><td>0.014</td><td>0.014</td><td>0.014</td></tr><tr><td>Insulator 2 Relative Permittivity</td><td>3.72</td><td>3.72</td><td>3.72</td></tr><tr><td>Insulator 2 Relative Permeability</td><td>1.0</td><td>1.0</td><td>1.0</td></tr></tbody></table><h4 id="2-1-2-详细仿真步骤"><a href="#2-1-2-详细仿真步骤" class="headerlink" title="2.1.2 详细仿真步骤"></a>2.1.2 详细仿真步骤</h4><h4 id="步骤1-在电路中创建一个电缆配置组件："><a href="#步骤1-在电路中创建一个电缆配置组件：" class="headerlink" title="步骤1 - 在电路中创建一个电缆配置组件："></a>步骤1 - 在电路中创建一个电缆配置组件：</h4><p>（使用右键点击“Component Wizard…”然后选择“Cable”）</p><p>选择“Edit Parameters…”并输入线路长度和稳态频率。</p><h4 id="步骤-2-将此电缆接口组件复制到电路中"><a href="#步骤-2-将此电缆接口组件复制到电路中" class="headerlink" title="步骤 2 - 将此电缆接口组件复制到电路中"></a>步骤 2 - 将此电缆接口组件复制到电路中</h4><p>（或使用右键菜单 - Add Component | Cable Interface）<br>编辑参数：</p><ul><li>输入电缆名称（此名称在此仿真中必须唯一，并且必须与电缆配置中给定的名称匹配）。</li><li>输入在一个模型中耦合的电缆数量（1-8）。</li><li>输入每根电缆的电气连接（导体、护套、铠装）。</li><li>将此组件复制到电缆电气系统的接收端。</li></ul><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.1.png" alt="交流电路设计"></p><h4 id="步骤-3-打开电缆配置"><a href="#步骤-3-打开电缆配置" class="headerlink" title="步骤 3 - 打开电缆配置"></a>步骤 3 - 打开电缆配置</h4><p>（右键点击 - Edit Definition…）</p><h4 id="步骤-4-选择一个传输模型和选项"><a href="#步骤-4-选择一个传输模型和选项" class="headerlink" title="步骤 4 - 选择一个传输模型和选项"></a>步骤 4 - 选择一个传输模型和选项</h4><p>仅需将以下模型中的一个复制到电缆模块中。默认传输模型会自动创建。如果默认模型不是所需的模型，则删除默认模型并选择一个传输模型。<br>（右键菜单 “Select Transmission Model”）</p><h4 id="步骤-5-输入电缆数据"><a href="#步骤-5-输入电缆数据" class="headerlink" title="步骤 5 - 输入电缆数据"></a>步骤 5 - 输入电缆数据</h4><p>编辑接地组件的参数。<br>添加“电缆横截面”组件并编辑参数。</p><h4 id="步骤-6-Build-Modified"><a href="#步骤-6-Build-Modified" class="headerlink" title="步骤 6- Build &amp; Modified"></a>步骤 6- Build &amp; Modified</h4><p>遇到的问题：</p><ol><li>电缆尺寸矛盾，注意调整尺寸的大小，比如：</li></ol><ul><li>内部两根电缆的中心距离小于半径和——error</li><li>电缆是三根内部电缆总包成一根，因此不能直接采用官网例程中的三相分开，单根单相模型，需要修改模型。</li><li>接入交流信号（3信号维度）的元器件不能和直流信号（单信号维度）元件直接连接，需要加一个三叉戟样式的转换器件，接地GND也是。</li><li>需要额外安装一个<code>Intel Fortran Compiler</code>编译器。</li></ul><p>110KV pp电缆的科研参考材料中电缆的尺寸数据和本项目的电缆尺寸不同，按照不同层等比例缩小进行仿真尺寸设计。</p><h4 id="步骤-7-Run"><a href="#步骤-7-Run" class="headerlink" title="步骤 7- Run"></a>步骤 7- Run</h4><p>查看.out文件，里面包含了对电缆的阻抗参数分析。</p><p>（1）负载流数据:<br>正序和零序阻抗参数<br>阻抗参数包括电阻$R$和电抗$X$,通常以 per-unit (pu) 表示。下面是.out文件数据：</p><table><thead><tr><th>类型</th><th>参数</th><th>值</th></tr></thead><tbody><tr><td>正序阻抗</td><td>Resistance (R_{sq}) [pu]</td><td>0.217697348E-02</td></tr><tr><td></td><td>Reactance (X_{sq}) [pu]</td><td>0.375423769E-03</td></tr><tr><td></td><td>Susceptance (B_{sq}) [pu]</td><td>36.6116774</td></tr><tr><td></td><td>Surge Impedance (Z_{csq}) [pu]</td><td>0.320221929E-02</td></tr><tr><td>零序阻抗</td><td>Resistance (R_{sq}) [pu]</td><td>0.224356440E-02</td></tr><tr><td></td><td>Reactance (X_{sq}) [pu]</td><td>0.284711498E-03</td></tr><tr><td></td><td>Susceptance (B_{sq}) [pu]</td><td>36.6380254</td></tr><tr><td></td><td>Surge Impedance (Z_{csq}) [pu]</td><td>0.278763863E-02</td></tr></tbody></table><p>正序参数通常与电缆在平衡负载条件下的行为相关，而零序参数与非平衡条件下的行为相关，如单相接地故障。</p><p>（2）阻抗矩阵（Z矩阵）<br>阻抗矩阵提供了关于电缆各相之间的互感和自感的详细信息。</p><ul><li>系列阻抗矩阵 ($Z$)：表示单位长度（米）上的阻抗值，矩阵的每个元素都是一个复数，形式为 $M$,$N$ 表示 $M + jN$。</li><li>并联导纳矩阵 ($Y$)：表示单位长度（米）上的导纳值，矩阵的每个元素也是一个复数。</li></ul><p>.out文件输出了电缆的相域数据和负载流数据。</p><h3 id="2-2-对不同工况下聚丙烯电缆的模拟测试"><a href="#2-2-对不同工况下聚丙烯电缆的模拟测试" class="headerlink" title="2.2 对不同工况下聚丙烯电缆的模拟测试"></a>2.2 对不同工况下聚丙烯电缆的模拟测试</h3><h4 id="2-2-1-模拟聚丙烯电缆在不同温度情况下的工作情况"><a href="#2-2-1-模拟聚丙烯电缆在不同温度情况下的工作情况" class="headerlink" title="2.2.1 模拟聚丙烯电缆在不同温度情况下的工作情况"></a>2.2.1 模拟聚丙烯电缆在不同温度情况下的工作情况</h4><p>考虑长期运行温度110度，高温150度的情况。</p><h4 id="2-2-2-空间电荷效应在聚丙烯电缆中的绝缘老化现象"><a href="#2-2-2-空间电荷效应在聚丙烯电缆中的绝缘老化现象" class="headerlink" title="2.2.2 空间电荷效应在聚丙烯电缆中的绝缘老化现象"></a>2.2.2 空间电荷效应在聚丙烯电缆中的绝缘老化现象</h4><p>绝缘层空间电荷的积聚会导致内部电场的畸变，进而引发介质内局部放电、加速聚合物材料老化及电树枝生长，最终导致绝缘击穿故障，严重影响电缆性能和使用寿命。</p><p><img src="/images/PSCAD%E7%94%B5%E6%B0%94%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/9.png" alt="电缆绝缘层的电荷输运过程示意图"></p><h1 id="COMSOL简介"><a href="#COMSOL简介" class="headerlink" title="COMSOL简介"></a>COMSOL简介</h1><p>COMSOL是一种有限元仿真软件，可以对多物理场进行建模仿真；有丰富的案例库和文档手册支持。<br>中期电缆仿真报告采用COMSOL完成。</p><h1 id="中期电缆仿真报告"><a href="#中期电缆仿真报告" class="headerlink" title="中期电缆仿真报告"></a>中期电缆仿真报告</h1><div class="row">    <embed src="/pdf/电缆仿真中期报告.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二暑期实验室学习记录</title>
    <link href="/2024/07/15/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/15/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录大二暑假在实验室的专业学习~</p><span id="more"></span> <h1 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h1><h2 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h2><ol><li>Ansys仿真PP电缆</li><li>学习使用pscad仿真软件和COMSOL，对PP电缆进行仿真</li><li>深度学习部分</li></ol><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><ol><li>使用运放电路对电流互感器进行数据采样</li><li>摸鱼时间，完成至少一个嘉立创的开源硬件项目<br>PS：拜托！！ 这里有焊台，有常用的检测仪表，还有白嫖的一堆元器件！！</li></ol><h1 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h1><ul><li>7.15-7.19：使用PSCAD对PP电缆进行仿真和阻抗分析</li><li>7.20-7.22：使用COMSOL对PP电缆进行二维的几何建模和基础电磁场分析，完成中期报告</li><li>7.23-7.25：台风天，摸鱼天~完成发明专利的文书材料，并进行修改</li><li>7.26-7.29：对PP电缆进行三维的几何建模，进行频域和瞬态仿真，得到单相和三相电流波形</li><li>7.30-7.31：硬件实验室学习罗氏线圈测试电流的基本原理，调试积分器的增益，安装波形采集器的驱动，学习波形采集和FFT分析，预约现场测试时间</li><li>8.1：确定数据处理方案，查阅相关文献，拟定下周安排</li><li>8.2-8.4：学习JavaScript</li></ul><h1 id="电气小知识集萃"><a href="#电气小知识集萃" class="headerlink" title="电气小知识集萃"></a>电气小知识集萃</h1><h2 id="电力系统"><a href="#电力系统" class="headerlink" title="电力系统"></a>电力系统</h2><h3 id="Q：电力系统中，谐波的存在会产生什么影响？"><a href="#Q：电力系统中，谐波的存在会产生什么影响？" class="headerlink" title="Q：电力系统中，谐波的存在会产生什么影响？"></a>Q：电力系统中，谐波的存在会产生什么影响？</h3><ol><li>n次谐波，表示该谐波的频率是基频的n倍。</li><li>谐波会带来电流或电压的扭曲，闪变或者异常波动，这种情况会导致设备体温度升高，产生信号串扰，并使中性点的电压升高，进而造成一些不可预测的风险：<br>比如设备意外停机，火灾，电气事故等等。</li><li>谐波的监测设备：<code>谐波检测仪</code>，又称<code>谐波分析仪</code>。<br>绝大部分谐波测量仪器都使用傅立叶变换的方法来进行谐波测量，使用<code>傅立叶变换</code>进行谐波分析的前提是要求被分析的波形必须是一个周期波形，也就是说，使用傅立叶变换只能<code>测量整数次谐波</code>。极少数谐波检测仪可以检测分数谐波，测量分数谐波不能使用傅立叶变换的方法，</li></ol><h3 id="Q-什么是零序阻抗？"><a href="#Q-什么是零序阻抗？" class="headerlink" title="Q:什么是零序阻抗？"></a>Q:什么是零序阻抗？</h3><pre><code class="hljs">零序阻抗（Zero-Sequence Impedance）是电力系统中用于分析`不对称故障`（如单相接地故障）的一种参数。它是指在`零序分量`（所有三相电流或电压相等且同相位）的条件下，电力系统元件对零序电流的阻抗。</code></pre><ul><li><p>零序阻抗的背景<br>在电力系统中，电流和电压的对称分量法（Symmetrical Components）将不对称的三相系统分解为对称的正序、负序和零序分量：</p><ul><li>正序分量：三相电流或电压具有相同的幅值，依次相差120度。</li><li>负序分量：三相电流或电压具有相同的幅值，依次相差-120度。</li><li>零序分量：三相电流或电压具有相同的幅值和相位。</li></ul></li><li><p>零序阻抗的计算和意义<br>零序阻抗通常由系统元件（如变压器、发电机、电缆、线路等）的物理特性决定。它包括<code>零序电阻</code>和<code>零序电抗</code>。计算零序阻抗的方法通常包括短路试验或基于设备参数的计算。</p><ul><li>在零序条件下，通过设备的电流为零序电流，这些电流会在中性点或地线上循环，因此零序阻抗直接影响到单相接地故障时的电流大小和系统响应。</li></ul></li><li><p>零序阻抗的应用</p><ul><li>故障分析：在单相接地故障时，零序阻抗用于<code>计算故障电流和电压</code>。它帮助工程师评估故障对系统的影响，选择合适的保护设备和策略。</li><li>保护设置：零序阻抗影响<code>接地保护装置</code>的设定。正确的零序阻抗参数有助于准确<code>识别和隔离故障</code>，防止设备损坏和系统停电。</li><li>系统设计：在设计电力系统时，工程师需要考虑零序阻抗来优化系统的性能，确保在故障情况下系统能够安全运行。</li></ul></li><li><p>例子<br>考虑一个简单的电力系统，包括一个发电机、一个变压器和一段输电线路。每个元件都有其独特的零序阻抗：</p><ul><li>发电机：发电机的零序阻抗取决于其内部结构和接地方式。通常较小，因为发电机接地电阻较低。</li><li>变压器：变压器的零序阻抗与其绕组连接方式有关（如Y-Y、Y-Δ等）。<ul><li>例如，Y-Δ变压器不传输零序电流，因此在零序网络中表现为开路。</li></ul></li><li>输电线路：输电线路的零序阻抗包括导线的零序电阻和电抗，通常较大，因为零序电流流经地线或回路电阻。</li></ul></li></ul><h3 id="Q：什么是Surge-Impedance？"><a href="#Q：什么是Surge-Impedance？" class="headerlink" title="Q：什么是Surge Impedance？"></a>Q：什么是Surge Impedance？</h3><pre><code class="hljs">Surge Impedance：浪涌阻抗，也称为特性阻抗，是在传输线（如电力线或通信线）上描述波动（如电压波或电流波）如何传播的一个重要参数。它是电力工程和电信领域中的一个核心概念，对于理解和设计传输线系统至关重要。</code></pre><p>定义和公式<br>Surge impedance 是传输线的电阻、电感和电容参数的函数，其公式为：<br>$$<br>Z_0&#x3D;\sqrt{\frac{R+jwL}{G+jwC}}<br>$$</p><p>其中：<br>$Z_0$是特性阻抗，单位是欧姆（Ohms）。<br>$R$ 是单位长度的电阻，单位是欧姆&#x2F;米。<br>$L$ 是单位长度的电感，单位是亨利&#x2F;米。<br>$G$ 是单位长度的导纳，单位是西门子&#x2F;米。<br>$C$ 是单位长度的电容，单位是法拉&#x2F;米。</p><p>物理意义:<br>在理想情况下，如果传输线是无损的（即$R$和$G$都是零），特性阻抗简化为：<br>$$Z_0&#x3D;\sqrt{\frac{L}{C}}$$</p><p>这表明特性阻抗主要由线的电感和电容决定。特性阻抗是传输线的一个重要属性，因为它描述了线路如何响应电压和电流的变化，特别是在快速变化的情况下，如电压冲击。</p><h3 id="Q：什么是Susceptance？"><a href="#Q：什么是Susceptance？" class="headerlink" title="Q：什么是Susceptance？"></a>Q：什么是Susceptance？</h3><pre><code class="hljs">Susceptance，电纳Y的虚数部分，是电气工程中一个重要的概念，表示交流电路中对电流的容许性或接受度，通常用于描述电容或电感元件的行为。电纳是电阻（impedance）的倒数。电纳、电阻、电容和电感这些量都用于分析和设计交流电路，特别是在电力系统和信号处理中非常重要。</code></pre><p>电纳$Y$可以分解为电导$G$（实部）和电纳$B$（虚部）:<br>$$<br>Y&#x3D;G+jB<br>$$<br>电导$G$表示电路的真实功率消耗，而电纳$B$表示电路的无功功率，即能量在源和负载之间往复移动但不进行实际功率转换的部分。</p><ul><li><p>对于电容元件，Susceptance $B$为正值，表示其积累能量的能力。</p></li><li><p>对于电感元件，Susceptance $B$为负值，表示其释放能量的能力。</p></li><li><p>对于纯电容或纯电感的理想元件，Susceptance 的计算公式如下：</p><ul><li>电容的 Susceptance $B_C$：<br>$<br>B_C&#x3D;wC<br>$<br>其中，$w$是角频率，C是电容值。$w&#x3D;2\pi f$</li><li>电感的 Susceptance$B_L$:<br>  $B_L&#x3D;-\frac{1}{wL}$<br>  其中$L$是电感值。</li></ul></li></ul><h3 id="Q：什么是trapped-charge？"><a href="#Q：什么是trapped-charge？" class="headerlink" title="Q：什么是trapped charge？"></a>Q：什么是trapped charge？</h3><pre><code class="hljs">&quot;（trapped charge）是一个在电力系统特别是高压电缆中常见的现象。当电缆在没有完全放电的情况下被断开或重新通电时，电缆内可能残留的电荷就被称为困难电荷。这些电荷可以对电力系统的运行和设备的安全产生影响。</code></pre><p>困难电荷的产生原理</p><ul><li><p><code>电缆的电容特性</code>：高压电缆具有一定的电容，可以存储电荷。当电缆被通电时，其内部的介质（通常是绝缘材料）会储存电能。断电时，如果没有一个完全的放电过程，这些电能不会完全释放，形成困难电荷。</p></li><li><p>断开和重新通电：当电缆在有电荷的状态下断开，断路器或其他开关设备可能不能将电缆内的所有电荷放掉。这些残留的电荷如果未被妥善处理，当电缆再次通电时，这些困难电荷会突然释放，可能导致电压和电流的瞬间冲击。</p></li></ul><h2 id="绝缘老化的一些影响因素"><a href="#绝缘老化的一些影响因素" class="headerlink" title="绝缘老化的一些影响因素"></a>绝缘老化的一些影响因素</h2><ul><li><p>电压应力：<br>电缆在运行过程中，特别是高压电缆，其绝缘层经常承受高电压。电缆的电容特性会导致电荷在绝缘介质中积累，从而在材料中产生电场。持续的高电场强度可以加速绝缘材料的电化学分解，从而导致老化。</p></li><li><p>温度变化：<br>电荷的充放电过程会在电缆中产生热量，尤其是在频繁的充放电周期中更为显著。这种温度的升高可能会加速绝缘材料的热老化过程，特别是在材料已经由于外界环境或运行条件处于高温状态时。</p></li><li><p>局部放电：<br>电缆在特定的条件下，如存在微小的空气隙或绝缘材料的缺陷时，可能发生局部放电现象。这种局部放电可以在绝缘材料内部产生小的电弧，导致绝缘材料破坏，加速老化。电缆的电容特性与其内部的电场分布相关，不均匀的电场可以增加局部放电的风险。</p></li><li><p>水树和电树：<br>电缆绝缘材料在长期运行中可能形成微小的裂纹或通道，这些通道在电场作用下进一步发展成为所谓的水树或电树现象。这些结构损害了绝缘材料的完整性，是电缆绝缘老化的常见原因。电容特性影响电场的分布和强度，间接影响这些现象的发展。</p></li></ul><h2 id="电流互感器"><a href="#电流互感器" class="headerlink" title="电流互感器"></a>电流互感器</h2><p>作用：</p><ol><li>扩大电流表的量程，实现用小量程的表测量大电流。</li><li>隔离高压线路，确保人身和设备安全。</li></ol><p>电流互感器其实是一种特殊的变压器。<br>$$<br>\frac{I_1}{I_2}&#x3D;\frac{N_1}{N_2}&#x3D;K_i<br>$$<br>因此，电流互感器上二次侧导线穿几圈都是根据变比K来决定的。</p><p><img src="/images/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png" alt="实物图"></p><p><img src="/images/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.1.png" alt="电路原理图"></p><p><img src="/images/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.2.png" alt="注意要点"></p><p><a href="https://www.bilibili.com/video/BV1n14y1z7ik/?spm_id_from=333.337.search-card.all.click&vd_source=0997900aaf2a5d972f902ba195bbd223">感觉不错的哔站视频1——电流互感器采样电路设计</a></p><p><a href="https://www.bilibili.com/video/BV1kZ421K77W/?spm_id_from=333.337.search-card.all.click&vd_source=0997900aaf2a5d972f902ba195bbd223">感觉不错的哔站视频2——电流互感器穿几圈</a></p><p><a href="https://www.bilibili.com/video/BV1pm421W78b/?spm_id_from=333.788.recommend_more_video.-1&vd_source=0997900aaf2a5d972f902ba195bbd223">感觉不错的哔站视频3——电流互感器的使用</a></p><h2 id="RLC直流电缆测量"><a href="#RLC直流电缆测量" class="headerlink" title="RLC直流电缆测量"></a>RLC直流电缆测量</h2><p>RLC直流电缆测量指的是通过测量电缆的电阻（R）、电感（L）和电容（C）来评估电缆的电气特性。这些测量有助于了解电缆的性能、健康状况和故障情况。</p><p>(1) 电阻（R）测量<br>测量电缆电阻可以提供关于电缆材料和连接质量的信息。</p><p>(2) 电感（L）测量<br>电感是指电缆中导体在电流变化时产生的磁场，并且这种磁场对电流变化产生的反作用力。测量电感有助于了解电缆在交流电流下的表现。</p><ul><li>交流电感测量: 使用交流信号（通常是正弦波）测量电缆的电感。<ul><li>方法: 通过LCR测量仪施加已知频率的交流电流，测量产生的电压，计算电感值。</li></ul></li></ul><p>(3) 电容（C）测量<br>电容是指电缆在导体之间存储电荷的能力。电容测量能够揭示电缆的隔离性能和材料特性。</p><h3 id="RLC电缆仿真分析"><a href="#RLC电缆仿真分析" class="headerlink" title="RLC电缆仿真分析"></a>RLC电缆仿真分析</h3><h4 id="Step1：消除导体层"><a href="#Step1：消除导体层" class="headerlink" title="Step1：消除导体层"></a>Step1：消除导体层</h4><p>在进行RLC分析时，特别是在测量同轴电缆的情况下，需要先消除导体层，这是因为：</p><ul><li><p>减少误差：<br>导体层（如屏蔽层、护套等）可能引入额外的电阻、电感和电容成分，这些成分会干扰精确测量内导体的真实电气特性。<br>消除这些导体层可以减少这些干扰，使测量结果更准确地反映电缆本身的特性。</p></li><li><p>隔离目标导体：<br>为了单独测量和分析电缆核心导体的RLC参数，必须去除外部导体层。这可以确保测量只涉及内导体，而不包括外部导体的影响。</p><ul><li>特别是在多芯电缆或带有屏蔽层的电缆中，外层导体可能会引起互感和寄生电容的变化，影响测量结果。</li></ul></li><li><p>简化测量模型：<br>在测量和建模过程中，简化电缆结构有助于创建更简单和更易于理解的电气模型。</p></li><li><p>提高测量精度(实际测量中)<br>测量设备和技术，如四端测量法和LCR测量仪，通常需要直接连接到目标导体上进行精确测量。<br>通过去除导体层，可以确保测量设备直接接触到内导体，从而提高测量精度。</p></li></ul><h3 id="电缆相关的专业术语"><a href="#电缆相关的专业术语" class="headerlink" title="电缆相关的专业术语"></a>电缆相关的专业术语</h3><table><thead><tr><th>English Term</th><th>Chinese Translation</th><th>English Term</th><th>Chinese Translation</th></tr></thead><tbody><tr><td><code>Coaxial Cable</code></td><td>同轴电缆</td><td><code>Arrester</code></td><td>避雷器</td></tr><tr><td><code>conductor</code></td><td>导体</td><td><code>source impedence</code></td><td>源阻抗</td></tr><tr><td><code>sheath</code></td><td>护套</td><td><code>Aerial shunt conductance</code></td><td>架空分流电导</td></tr><tr><td><code>insulator</code></td><td>绝缘层</td><td><code>Aerial</code></td><td>架空</td></tr><tr><td><code>armour</code></td><td>铠层</td><td><code>resistivity</code></td><td>电阻率</td></tr><tr><td><code>permittivity</code></td><td>介电常数</td><td><code>relative permeability</code></td><td>相对磁导率</td></tr><tr><td><code>SC layer</code></td><td>屏蔽层&#x2F;半导层</td><td><code>outer radius</code></td><td>外半径</td></tr><tr><td><code>interface</code></td><td>接口</td><td><code>encompass</code></td><td>围绕</td></tr><tr><td><code>instantaneous</code></td><td>瞬时的</td><td><code>active power</code></td><td>有功功率</td></tr><tr><td><code>reactive power</code></td><td>无功功率</td><td><code>phase angle</code></td><td>相位角</td></tr><tr><td><code>Resistance </code></td><td>电阻</td><td><code>RMS </code></td><td>有效值</td></tr><tr><td><code>semi-conductor</code></td><td>半导体</td><td><code>Reactance </code></td><td>电抗</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>科研课题组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电气工程及其自动化专业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender学习笔记</title>
    <link href="/2024/07/11/Blender%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/11/Blender%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在3D建模和动画设计领域，Blender 是一款强大且免费的开源软件，具有优秀的性能和对众多技术的支持。</p><span id="more"></span> <h1 id="安装下载以及中文设置"><a href="#安装下载以及中文设置" class="headerlink" title="安装下载以及中文设置"></a>安装下载以及中文设置</h1><p><a href="https://blog.csdn.net/jieyucx/article/details/132066814">教程点这里</a></p><h1 id="基础篇：第一节——让手听话"><a href="#基础篇：第一节——让手听话" class="headerlink" title="基础篇：第一节——让手听话"></a>基础篇：第一节——让手听话</h1><h2 id="视图和视角的控制"><a href="#视图和视角的控制" class="headerlink" title="视图和视角的控制"></a>视图和视角的控制</h2><p>一、视角的调节</p><ol><li>控制观察视角：鼠标中键</li><li>平移视图：Shift+鼠标中键</li><li>缩放视图：滚动鼠标中键的滚轮</li></ol><p>二、摄像机视图<br>摄像机视图是最后渲染出来视频的样子。</p><p>三、正交视图和透视视图的切换<br>点击摄像机按钮下面的一个按钮进行切换。</p><p>四、主视图，侧视图，底视图的切换：<br>使用<code>~目录</code></p><h2 id="物体的控制"><a href="#物体的控制" class="headerlink" title="物体的控制"></a>物体的控制</h2><ol><li>左侧竖列，分别控制：</li></ol><ul><li>选中物体进行自由移动 <ul><li><code>快捷键：g</code></li><li>初始默认是框选，长按可以切换选择的模式：<code>调整、刷选(快捷键c)、套选工具</code></li></ul></li><li>沿XYZ轴三个方向平移  <ul><li><code>快捷键：g+x；g+y;g+z</code></li></ul></li><li>旋转物体 <ul><li><code>快捷键：r</code>默认垂直视图方向进行旋转</li><li><code>r+x;r+y;r+z</code></li></ul></li><li>沿XYZ轴三个方向缩放物体 <ul><li><code>快捷键：f+移动鼠标；f+x;f+y;f+z</code></li><li>按鼠标右键退出移动&#x2F;缩放&#x2F;旋转模式</li></ul></li><li>Alt+s：撤销缩放<br>Alt+r:撤销旋转<br>Alt+g:回到原初始新建的位置</li></ul><ol start="2"><li><code>删除</code>物体：选中然后delete;或者直接按键盘X，也可以直接删除物体。</li><li><code>新建</code>物体：Shift+A，出现菜单，点击网格，有很多默认的新建物体模型。</li><li><code>隐藏</code>物体：</li></ol><ul><li>隐藏选中的物体：选中物体，按快捷键H</li><li>把没有选中的物体隐藏：Shift+h</li><li>取消隐藏：Alt+h<ul><li>可以通过查看物体列表的小眼睛来判断是否隐藏好</li></ul></li></ul><ol start="5"><li><code>复制</code>物体：Shift+d移动并复制</li></ol><h2 id="课堂小结"><a href="#课堂小结" class="headerlink" title="课堂小结"></a>课堂小结</h2><p><img src="/images/Blender%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt="笔记截图"></p>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansys仿真——三相感应电机</title>
    <link href="/2024/07/11/Ansys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA/"/>
    <url>/2024/07/11/Ansys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E4%B8%89%E7%9B%B8%E6%84%9F%E5%BA%94%E7%94%B5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>小学期实习内容：使用Ansys进行电磁场仿真。</p><span id="more"></span> <p>参考学习教程为：《Ansoft 12在工程电磁场中的应用》。</p><h1 id="仿真报告"><a href="#仿真报告" class="headerlink" title="仿真报告"></a>仿真报告</h1><div class="row">    <embed src="/pdf/电气工程认知实习仿真报告_陈韵如.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="绕电机实践报告"><a href="#绕电机实践报告" class="headerlink" title="绕电机实践报告"></a>绕电机实践报告</h1><div class="row">    <embed src="/pdf/电气工程实习绕电机报告_陈韵如.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年美赛数模论文存档</title>
    <link href="/2024/05/03/2024%E5%B9%B4%E7%BE%8E%E8%B5%9B%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/05/03/2024%E5%B9%B4%E7%BE%8E%E8%B5%9B%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>存档留念，with my teammates.</p><span id="more"></span> <p> 时间：2024.2.2——2024.2.6</p><p> 地点：南京理工大学</p><p><img src="/images/2024%E5%B9%B4%E7%BE%8E%E8%B5%9B%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E5%AD%98%E6%A1%A3/1.png" alt="证书"></p><div class="row">    <embed src="/pdf/2409283.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工磁电磁场Ansys仿真——永磁同步电机</title>
    <link href="/2024/05/02/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/"/>
    <url>/2024/05/02/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>使用Ansys进行电磁场仿真。</p><span id="more"></span> <p>参考学习教程为：《Ansoft 12在工程电磁场中的应用》。</p><p>稳态磁场的分析通常归结为两大类：<code>静态磁场分析</code>与<code>涡流磁场分析</code>，两种磁场的本质区别在于磁场是否随时间的变化而改变。</p><ul><li>静态磁场是指所有的磁场量均不随时间改变而改变。</li><li>涡流磁场则是指激励随时间按正弦或者余弦规律变化。但从统计意义上来讲，它又是时间平稳的，我们通常将这样的磁场看成是准静态的电磁场，称之为谐性磁场或似稳场。</li></ul><h1 id="仿真目标描述"><a href="#仿真目标描述" class="headerlink" title="仿真目标描述"></a>仿真目标描述</h1><p>三相永磁同步电动机，由定子铁心、定子绕组、永磁体磁极、转子铁心组成。</p><p>电机定子内径、外径分别为 74mm 和 120mm，极数 4，定子槽数 24，电机为对称结构可以建立四分之一模型，本次仿真采用<code>整域求解</code>，问题求解电机的平均电磁转矩及场图分布。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/1.png" alt="4级24槽永磁电机结构示意图"></p><h2 id="Ansoft-软件进行有限元分析的基本步骤如下："><a href="#Ansoft-软件进行有限元分析的基本步骤如下：" class="headerlink" title="Ansoft 软件进行有限元分析的基本步骤如下："></a>Ansoft 软件进行有限元分析的基本步骤如下：</h2><ol><li>创建项目及定义分析类型</li></ol><ul><li>选择 maxwell 2D 求解器，坐标平面选择 XY 坐标系统。</li></ul><ol start="2"><li>建立几何模型</li><li>定义及分配材料</li><li>定义及加载激励源和边界条件</li><li>求解参数设定</li><li>后处理</li></ol><h1 id="构建几何模型"><a href="#构建几何模型" class="headerlink" title="构建几何模型"></a>构建几何模型</h1><h2 id="确定模型单位：mm"><a href="#确定模型单位：mm" class="headerlink" title="确定模型单位：mm"></a>确定模型单位：mm</h2><p>菜单<code>Modeler/Units</code>，列表中的单位默认为 mm，当选择新的单位时，鼠标左键单击要选择的单位并执行&#x2F;Rescale to new units&#x2F;命令，将模型窗口的单位转为所要选择的单位。</p><h2 id="绘制电机定子槽几何模型"><a href="#绘制电机定子槽几何模型" class="headerlink" title="绘制电机定子槽几何模型"></a>绘制电机定子槽几何模型</h2><p>Ansoft 模型建立一般采用自下而上的方式，以点—线—面逐步进行模型生成。</p><p>（1）选择<code>Draw/Line</code></p><ul><li>第一点（1.25, 37.5）</li><li>第二点（1.25, 38.0）</li><li>第三点（2.4, 38.5）</li><li>第四点（3.4, 46.5）</li></ul><p>最后一个点输入完成后，双击两次 Enter 键以结束直线段绘制。</p><p>（2）通过镜像，<code>Edit/Duplicate/Mirror</code>，对称生成成另半槽直线部分模型，然后根据以下坐标点，<code>Draw/Arc/Center Point</code>完成定子槽底弧线部分模型建立。</p><ul><li>中心 (0, 46.5) </li><li>左侧 (-3.4, 46.5) </li><li>右侧 (3.4, 46.5)</li></ul><p>（3）执行命令 <code>Edit/Duplicate/Around Axis</code>，出现沿轴复制属性对话框，在 Axis 选择沿 Z轴复制，相隔 <code>15 度</code>，进行 <code>24 次</code>复制。</p><p>（4）执行弧线绘制命令 <code>Draw/Arc/Center Point</code>，中心原点选择为（0,0），将各个定子槽之间用圆弧连接。</p><p>（5）选择所有物体并执行命令<br><code>Modeler/Boolean/Unite</code>，将所有线段组合为一个object。</p><h2 id="绘制电机绕组几何模型"><a href="#绘制电机绕组几何模型" class="headerlink" title="绘制电机绕组几何模型"></a>绘制电机绕组几何模型</h2><p>（1）执行 Draw&#x2F;Line 命令，分别输入点坐标（2, 39）、（3, 46.5）以及（-2, 39）、（-3, 46.5）绘制两条直线，然后执行命令 Draw&#x2F;Arc&#x2F;Center Point，中心原点选择为（0,0），以两侧点坐标（3, 46.5）、（-3, 46.5）绘制弧线，并将所有线段闭合连接，执行 Modeler&#x2F;Boolean&#x2F;Unite操作，合成一体。</p><p>（2）执行命令 Edit&#x2F;Duplicate&#x2F;Around Axis，选择沿 Z 轴复制，相隔 15 度，进行 24 次复制，生成所有槽绕组。</p><h2 id="创建电机定子冲片模型"><a href="#创建电机定子冲片模型" class="headerlink" title="创建电机定子冲片模型"></a>创建电机定子冲片模型</h2><p>(1)由于Ansoft软件最后是对<code>面</code>进行操作，因此需要将建立的定子槽与绕组创建为面域，此过程通过执行命令 <code>Modeler/Surface/Cover lines</code> 来完成。</p><p>(2)此时生成的电机定子槽与绕组面相互重叠，执行布尔操作命令 <code>Modeler/Boolean/Substract</code> 将两者分开，在 <code>Blank Parts</code> 中选择定子槽，代表减操作，在 <code>Tool Parts</code> 中将 24 个绕组选择，代表被减操作。注意在此处操作时一定要将<code>[Clone tool objects before substracting]</code>选择框选上，以保留布尔操作后电机绕组模型。</p><p>(3)绘制圆，在模型窗口中选择绝对增量 Absolute,圆中心坐标（0，0），X 与 Y 偏移坐标分别为（0，60），由于分析的永磁电机外径为 120mm。选择新生成的圆，执行 Modeler&#x2F;Surface&#x2F;Cover lines 命令以生成面域，连续两次执行布尔操作命令 Modeler&#x2F;Boolean&#x2F;Substract。</p><ul><li>第一次在 Blank Parts 中选择 Circle1，在 Tool Parts<br>中选择所有定子绕组面域，单击 ok 按纽</li><li>第二次在 Blank Parts 中选择 Circle1，在 Tool Parts<br>中选择 Polyline1 定子槽面域，单击 ok 按纽完成电机定子冲片模型</li></ul><p>注意两次操作一定将[Clone tool objects before substracting]选择框选上，且操作顺序依次进行，如果顺序错误，则通过第一次操作所生成的面域不再连续，因此无法继续完成下面操作。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/2.png" alt="电机定子冲片模型"></p><h2 id="创建永磁体模型"><a href="#创建永磁体模型" class="headerlink" title="创建永磁体模型"></a>创建永磁体模型</h2><p>（1）执行 Draw&#x2F;Line 命令绘制永磁体直线段模型，分别输入第一条线始末点坐标（-21.91，29.81）和（-18.36,24.98），第二条线始末点坐标（21.91，29.81）和（18.36,24.98）。</p><p>（2）执行命令 Draw&#x2F;Arc&#x2F;Center Point，中心原点选择为（0,0），以两条直线段的相应始末点为两侧点绘制弧线，完成第一片磁极模型建立。</p><p>（3）选择建立的永磁体所有线段，执行命令 Modeler&#x2F;Boolean&#x2F;Unite，将所有线段连接，再执行命令 Modeler&#x2F;Surface&#x2F;Cover lines 生成永磁体面域。接下来生成其余三片永磁体模型，选择刚生成的永磁体面域，执行命令Edit&#x2F;Duplicate&#x2F;Around Axis，选择沿Z轴复制，相隔90 度，进行 4 次复制，生成永磁体模型。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/3.png" alt="永磁体模型"></p><h2 id="创建转子轭模型和转轴模型"><a href="#创建转子轭模型和转轴模型" class="headerlink" title="创建转子轭模型和转轴模型"></a>创建转子轭模型和转轴模型</h2><p>（1）以永磁体内圆的八个点 A、B、C、D、E、F、G、H，为始末点，原点(0,0)为中心执行命令 Draw&#x2F;Arc&#x2F;Center Point，绘制出电机转子轭外圆线段，选择所绘制的八段弧线执行Modeler&#x2F;Boolean&#x2F;Unite 操作，合成一体，再执行 Modeler&#x2F;Surface&#x2F;Cover lines 生成转子轭面域。</p><p>（2）由于此时，永磁体及转子轭面域与定子槽的面域相互重叠，因此执行命令<br>Modeler&#x2F;Boolean&#x2F;Substract，在 Blank Parts 中选择定子槽面域，在 Tool Parts 中选择永磁体及转子轭面域，单击 ok 按纽，完成各个面域之间的分离。</p><p>（3）绘制圆，在模型窗口中选择绝对增量 Absolute,圆中心坐标（0，0），X 与 Y 偏移坐标分别为（0，13），分析的永磁电机转轴外径为 26mm。</p><p>（4）选择生成的圆线段，执行 Modeler&#x2F;Surface&#x2F;Cover lines 生成转轴面域，再执行命令Modeler&#x2F;Boolean&#x2F;Substract，在 Blank Parts 中选择转子轭面域，在 Tool Parts 中选择转轴面域，此时[Clone tool objects before substracting]选择框不选，单击 ok 按纽。</p><h2 id="模型显示属性设置"><a href="#模型显示属性设置" class="headerlink" title="模型显示属性设置"></a>模型显示属性设置</h2><p>对各个部分重新进行属性设置，其主要包括<code>面域名称</code>及显示<code>颜色</code>两部分。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/4.png" alt="电机几何模型图"></p><h1 id="材料定义及分配"><a href="#材料定义及分配" class="headerlink" title="材料定义及分配"></a>材料定义及分配</h1><p>材料属性的指定是通过材料管理器来实现的。在建立几何模型时，所有部件的材料属性都默认为真空 vacuum，对于永磁同步电动机静磁场分析，需要指定以下材料属性：</p><ul><li>指定气隙 Air-gap 材料属性——空气（亦可采用默认材料属性真空）；</li><li>指定绕组 coil 材料属性——铜</li><li>定义定子铁心 Stator 及转子轭 yoke 材料属性 DW465-50,一种电机常用非线性铁磁材料，位于RX拓展库中；</li><li>永磁体材料，命名为 P_N和P_S,指定给永磁磁极；</li></ul><h2 id="永磁体材料设置"><a href="#永磁体材料设置" class="headerlink" title="永磁体材料设置"></a>永磁体材料设置</h2><center class="half"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/5.png" width="250/"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/51.png" width="250/"></center><p>将建立的永磁材料 P_N和P_S，分配给各个磁极，通过单击各个磁极面域所弹出的属性设置对话框来完成。</p><h2 id="激励源与边界条件定义及加载"><a href="#激励源与边界条件定义及加载" class="headerlink" title="激励源与边界条件定义及加载"></a>激励源与边界条件定义及加载</h2><p>磁场分析中，每个被分析的问题，至少存在一种激励源，在永磁同步电机分析中，存<br>在着<code>电机定子绕组电流源</code>与<code>永磁体</code>两种激励源。</p><ul><li>永磁体激励源在材料管理器中已经定义并分配给了磁极，因此，在此部分激励源仅定义绕组的电流源。</li></ul><p>对于边界条件，电机求解域的外边界及转子轭与转轴的交界都应施加相应的边界条件，此问题中由于两处边界均为高导磁介质与非导磁介质的分界处，因此，施加<code>磁通平行边界条件</code>即可，这也是电机分析中为常用的边界条件。</p><h3 id="绕组分相"><a href="#绕组分相" class="headerlink" title="绕组分相"></a>绕组分相</h3><p>根据电机设计单中的绕组排列对三相永磁同步电动机定子槽中的绕组进行分相，各相<br>正绕组用英文 Phase 表示，负绕组用英文 Return 表示，例如对于 60 度相带电机绕组一般采用 A、Z、B、X、C、Y 表示，A、B、C 分别代表三相正绕组，X 代表 A 相负绕组，Y代表 B 相负绕组，Z 代表 C 相负绕组，在此数值计算中 A 表示 A_Phase，X 表示为 A_Return，其它表示类似。</p><h3 id="加载电流激励源"><a href="#加载电流激励源" class="headerlink" title="加载电流激励源"></a>加载电流激励源</h3><p>选择 A_Phase 相四个绕组，执行命令 <code>Maxwell 2D/Excitations/Assign/Current</code>，将弹出电流激励源设置对话框，在源名称中输入 A_P，值 Value 中输入 25，A 相由四个绕组组成因此总的 A 相电流为 100 安培，单位安培 A，参考方向为正方向，在 Ansoft 软件中正方向指电流流出分析平面，负方向指电流流入分析平面，在本问题分析中，只选择正方向，电流值则采用“正负”表示。</p><p>对于 B、C 相绕组的加载方式与 A 相绕组加载相同，命名方式相类似，由于三相对称<br>绕组，B、C 相分别电流相位分别落后与 A 相电流相位 120 度和 240 度，因此其值为 12.5安培。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/8.png" alt="加载电流激励源"></p><h3 id="加载边界条件"><a href="#加载边界条件" class="headerlink" title="加载边界条件"></a>加载边界条件</h3><p>选择电机内外圆两条边界，首先执行 <code>Edit/Select/Edge</code> 命令，选择边界线，再执行命令 <code>Maxwell 2D /Boundaries/ Assign/ Vector Potential</code>，此时会自动弹出磁位函数边界设置对话框，在Name 框中输入边界条件名称 Boundary，参数值设置为 0 即边界出无磁场通过，也就是说<code>电机无边界漏磁存在</code>。</p><center class="half"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/7.png" width="250/"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/7-1.png" width="200/"></center><h1 id="求解选项参数设定"><a href="#求解选项参数设定" class="headerlink" title="求解选项参数设定"></a>求解选项参数设定</h1><p>除了计算电磁场外，还需要确定电机转子上所产升的电磁力、力矩及电机绕组<br>的电感等参数，在静磁场分析中，这些参数的求解需要事先设定。</p><h2 id="力和力矩设置"><a href="#力和力矩设置" class="headerlink" title="力和力矩设置"></a>力和力矩设置</h2><p>选择需要计算力及力矩参数的面域，包含四个磁极及转子轭部分，执行命令<br><code>Maxwell 2D /Parameters/ Assign/ Force</code>和命令 <code>Maxwell 2D /Parameters/ Assign/ Toque</code>，弹出力及力矩设置对话框，参考坐标均为 Global。</p><center class="half"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/9.png" width="150/"><img src="/images/工磁电磁场Ansys仿真——永磁同步电机/9-1.png" width="330/"></center><h2 id="电感矩阵设置"><a href="#电感矩阵设置" class="headerlink" title="电感矩阵设置"></a>电感矩阵设置</h2><p>Ansoft 静态电感矩阵的计算是基于特定激磁下，导体包围区域的线性磁导条件下计<br>算的，也就是说，电感矩阵的计算是对于完整闭合绕组的，而不是对于单根导体而言，因<br>此，在设定电感矩阵参数时应确定每个绕组的回路关系。</p><p>（1）执行命令 Maxwell 2D &#x2F;Parameters&#x2F; Assign&#x2F; Matrix，将自动弹出矩阵属性设置对话框，名称设置对话框中输入名称 L_Matrix，Source 选项中选择各相的正绕组，选择 Include选择项，在 Retur Path 选项中选择每条支路所闭合的负绕组，一构成完整的闭合线圈。</p><p>（2）回路设置完成后，单击矩阵设置对话框中的 Post Processing 按钮，弹出分组设置对话框，由于本次分析的永磁电机由每相绕组由 4 个槽绕组构成，因此为分析每相绕组的电感时应将属于同相的绕组进行分组，例如 A 相绕组由 A_P_1、A_P_2、A_P_3、A_P_4 组成，因此通过选择此四个绕组，电机 Group 按钮完成分组，名称设置为 A_winding，其它两相操作类似。</p><h2 id="网格剖分设置"><a href="#网格剖分设置" class="headerlink" title="网格剖分设置"></a>网格剖分设置</h2><p>Ansoft 12 的网格设置通过执行命令 Maxwell 2D &#x2F;Mesh Operations&#x2F; Assign&#x2F; On selection (Inside Selection、Surface Approximatio)来完成，本例采用基于模型内部单元边长的剖分设置进行模型剖分，在弹出的设置对话框中，名称设置为 Length，长度设置为2mm。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/10.png" alt="模型剖分图"></p><h2 id="求解残差设定"><a href="#求解残差设定" class="headerlink" title="求解残差设定"></a>求解残差设定</h2><p>执行命令 Maxwell 2D &#x2F;Analysis Setup&#x2F; Add Solution setup，自动弹出求解设置对话框，主要包括一般设置、收敛设置及求解设置，大部分保持默认设置即可，将收敛率改为10%。</p><h2 id="分析自检"><a href="#分析自检" class="headerlink" title="分析自检"></a>分析自检</h2><p>有限元分析的模型、载荷、边界，求解项设置均完成后，执行命令 Maxwell 2D<br>&#x2F;Validation check，弹出自检对话框，当所有设置正确后，每项前出现对勾提示。</p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/11.png" alt="分析自检通过"></p><h1 id="仿真效果展示"><a href="#仿真效果展示" class="headerlink" title="仿真效果展示"></a>仿真效果展示</h1><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/13.png" alt="电机磁力线分布"></p><p><img src="/images/%E5%B7%A5%E7%A3%81%E7%94%B5%E7%A3%81%E5%9C%BAAnsys%E4%BB%BF%E7%9C%9F%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA/12.png" alt="电机磁通密度云图分布"></p>]]></content>
    
    
    <categories>
      
      <category>仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.0HUB四层板设计</title>
    <link href="/2024/04/14/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/04/14/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>成图校赛学习的四层板PCB设计！</p><span id="more"></span><h1 id="3-0HUB板设计概述"><a href="#3-0HUB板设计概述" class="headerlink" title="3.0HUB板设计概述"></a>3.0HUB板设计概述</h1><h2 id="四层板"><a href="#四层板" class="headerlink" title="四层板"></a>四层板</h2><p>一般pcb四层板，如下安排：顶层和底层为信号层，中间2层分别为电源层和地层。电源层与地线层在中间可以起到隔离作用，减少干扰的作用。</p><p>对于尺寸较大的pcb四层板，元器件比较宽松的PCB板也可以用两层完成，如果两层布局困难，排不开的话，容易造成干扰的，可以使用4层解决过分拥挤的困难。</p><center class="half"><img src="/images/3-0HUB四层板设计/1.png" width="300/"><img src="/images/3-0HUB四层板设计/2.png" width="300/"></center><p>不同的层叠结构有着不同的应用情景，如果器件在顶层布局或者关键信号线在顶层走线连接，GND最好放在第二层，采用层叠结构1；若器件在底层布局或者关键信号线在底层走线连接，则GND最好放在第三层，采用层叠结构2。</p><h2 id="阻抗干扰"><a href="#阻抗干扰" class="headerlink" title="阻抗干扰"></a>阻抗干扰</h2><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/3.png" alt="阻抗干扰"></p><h3 id="嘉立创阻抗计算神器"><a href="#嘉立创阻抗计算神器" class="headerlink" title="嘉立创阻抗计算神器"></a>嘉立创阻抗计算神器</h3><p>在嘉立创官网进入阻抗计算服务页面，设置参数，可以一键生成需要的线宽。</p><ul><li>四种阻抗模式的选择：</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/4.png" alt="阻抗模式"></p><p>这里假设需求阻抗为90Ω，模式选择差分阻抗，阻抗层为L1，即在顶层进行走线，按照前面的层叠结构1，第二层为GND层，因此下参考层为L2，，间距按照默认8mil。</p><ul><li>点击计算</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/5.png" alt="阻抗计算"></p><ul><li>注意：线宽不能随意设置，需要考虑生产加工的限制，嘉立创多层板的最小线宽为3.5mil,还需要留有一定的余量保证生产合格率，因此嘉立创多层板的最小线宽不要小于6mil。</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/6.png" alt="共面与否的区别"></p><h2 id="USB端口设计"><a href="#USB端口设计" class="headerlink" title="USB端口设计"></a>USB端口设计</h2><center class="half"><img src="/images/3-0HUB四层板设计/6.png" width="300/"><img src="/images/3-0HUB四层板设计/7.png" width="420/"></center><p>USB接口选型：</p><ul><li>对于TYPE-C接口类型，只有24P全功能TYPE-C才有差分数据引脚，为USB3.x及以上版本。</li><li>对于TYPE-B接口类型，外形上就比较好区分。</li></ul><center class="half"><img src="/images/3-0HUB四层板设计/8.png" width="370/"><img src="/images/3-0HUB四层板设计/88.png" width="400/"></center><h1 id="基于VL812的3-0HUB芯片电路设计"><a href="#基于VL812的3-0HUB芯片电路设计" class="headerlink" title="基于VL812的3.0HUB芯片电路设计"></a>基于VL812的3.0HUB芯片电路设计</h1><p>新建工程，命名保存之后打开电路图设计界面。</p><h2 id="主控芯片VL812"><a href="#主控芯片VL812" class="headerlink" title="主控芯片VL812"></a>主控芯片VL812</h2><p>在立创商城搜索VL812芯片，放置，点击属性查看数据手册。</p><p>通过Product Features 可以快速了解一款芯片的特性。</p><p>点击芯片，右键选择<code>编辑符号</code>，进入符号编辑界面。可以顺带查看每个引脚的功能。</p><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/9.png" alt="芯片引脚符号"></p><ul><li><p>1号引脚SSREXT，官方实例要求连接6.04kΩ的电阻之后再接地。</p></li><li><p>31号引脚VBUSDET：检测是否存在5V电源的输入，高电平时表示存在高电平输入，低电平表示不存在。</p></li><li><p>32号-35号引脚都是用来检测过电流的，这里不需要，之间不连接。</p></li></ul><h3 id="计算晶振匹配电容："><a href="#计算晶振匹配电容：" class="headerlink" title="计算晶振匹配电容："></a>计算晶振匹配电容：</h3><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/10.png" alt="晶振匹配电容计算公式"></p><h3 id="USB3-0差分信号极性问题"><a href="#USB3-0差分信号极性问题" class="headerlink" title="USB3.0差分信号极性问题"></a>USB3.0差分信号极性问题</h3><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/11.png" alt="USB3.0差分信号极性问题"></p><ul><li><p>小知识：在USB3.0的SSTX信号线中，常常串联一个100NF的贴片电容，减少低频干扰，提升信号质量。</p></li><li><p>VBUS是USB接口中提供电源电压的信号线。通过VBUS，主机端可以向连接的设备提供所需的电源，使其正常工作。</p></li></ul><h3 id="TVS二极管"><a href="#TVS二极管" class="headerlink" title="TVS二极管"></a>TVS二极管</h3><p>TVS即Transient Volatge Suppressor，中文名称：瞬态电压抑制二极管，又称雪崩击穿二极管。在通常情况下，我们称之为TVS二极管。<br>    - 其在电路中的作用主要是保护敏感电路，免受高电压瞬变损坏的组件。其中，大部分用于端口的保护，防止端口瞬间的电压冲击造成后级电路的损坏。其中高压瞬变的主要来源是静电放电，电气快速瞬变和浪涌事件。</p><h3 id="限流保护芯片"><a href="#限流保护芯片" class="headerlink" title="限流保护芯片"></a>限流保护芯片</h3><p>这里选用的是MT9700。</p><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/12.png" alt="限流保护芯片的SET电阻选择"></p><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/13.png" alt="官方参考连接方式"></p><h3 id="螺丝"><a href="#螺丝" class="headerlink" title="螺丝"></a>螺丝</h3><p>在常用库中找到螺丝，选择M3，方便后续对板子进行固定</p><h2 id="DRC检查"><a href="#DRC检查" class="headerlink" title="DRC检查"></a>DRC检查</h2><p>检查原理图的一些问题。</p><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/144.png" alt="原理图"></p><h1 id="PCB布局"><a href="#PCB布局" class="headerlink" title="PCB布局"></a>PCB布局</h1><h2 id="绘制板框范围，倒圆角"><a href="#绘制板框范围，倒圆角" class="headerlink" title="绘制板框范围，倒圆角"></a>绘制板框范围，倒圆角</h2><p>嘉立创免费打板的范围是100*100(mm)，因此先把这个最大的板框范围画出来。然后点击板框，设置半径为5mm的倒圆角。</p><h2 id="粗调元器件的布局"><a href="#粗调元器件的布局" class="headerlink" title="粗调元器件的布局"></a>粗调元器件的布局</h2><ul><li>调整好之后，固定螺丝的位置，<code>锁定</code>。</li><li>四个输出接口，选择底部对齐和水平等距分布，调整好位置之后也点击<code>锁定</code>。</li><li>可以点击<code>工程设计-网络</code>,用不同的颜色区分电源线和信号线，但是注意不要弄成红色、蓝色线（容易跟切换顶层和底层时候的指示色相混淆）。</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/14.png" alt="粗调布局"></p><ul><li>输出电源引脚最好都外接100nF的电容，用于滤波。<ul><li>有多少个<code>没有外接电容</code>的裸露电源引脚，就放多少个100nF的滤波电容并联。<br>  -顶层是走高速信号线的，因此大量的滤波电容建议放在底面，就近放置，避免造成干扰。</li></ul></li></ul><h2 id="设计规则设置"><a href="#设计规则设置" class="headerlink" title="设计规则设置"></a>设计规则设置</h2><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/111.png" alt="板子层数的设置"></p><ul><li>板子层数的设置：点击<code>工具-图层管理器-铜箔层改为4</code><ul><li>一般将两个内层都设置为内电层，一个用于GND层，一个用于电源层。点击应用，确认保存。</li><li>内层1和内层2都默认为GND网络。</li></ul></li><li>阻抗计算：USB3.0一般需要控制阻抗在90欧姆左右，通过嘉立创的阻抗计算神器计算。<ul><li>USB3.0采用的差分信号线，顶层平面元器件不算拥挤，可以使用共面阻抗。因此，选择<code>共面差分阻抗</code>模式。<br> -走线层为L1, 即顶层，参考层为GND，为L2，其余参数保持默认。</li><li>差分线宽为计算得到的数据。</li></ul></li><li>回到编辑器页面，选择<code>设计-设计规则</code><ul><li>安全间距设为6mil,嘉立创的免费打样最低间距不要小于6mil。<br>  -导线线宽设为8mil，默认线宽是10，需要检查默认线宽和芯片的焊盘是否匹配，进行调整。</li><li>差分线宽严格按照计算数据进行设置。</li><li>过孔尺寸设置：内直径的最小免费尺寸为12mil,不要修改，默认为12即可。外直径进行一定的设置。<br>  -<code>内电层</code>和<code>铺铜</code>：均主要设置<code>到边框/槽孔间距</code>为40mil。</li></ul></li></ul><center class="half"><img src="/images/3-0HUB四层板设计/16.png" width="400/"><img src="/images/3-0HUB四层板设计/17.png" width="400/"></center><center class="half"><img src="/images/3-0HUB四层板设计/18.png" width="400/"><img src="/images/3-0HUB四层板设计/19.png" width="400/"></center><h2 id="走线"><a href="#走线" class="headerlink" title="走线"></a>走线</h2><p>先走芯片周围的杂线，再走高速信号线。</p><ul><li>点击<code>设计-差分对管理器</code>，设置15组差分对高速信号线。然后选择<code>布线-差分对布线</code><ul><li>布线优先级：优先考虑SSTX和SSRX（USB3.0高速信号线），然后才是HP（USB2.0信号线）。</li></ul></li><li>晶振周围需要进行<code>包地处理</code>。</li></ul><h2 id="DRC检查-1"><a href="#DRC检查-1" class="headerlink" title="DRC检查"></a>DRC检查</h2><ul><li>内电层报错：点击内电层，重建内电层。</li><li>差分线等长调节，单边，一般最小振幅为1mil，最大振幅为24mil（3W原则）。</li><li>GND最后统一铺铜：点击<code>放置-铺铜-矩形</code>，将整个PCB板框起来，然后顶层和底层铺铜。<ul><li>快捷键<code>shift+m</code>隐藏or展现铺铜。</li><li><code>shift+b</code>重新铺铜。</li></ul></li><li>游离的铜块不利于信号传输，需要进行处理。点击<code>放置-禁止区域-矩形</code></li><li>有些时候3D视角的元器件不显示，应该是嘉立创没有更新元件的3D视图，换一个商家的试试应该就可以。</li></ul><h2 id="最终成品展示"><a href="#最终成品展示" class="headerlink" title="最终成品展示"></a>最终成品展示</h2><ul><li>原理图：</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/144.png" alt="原理图"></p><ul><li>PCB板子：</li></ul><center class="half"><img src="/images/3-0HUB四层板设计/G20.png" width="400/"><img src="/images/3-0HUB四层板设计/211.png" width="400/"></center><ul><li>3D模型：</li></ul><p><img src="/images/3-0HUB%E5%9B%9B%E5%B1%82%E6%9D%BF%E8%AE%BE%E8%AE%A1/21.png" alt="3D模型"></p>]]></content>
    
    
    <categories>
      
      <category>硬件方向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PCB设计项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F103C8T6最小系统板(电控)学习指南</title>
    <link href="/2024/03/03/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2024/03/03/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>学习stm32的基本开发笔记~</p><span id="more"></span> <h1 id="学习一下这块最小系统板"><a href="#学习一下这块最小系统板" class="headerlink" title="学习一下这块最小系统板"></a>学习一下这块最小系统板</h1><p><a href="https://zhuanlan.zhihu.com/p/669325586">不错的讲解，点这里</a></p><h2 id="Stm32F103C8T6的常用引脚"><a href="#Stm32F103C8T6的常用引脚" class="headerlink" title="Stm32F103C8T6的常用引脚"></a>Stm32F103C8T6的常用引脚</h2><p><a href="https://blog.csdn.net/nolate_chen/article/details/132359815?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170964934116800227461640%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170964934116800227461640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-132359815-null-null.142%5Ev99%5Epc_search_result_base5&utm_term=stm32f103c8t6%E5%BC%95%E8%84%9A%E5%8A%9F%E8%83%BD&spm=1018.2226.3001.4187">STM32F103C8T6引脚功能整理</a></p><ol><li>通用I&#x2F;O口</li></ol><ul><li><p>PA0-PA15： 16个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断、模拟输入等。</p></li><li><p>PB0-PB15： 16个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断、模拟输入等。</p></li><li><p>PC13-PC15： 3个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p></li><li><p>PD0-PD2： 3个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p></li><li><p>PE0-PE5： 6个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p></li><li><p>PF0-PF1： 2个通用I&#x2F;O引脚，可用于输入&#x2F;输出、外部中断等。</p></li></ul><ol start="2"><li>晶振引脚</li></ol><ul><li>3456号引脚口，时钟晶振引脚口，</li><li>PC14-OSC32_IN，PC15-OSC32_OUT，32.768kHz的晶振</li><li>OSC_IN ，OSC_OUT，8MHz的晶振。主晶振。</li></ul><ol start="3"><li>下载端口</li></ol><ul><li>PA13:JTMS&#x2F;SWDIO </li><li>PA14:JTCK&#x2F;SWCLK</li></ul><ol start="4"><li>串口</li></ol><ul><li>PA9,PA10：USART1_TX，USART1_RX</li><li>PA2,PA3：USART2_TX，USART2_RX</li></ul><ol start="5"><li>IIC</li></ol><ul><li>PB6,PB7：I2C1_SCL，I2C1_SDA</li><li>PB10,PB11：I2C2_SCL，I2C2_SDA</li></ul><ol start="6"><li>SPI</li></ol><ul><li>PA4，SPI1 NSS；PA5，SPI1 SCK，PA6，SPI1 MISO；PA7，SPI1 MOSI</li><li>PA12，SPI2 NSS；PA13，SPI2 SCK，PA14，SPI2 MISO；PA15，SPI2 MOSI</li></ul><h1 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h1><p>简单的说，面包板是一种电子实验用品，表面是打孔的塑料，底部有金属条，电子元器件按照一定规则插上即可使用无需焊接。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p47.png" alt="面包板"></p><p><a href="http://www.taichi-maker.com/homepage/reference-index/circuit-reference-index/breadboard/">面包板的讲解和使用方法</a></p><center class="half"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p1.jpg" width="325/"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p2.jpg" width="300/"></center><h1 id="STM32CubeMX配置"><a href="#STM32CubeMX配置" class="headerlink" title="STM32CubeMX配置"></a>STM32CubeMX配置</h1><p><a href="https://blog.csdn.net/weixin_48896613/article/details/127243070">不错的教程，点这里</a></p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol><li>打开STM32CubeMX，单击ACCESS TO MCU SELECTOR</li><li>选择STM32F103C8T6芯片,创建project</li><li>进入配置界面后单击System Core（系统的核心） → SYS → Debug → Serial Wire</li><li>单击System Core（系统的核心） → RCC（配置晶振） → High speed Clock(HSE)（高速晶振）→ Crystal&#x2F;Ceramic Resonator（外部晶振，8M）</li></ol><ul><li>如果这里选Disable则无法使用外部高速晶振，这时PD0与PD1被用来做晶振的接口，如果不配置则可以把PD0、PD1当做普通IO口使用（新手建议还是进行配置）</li></ul><ol start="5"><li>单击Clock Configuration在这里输入72，按下回车 → OK，自动配置时钟频率为72Mhz</li></ol><p><a href="https://zhuanlan.zhihu.com/p/555632154">配置STM32外部时钟源</a></p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p55.png" alt="配置外部时钟源"></p><h2 id="需求配置（GPIO），以点灯为例"><a href="#需求配置（GPIO），以点灯为例" class="headerlink" title="需求配置（GPIO），以点灯为例"></a>需求配置（GPIO），以点灯为例</h2><ol start="6"><li>依次单击Pinout &amp; Configuration → System Core → <code>GPIO</code> →右边的PC13（点灯） → GPIO_Output</li></ol><ul><li>根据电路图，PC13应为输出<code>高电平</code>，即3.3V时，LED灯<code>熄灭</code>，0V<code>低电平</code>时LED灯<code>亮</code>，交替输出可以实现闪烁的效果。</li><li>GPIO_Input，为输入模式，可读取当前引脚的电平状态，该电平一般是由外部驱动的。<br>GPIO_Output为输出模式，意味着可控制当前引脚的电平状态。</li></ul><ol start="7"><li>继续配置PC13</li></ol><ul><li>设置GPIO output level：初始化电平，根据LED灯电路图，初始化输出低电平，灯亮。</li><li>设置GPIO mode 为：Output Push Pull(推挽输出)</li><li>设置 “既不上拉也不下拉”</li><li>输出最大速度默认为LOW</li><li>使用user label对该引脚进行别名，方便编程时区分和引用</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p2.png" alt="PC13配置"></p><h2 id="项目和代码生成"><a href="#项目和代码生成" class="headerlink" title="项目和代码生成"></a>项目和代码生成</h2><p>单击Project Manager → Project ，配置准备要生成的工程</p><ul><li>工程名不能为中文，开头不能用数字</li><li>工程路径也不能包含中文</li><li>程序结构选basic即可，Advanced为高级的，工程会很大</li><li>IDE选择MDK-ARM</li><li>设置Code Generator</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p3.png" alt="设置Code Generator"></p><p>上述的配置都设置好后就可以单击右上角的GENERATE CODE生成工程了。</p><ul><li>可直接Open Project，cubeMX会打开keil。</li></ul><h3 id="如果使用Stm32CubeIDE"><a href="#如果使用Stm32CubeIDE" class="headerlink" title="如果使用Stm32CubeIDE"></a>如果使用Stm32CubeIDE</h3><p>更简单了，设置好芯片之后，<code>Ctrl+S</code>保存配置，IDE会自动生成初始代码，并跳转到main.c页面。编写好代码之后，点击顶栏的<code>小锤子</code>进行编译。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p49.png" alt="CubeIDE的代码页面"></p><h4 id="可能遇到的一些问题："><a href="#可能遇到的一些问题：" class="headerlink" title="可能遇到的一些问题："></a>可能遇到的一些问题：</h4><ol><li><a href="https://blog.csdn.net/u014798590/article/details/126655017">STM32CubeIDE更新STLINK驱动失败</a></li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p50.png" alt="使用STM32 ST-LINK utility进行驱动更新"></p><ol start="2"><li><a href="https://blog.csdn.net/weixin_46695934/article/details/108474195">Please choose another workspace as ‘E:&#x2F;eclipse-workspace‘ is currently in use.</a></li></ol><ul><li>删掉该workspace目录下隐藏文件.metadata中的.lock文件</li></ul><h4 id="如何批量注释代码"><a href="#如何批量注释代码" class="headerlink" title="如何批量注释代码"></a>如何批量注释代码</h4><p>加入&#x2F;&#x2F;的方法，整行或者多行选中，按键<code>Ctrl + 按键/</code></p><h1 id="点灯——基础版"><a href="#点灯——基础版" class="headerlink" title="点灯——基础版"></a>点灯——基础版</h1><p><a href="https://blog.csdn.net/yangshengwei230612/article/details/104419697">参考教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/516662177#:~:text=%E6%9C%AC%E6%96%87%E4%B8%AD%E7%9A%84%E7%82%B9%E7%81%AF%EF%BC%8C%E6%98%AF%E6%8C%87%E7%94%A8STM32%E5%8D%95%E7%89%87%E6%9C%BA%E7%82%B9%E4%BA%AE%E4%B8%8E%E4%B9%8B%E8%BF%9E%E6%8E%A5%E7%9A%84LED%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82%20%E9%A6%96%E5%85%88%E6%88%91%E4%BB%AC%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BLED%E8%BF%99%E7%A7%8D%E5%99%A8%E4%BB%B6%EF%BC%8C%E5%AE%9E%E7%89%A9%E5%9B%BE%E5%A6%82%E4%B8%8B%E3%80%82,LED%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8F%91%E5%85%89%E4%BA%8C%E6%9E%81%E7%AE%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E7%82%B9%E7%81%AF%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B0%B1%E6%98%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8STM32%E6%8E%A7%E5%88%B6%E4%B8%80%E4%B8%AA%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%94%B5%E8%B7%AF%E3%80%82%20%E5%B8%82%E5%9C%BA%E4%B8%8A%E5%90%84%E7%B1%BBLED%EF%BC%88%E7%9B%B4%E6%8F%92%E5%BC%8F%2F%E8%B4%B4%E7%89%87%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E9%A2%9C%E8%89%B2%E7%9A%84LED%EF%BC%8C%E9%83%BD%E6%9C%89%E7%82%B9%E5%8C%BA%E5%88%AB%EF%BC%89%E5%9C%A8%E5%AF%BC%E9%80%9A%E6%97%B6%E7%9A%84%E5%8E%8B%E9%99%8D%E4%B8%80%E8%88%AC%E5%9C%A81.8~3.3V%E3%80%82">点灯的原理</a></p><p>由该最小系统板的原理图可知，PC13自带可编程普通LED灯,板载LED灯的电路：</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p1.png" alt="板载LED灯"></p><h2 id="Keli5编写代码"><a href="#Keli5编写代码" class="headerlink" title="Keli5编写代码"></a>Keli5编写代码</h2><p>打开工程后，进入Keli5软件，依次打开工程结构树，双击main.c开始写源码</p><ul><li>切忌：一定要在<code>BEGIN END</code>里写代码，不然后面STM32CubeMX重新配置生成代码, 会删除BEGIN END外面的代码</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p4.png" alt="keil5界面"></p><ul><li><p>找到Drivers文件夹里的stm32f1xx_hal_gpio.c（双击打开），找到第465行的HAL_GPIO_WritrPin函数，复制其函数名，并在main方法里的wihile(1)调用</p><ul><li>注意使用了别名LED0后，可直接在里面传入参数<code>LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET</code><ul><li>参数1：GPIO端口；<br>  参数2：GPIO引脚；<br>  参数3：输出电平，使LED灯亮，输出低电平</li><li>GPIO_PIN_RESET :   代表低电平</li><li>GPIO_PIN_SET :   代表高电平</li></ul></li></ul></li><li><p>左上角编译，0错误，0警告</p></li></ul><h2 id="CubeIDE-编写代码"><a href="#CubeIDE-编写代码" class="headerlink" title="CubeIDE 编写代码"></a>CubeIDE 编写代码</h2><p>使用<code>Alt+/</code>可以打开代码提示，方便查找需要的函数。</p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul><li><p>void <code>HAL_GPIO_TogglePin</code>(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)：<br>这个函数用于<code>反转（切换）指定的GPIO引脚的输出状态</code>。它的参数包括：</p><ul><li>GPIOx：GPIO端口的基址，指明要操作的GPIO端口（如GPIOA、GPIOB等）。</li><li>GPIO_Pin：指定要反转状态的GPIO引脚（可以是一个或多个引脚的位域）。<ul><li>例如，如果之前引脚是高电平，调用这个函数后引脚将变为低电平，反之亦然。</li></ul></li><li>由于系统运行太快，想看到LED灯闪烁，要加上延时函数：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> `HAL_Delay`(<span class="hljs-built_in">uint32</span>_t Delay)<br></code></pre></td></tr></table></figure>  此函数为<code>毫秒级延时</code>。如果想要指定间隔时间控制LED灯的亮灭，也是使用这个延时函数。</li></ul></li><li><p>void <code>HAL_GPIO_WritePin</code>(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)：<br>这个函数用于<code>设置指定GPIO引脚的输出状态</code>。它的参数包括：</p><ul><li>GPIOx：GPIO端口的基址，指明要操作的GPIO端口（如GPIOA、GPIOB等）。</li><li>GPIO_Pin：指定要设置状态的GPIO引脚（可以是一个或多个引脚的位域）。<br>   -PinState：指定要设置的状态，可以是 GPIO_PIN_SET（设置为高电平）或 GPIO_PIN_RESET（设置为低电平）。</li></ul></li><li><p>一种走马灯的思路设计：<br>(设置状态机，通过不同状态if的设置达到多个小灯交替变换的效果，一个周期结束之后，状态清零，继续while循环)</p></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p5.png" alt="走马灯"></p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p.png" alt="build成功"></p><h2 id="程序烧录"><a href="#程序烧录" class="headerlink" title="程序烧录"></a>程序烧录</h2><p>（之前用的keli5，后面换平台了）<br>这里记录的是使用CubeIDE平台，通过stlink进行程序烧录。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p51.png" alt="程序烧录成功"></p><h1 id="点灯——按键控制"><a href="#点灯——按键控制" class="headerlink" title="点灯——按键控制"></a>点灯——按键控制</h1><p>此项目是为了学习GPIO的输入： <code>GPIO_Input</code></p><h2 id="关于按键——通过轮询方式读取GPIO状态"><a href="#关于按键——通过轮询方式读取GPIO状态" class="headerlink" title="关于按键——通过轮询方式读取GPIO状态"></a>关于按键——通过轮询方式读取GPIO状态</h2><ol><li>关于<code>按键消抖</code>：</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p6.png" alt="并联电容实现按键消抖"></p><ul><li>上述是属于<code>硬件消抖</code>，但是为了以防万一，一般还会进行<code>软件消抖</code>——进行Delay，一般为10ms。</li></ul><ol start="2"><li>关于<code>上拉</code>：使用电源使GPIO口处的电平拉高。</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p8.png" alt="上拉操作"></p><center class="half"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p7.png" width="330/"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p9.png" width="300/"></center><ul><li>对于上拉电路：<ul><li>按键摁下——低电平</li><li>按键松开——高电平</li></ul></li></ul><ol start="3"><li>关于<code>下拉</code>:使用电源使GPIO口处的电平拉低。</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p10.png" alt="上拉电路和下拉电路"></p><ul><li>对于下拉电路：<ul><li>按键摁下——高电平</li><li>按键松开——低电平</li></ul></li></ul><ol start="4"><li>stm32内置了上拉和下拉电阻：<br>默认为<code>no-pull-up and no-pull-down</code> :浮空输入模式</li></ol><ul><li>上拉输入模式：Pull-up</li><li>下拉输入模式：Pull-down</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p11.png" alt="stm32内置GPIO上拉输入和下拉输入"></p><h2 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h2><ol><li><code>GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</code></li></ol><ul><li>参数：<ul><li>GPIOx：GPIO 控制器的基址，例如 GPIOA、GPIOB 等。</li><li>GPIO_Pin：要读取状态的 GPIO 引脚，可以使用宏定义，如 GPIO_PIN_0、GPIO_PIN_1 等。</li></ul></li><li>返回值：<br>返回值类型为 GPIO_PinState，该类型是一个枚举类型，有两个可能的值：<ul><li>GPIO_PIN_RESET：引脚处于低电平状态。</li><li>GPIO_PIN_SET：引脚处于高电平状态。</li></ul></li></ul><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">GPIO_PinState pinState;<br>pinState = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);<br><span class="hljs-keyword">if</span>(pinState == GPIO_PIN_SET) &#123;<br>    <span class="hljs-regexp">//</span> 如果引脚处于高电平状态，则执行相应操作<br>    <span class="hljs-regexp">//</span>例如：熄灭小灯<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> 如果引脚处于低电平状态，则执行相应操作<br>    <span class="hljs-regexp">//</span>例如：点亮小灯<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>按键反转小灯亮灭：</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p12.png" alt="stm32内置GPIO上拉输入和下拉输入"></p><p>需要添加按键摁下时等待，否则小灯会一直在while循环中从低电平被拉到高电平，然后又由于按键下拉成为低电平。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p13.png" alt="stm32内置GPIO上拉输入和下拉输入"></p><h2 id="使用矩阵式键盘模块"><a href="#使用矩阵式键盘模块" class="headerlink" title="使用矩阵式键盘模块"></a>使用矩阵式键盘模块</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p52.png" alt="博主使用的矩阵式键盘模块实物图"></p><p>矩阵按键扫描原理：</p><ul><li>先是把列(<code>col</code>)置0（推挽输出），行是输入上拉，扫描行得到行的键值；</li><li>再是把行(<code>row</code>)置0（推完输出），列是输入上拉，扫描列得到列的键值；</li><li>最后把行列的键值相加得到最后的总的键值。</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p53.png" alt="矩阵式键盘模块原理图"></p><h3 id="关于GPIO配置"><a href="#关于GPIO配置" class="headerlink" title="关于GPIO配置"></a>关于GPIO配置</h3><p>4个引脚配推挽输出，这4个配输出的引脚内部上下拉不用配置；另外4个配成输入，内部上拉。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p54.png" alt="矩阵式键盘模块GPIO配置"></p><p>在key.h里面对硬件的引脚进行define，方便后面代码的书写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx_hal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gpio.h&quot;</span>   <span class="hljs-comment">//这里如果不引入gpio.h，会出现报错显示引脚标签为没有定义的变量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span>     _KEY_BOARD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>     _KEY_BOARD_H_</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PORT          GPIOD</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK_FUN       RCC_APB2PeriphClockCmd</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_CLK           RCC_APB2Periph_GPIOD</span><br><br><br><span class="hljs-comment">//line    行</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN0           KEY_col0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN1           KEY_col1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN2           KEY_col2_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN3           KEY_col3_Pin</span><br><br><br><br><span class="hljs-comment">//row      列</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN4           KEY_row0_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN5           KEY_row1_Pin</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>   KEYBOARD_GPIO_PIN6           KEY_row2_Pin</span><br><br><br><span class="hljs-comment">//extern uint8_t Send_F;</span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">Keyboard_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title">keyboard_scan</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>具体的函数实现在key.c文件中，具体的调用方法参见库函数整理的那一篇博客。</p><h1 id="关于GPIO的内部电路原理"><a href="#关于GPIO的内部电路原理" class="headerlink" title="关于GPIO的内部电路原理"></a>关于GPIO的内部电路原理</h1><h2 id="GPIO功能描述"><a href="#GPIO功能描述" class="headerlink" title="GPIO功能描述"></a>GPIO功能描述</h2><p>每个GPI&#x2F;O端口有:<br>两个32位<code>配置寄存器</code>(GPIOx_CRL，GPIOx_CRH)，两个32位<code>数据寄存器</code>(GPIOx_IDR和GPIOx_ODR)，一个<code>32位置位/复位寄存器</code>(GPIOx_BSRR)，一个<code>16位复位寄存器</code>(GPIOx_BRR)和一个<code>32位锁定寄存器</code>(GPIOx_LCKR)。<br>根据数据手册中列出的每个I&#x2F;O端口的特定硬件特征， GPIO端口的每个位可以由软件分别配置成多种模式。</p><ul><li>输入浮空</li><li>输入上拉</li><li>输入下拉</li><li>模拟输入</li><li>开漏输出</li><li>推挽式输出</li><li>推挽式复用功能</li><li>开漏复用功能</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p57.png" alt="GPIO口读取高低电平原理"></p><ul><li>模拟输入，读取的是具体数值，没有经过施密特触发器处理。</li><li>数字输入和复用输入都是读取的高低电平（经过施密特触发器过滤处理）</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p14.png" alt="I/O端口位的基本结构"></p><p>1.输出驱动器： <br>主要配置<code>开漏输出</code>和<code>推挽输出</code>。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p18.png" alt="开漏输出和推挽输出区别"></p><ul><li>推挽输出：<br>该模式需要P-MOS和N-MOS协同作用。</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p15.png" alt="推挽输出-输出高电平"></p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p16.png" alt="推挽输出-输出低电平"></p><ul><li>开漏输出：<br>当外设元器件需要的电压不是3.3V时，可以使用开漏输出，此时只有N-MOS工作，外接GND变为器件需要的工作电压VCC。<ul><li>开漏输出必须依靠外接的电压源来进行驱动，当外接电压大于3.3V时，需要选择<code>5V容忍</code>的I&#x2F;O口。</li><li>当要求I&#x2F;O口输出低电平时，N-MOS断开，反之则N-MOS连接GND为0V。</li></ul></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p17.png" alt="开漏输出"></p><ul><li>由于输出驱动器的控制指令来源有2个：<ul><li>一个是写入(HAL_GPIO_WritePin函数)控制的输出寄存器</li><li>另一个是片上外设，例如串口模块，I^2C模块的复用功能输入</li></ul></li></ul><p>因此，根据控制来源的不同，stm32将输出模块分为：</p><ul><li>开漏输出</li><li>推挽式输出</li><li>推挽式复用功能</li><li>开漏复用功能</li></ul><ol><li>输入驱动器：<br>根据是否开启上拉&#x2F;下拉电阻可以选择以下三种模式。</li></ol><ul><li>输入浮空</li><li>输入上拉</li><li>输入下拉</li></ul><p>TTL肖特基触发器的功能：稳定电平</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p19.png" alt="TTL肖特基触发器"></p><p>经过肖特基触发器处理之后的电平数据存储在输入数据寄存器中，等待使用HAL_GPIO_ReadPin函数对寄存器进行读取。</p><ul><li><p>模拟输入模式可以读取输入电压的具体数值，即不经过肖特基触发器处理的原始电压数据。</p></li><li><p>输入部分的不同分支可以同时读取施密特触发器的输出：</p></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p20.png" alt="输入部分"></p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断的概念：</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p21.png" alt="输入部分"></p><p>常见的中断事件有：</p><ul><li>指令出错</li><li>定时器结束</li><li>串口接收数据</li><li>GPIO电平发生变化(外部中断EXTI)</li></ul><h2 id="外部中断：红灯循环闪烁，按键中断，绿灯闪烁"><a href="#外部中断：红灯循环闪烁，按键中断，绿灯闪烁" class="headerlink" title="外部中断：红灯循环闪烁，按键中断，绿灯闪烁"></a>外部中断：红灯循环闪烁，按键中断，绿灯闪烁</h2><p> 不使用中断，会存在的情况：</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p22.png" alt="逻辑错误"></p><h3 id="设置中断："><a href="#设置中断：" class="headerlink" title="设置中断："></a>设置中断：</h3><p>   将接收电平输入的引脚设置为：<code>GPIO_EXTIXX</code>，XX为引脚号，表示第XX号外部中断线。</p><ul><li>设置GPIO mode：<ul><li>上升沿触发中断：某个GPIO口读取的电平由低电平变为高电平，触发中断</li><li>下降沿触发中断：某个GPIO口读取的电平由高电平变为低电平，触发中断</li><li>上升、下降沿都触发中断</li></ul></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p23.png" alt="GPIO mode"></p><ul><li>设置NVIC(中断控制器)：勾选开启<code>中断向量EXTI15_10</code></li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>在Core&#x2F;Src中可以找到stm32f1xx_it.c，其后缀it就表示它是与中断(interrupt)相关的文件。</p><p>此文件的最底部有CubeMX自动生成的函数:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EXTI15_10_IRQHandler</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>&#123;<br>    HAL_GPIO_EXTI_IRQHandler(KET1_PIN);   <span class="hljs-meta"># KET1_PIN为引脚的用户标签</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数为我们摁下按键触发中断后，stm32会调用执行的中断处理函数。</p><h4 id="外部中断的软件消抖-按键"><a href="#外部中断的软件消抖-按键" class="headerlink" title="外部中断的软件消抖(按键)"></a>外部中断的软件消抖(按键)</h4><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p24.png" alt="软件消抖"></p><ul><li><p>在中断处理函数中，先等10ms，用于软件消抖，等按键稳定之后，再读取按键状态判断是否为有效的中断触发。</p><ul><li>若为误触，则中断处理函数不做任何操作，直接回到主程序</li></ul></li><li><p>注意：如果要在回调函数中使用<code>HAL_Delay()</code>，就必须配置<code>中断优先级</code>:</p></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p25.png" alt="中断优先级配置"></p><ul><li>System Core -&gt; NVIC，将 Time base: System tick timer 的主要优先级调到比EXTI line[15:10] Interrupts 高即可。<ul><li>HAL_Delay()函数依靠<code>System tick timer</code>的中断提供1ms的时钟基准。该中断的优先级如果低于我们触发的中断，使 HAL_Delay() 函数无法在中断函数中正常执行，会导致程序卡死在这里。</li></ul></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在正规的项目中，在中断中调用HAL_Delay()函数是不被推荐的，需要尽可能的保证中断任务可以尽快执行完成，将中断对正常执行流程的影响降到最低。</p><h2 id="深入外部中断"><a href="#深入外部中断" class="headerlink" title="深入外部中断"></a>深入外部中断</h2><h3 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p26.png" alt="外部中断/事件控制器框图"></p><p>在stm32f1系列芯片中一共有19个这样的外部中断&#x2F;事件控制器，它们共用一套寄存器，但连线是独立的，称为<code>外部中断线</code>。</p><ul><li>前16条外部中断线，即EXTI0~EXTI15分别对应其同号的GPIO口。<ul><li>从PA0，PB0，PC0，PD0进入的电平信号都可以进入EXTI0。</li></ul></li></ul><ol><li>事件信号：<br>事件是和中断类似的概念，但是事件信号直接送达相应的外设，由外设自行处理，不会中断正常代码执行流程。</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p27.png" alt="事件信号处理部分"></p><ol start="2"><li>软件中断事件寄存器可以用代码模拟产生一个中断。</li><li>边沿检测电路就是用来检测电平变化的，经过一个或门，传输中断数据到<code>请求挂起寄存器</code>，其输出的信号和<code>中断屏蔽寄存器</code>的信号通过一个与门, 进入NVIC中断控制器。</li></ol><h3 id="NVIC-嵌套向量中断控制器"><a href="#NVIC-嵌套向量中断控制器" class="headerlink" title="NVIC 嵌套向量中断控制器"></a>NVIC 嵌套向量中断控制器</h3><ol><li>关于中断向量：</li></ol><ul><li>EXTI0~EXTI4 ： 拥有自己的中断向量</li><li>EXTI5~EXTI9： 共享中断向量 EXTI9_5</li><li>EXTI10~EXTI15: 共享中断向量EXTI15_10</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p28.png" alt="中断向量"></p><ol start="2"><li>NVIC会一直读取中断信号线是否存在中断请求。为了让中断处理函数只执行一遍而不是无限重复，需要在中断处理函数中，将请求挂起寄存器的对应位清零。<ul><li>CubeMX生成的代码中，中断处理函数里面自动调用了该清零的函数_HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN)。<br> 所以不需要额外写。</li></ul></li><li>优先级</li></ol><ul><li>两中断同时发生时，先比较<code>抢占优先级</code>；若抢占优先级相同，再比较<code>响应优先级</code>。</li><li>某中断正在进行中，另一中断突然发生，只比较二者抢占优先级。</li></ul><center class="half"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p29.png" width="250/"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p30.png" width="280/"></center><p>CubeMX用四个二进制位表示优先级，默认4位均为抢占优先级。</p><h2 id="一些其他的中断"><a href="#一些其他的中断" class="headerlink" title="一些其他的中断"></a>一些其他的中断</h2><ul><li>串口USART：<ul><li>空暇中断</li><li>接收中断</li><li>发送完成中断</li><li>奇偶校验中断</li><li>…</li></ul></li><li>定时器TIM：<ul><li>刹车中断</li><li>触发和通信中断</li><li>捕获比较中断</li><li>…</li></ul></li><li>I^2C:<ul><li>传输完成终端</li><li>地址发送终端</li><li>起始位发送中断</li><li>接收缓存区非空中断</li><li>…</li></ul></li></ul><p>这些中断虽然没有外部中断线这套结构，但是也有相关的请求挂起寄存器和中断屏蔽寄存器，触发中断后依旧需要NVIC通过中断向量找到并执行中断处理函数。</p><h1 id="串口通信——TTL串口"><a href="#串口通信——TTL串口" class="headerlink" title="串口通信——TTL串口"></a>串口通信——TTL串口</h1><p>常见的串口：</p><ul><li>RS-232、RS-485</li><li>RJ-45 ：网线接口</li><li>USB串口</li></ul><p>这里介绍的是单片机中最常见的串口：TTL串口</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p31.png" alt="串口接线图"></p><ul><li>共地是两设备通信的前提</li><li>TTL串口为异步通信</li><li>波特率：每秒传送的码元数量，即每秒多少次高低电平信号。<ul><li>TTL串口每传递一个字节(Byte)，也就是<code>8 bit</code>数据，加上一位<code>起始位</code>和一位<code>停止位</code>,每传递一字节的信息需要10 bit</li><li>常见的波特率：<ul><li>115200</li><li>9600</li><li>19200</li><li>38400</li></ul></li><li>通信的两个设备需要使用相同的波特率才能正常通信。</li></ul></li><li>除了波特率，另外需要在CubeMX中设置的<code>Word Length</code>(字节长度),<code>Parity</code>(校验位)，<code>Stop Bits</code>(停止位)保持默认即可。</li></ul><h2 id="初识串口——项目实战"><a href="#初识串口——项目实战" class="headerlink" title="初识串口——项目实战"></a>初识串口——项目实战</h2><p>串口通信方式：</p><ul><li>轮询方式：CPU不断检测串口的状态标志来判断数据收发的情况。<ul><li>特点：程序设计简单，但CPU在检测标志位期间，无法执行其他任务，CPU利用率较低。</li></ul></li><li>中断方式：使能中断后，接收一字节数据或发送一字节后申请中断，在ISR中完成后续处理。<ul><li>在数据收发期间，CPU可以执行其他任务，CPU利用率较高。</li></ul></li><li>DMA方式：初始化时设置相关参数，启动DMA传输后，数据传输过程不需要CPU的干预。<ul><li>传输完成后，再产生DMA中断，由CPU进行后续处理，传输效率最高。</li></ul></li></ul><h3 id="轮询模式的底层机制"><a href="#轮询模式的底层机制" class="headerlink" title="轮询模式的底层机制"></a>轮询模式的底层机制</h3><p>在stm32的每个串口内部都有两个发送数据寄存器：<code>发送数据寄存器(TDR)</code>,<code>发送移位寄存器</code>，两个接收数据的寄存器：<code>接收数据寄存器(RDR)</code>,<code>接收移位寄存器</code>。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p35.png" alt="两个发送数据寄存器的作用"></p><p>CPU不停的轮询发送数据寄存器中的数据是否已经移送到发送移位寄存器。</p><p>同理，CPU不停的轮询接收数据寄存器中是否有新数据可以读，直到接收完设置的希望接收的字节数或者时间超时。</p><ul><li>在轮询模式下，不管是发送还是接收，CPU一直处于忙碌状态。容易产生长期串口占用CPU导致堵塞的问题。</li></ul><h3 id="CubeMX设置"><a href="#CubeMX设置" class="headerlink" title="CubeMX设置"></a>CubeMX设置</h3><p>stm32F103C8T6的芯片中，调试串口的I&#x2F;O口为PA2和PA3。<br>设置USART2为异步模式，设置波特率为115200,保存设置并生成代码。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p32.png" alt="CubeMX设置串口"></p><h3 id="代码编写-1"><a href="#代码编写-1" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="函数介绍：串口轮询模式"><a href="#函数介绍：串口轮询模式" class="headerlink" title="函数介绍：串口轮询模式"></a>函数介绍：串口轮询模式</h4><ol><li><p>MX_USART2_UART_Init()：初始化USART2串口。<br>这个函数通常在微控制器固件的初始化阶段被调用，用于根据在 STM32CubeMX 中配置的参数（如波特率、数据位、停止位和校验位）设置和配置 USART2 外设（在本例中为 UART2）。</p></li><li><p>发送数据 :</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Transmit(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size, <span class="hljs-params">uint32_t</span> Timeout)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>参数：<ul><li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li><li>pData：指向要发送的数据缓冲区的指针。</li><li>Size：要发送的数据字节数。</li><li>Timeout：发送操作的超时时间（以毫秒为单位）。如果在超时时间内未完成发送操作，则函数可能会返回超时错误。<ul><li><code>HAL_MAX_DELAY</code> :表示不设超时时间，可以无限等待到发送完成。</li></ul></li></ul></li><li>返回值：<ul><li>HAL_OK：操作成功完成。</li><li>其他错误代码，例如超时错误或者传输中断。</li></ul></li><li>功能：<ul><li>当调用 HAL_UART_Transmit() 函数时，它会尝试将指定数量的数据字节发送到 UART 外设。</li><li>如果 UART 外设正在发送其他数据或者处于忙状态，该函数将等待直到 UART 外设空闲，然后再发送数据。</li><li>如果发送过程中发生错误（例如超时或者传输中断），函数将返回相应的错误代码。</li></ul></li></ul><h4 id="实战项目：串口控制LED灯的亮灭"><a href="#实战项目：串口控制LED灯的亮灭" class="headerlink" title="实战项目：串口控制LED灯的亮灭"></a>实战项目：串口控制LED灯的亮灭</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> main(void)<br>    &#123;<br>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span><br>  <span class="hljs-constructor">HAL_Init()</span>;<br>  <span class="hljs-constructor">SystemClock_Config()</span>;<br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  <span class="hljs-constructor">MX_GPIO_Init()</span>;<br>  <span class="hljs-constructor">MX_USART2_UART_Init()</span>;<br><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br><span class="hljs-built_in">char</span> message_1<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Normal situation : The LED is extincting ...&quot;</span>;<br><span class="hljs-built_in">char</span> message_2<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;The LED is lit up !!!&quot;</span>;<br>uint8_t receiveData<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br><span class="hljs-constructor">HAL_UART_Receive(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,1,100)</span>;<br><span class="hljs-comment">//Normal situation--Flashing light</span><br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>  <span class="hljs-constructor">HAL_Delay(1000)</span>;<br><span class="hljs-keyword">if</span>(receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>==<span class="hljs-character">&#x27;0&#x27;</span>)&#123;<br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br><span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_2,strlen(message_2),<span class="hljs-number">100</span>);<br><span class="hljs-constructor">HAL_Delay(5000)</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-constructor">HAL_UART_Transmit(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_1,strlen(message_1),<span class="hljs-number">100</span>);<br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_SET)</span>;<br><span class="hljs-constructor">HAL_Delay(1000)</span>;<br>&#125;<br>receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* USER CODE END WHILE */</span><br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure><center class="half"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p33.png" width="420/"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p34.png" width="420/"></center><h2 id="串口的中断模式"><a href="#串口的中断模式" class="headerlink" title="串口的中断模式"></a>串口的中断模式</h2><p>采用中断模式，当CPU把发送的内容塞入发送数据寄存器之后，就去处理其他代码，<code>当发送数据寄存器为空之后，触发中断，CPU再继续塞数据</code>…由此可以解决串口占用CPU导致的阻塞问题。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p36.png" alt="串口的中断模式"></p><h3 id="CubeMX设置-1"><a href="#CubeMX设置-1" class="headerlink" title="CubeMX设置"></a>CubeMX设置</h3><p>在NVIC中勾选上UART2即可。</p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p37.png" alt="串口中断模式设置"></p><h3 id="函数介绍-2"><a href="#函数介绍-2" class="headerlink" title="函数介绍"></a>函数介绍</h3><ol><li>发送数据：<code>HAL_UART_Transmit_IT()</code><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Transmit_IT(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>参数：<ul><li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li><li>pData：指向要发送的数据缓冲区的指针。</li><li>Size：要发送的数据字节数。</li><li>因为是中断模式，不会长期占用CPU，所以无需设置等待时间</li></ul></li><li>功能：<ul><li>当调用 HAL_UART_Transmit_IT() 函数时，它会将指定数量的数据字节放入发送缓冲区，并启动发送过程。</li><li>函数将立即返回，不会等待数据发送完成。数据将在后台通过中断的方式进行发送。</li><li>一旦发送完成，将触发相应的 UART 发送完成中断，可以在中断处理函数中进行进一步的处理。</li></ul></li></ul><ol start="2"><li>接收数据：<code>HAL_UART_Receive_IT()</code><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UART_Receive_IT(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>参数：<ul><li>huart：指向 UART 外设的句柄的指针，包含了 UART 的配置和状态信息。</li><li>pData：指向接收数据的缓冲区的指针。</li><li>Size：要接收的数据字节数。</li></ul></li><li>功能：<ul><li>当调用 HAL_UART_Receive_IT() 函数时，它会启动接收过程，并将接收到的数据存储到指定的缓冲区中。</li><li>函数将立即返回，不会等待数据接收完成。数据将在后台通过中断的方式进行接收。<ul><li>因此不能把这个函数放到while循环中，否则会出现新一轮循环调用它时，上一次的接收还未结束</li><li>需要设置回调函数，并且记得在HAL_UART_RxCpltCallback()中开启下一次串口的接收</li></ul></li><li>一旦接收到指定数量的数据字节或者接收超时，将触发相应的 UART 接收<code>完成中断</code>(接收数据寄存器非空中断)，可以在中断处理函数中获取接收到的数据。</li></ul></li></ul><ol start="3"><li>回调函数</li></ol><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p38.png" alt="USART中断请求"></p><p>一个USART只有一个中断向量，使用回调函数，可以更好的处理各种中断事件。</p><ul><li><code>HAL_UART_RxCpltCallback()</code>函数<br>当串口接收到指定数量的数据字节后，将触发接收完成中断。此时，HAL 库将自动调用 HAL_UART_RxCpltCallback() 函数（如果已经在代码中定义了该函数），并将 UART 句柄作为参数传递给它。<br>此类函数虽然定义在stm32的库函数中，但是都是<code>_weak</code>定义，可以在其他地方重新定义此函数，然后在中间加入处理部分的代码。<ul><li>一般单开一个文件对这类函数重新定义的。<br>通常情况下，可以在 HAL_UART_RxCpltCallback() 函数中进行以下操作：</li><li>处理接收到的数据，例如解析数据包、执行相应的操作或者存储数据到缓冲区中。</li><li>启动下一次接收过程，以便继续接收数据。</li></ul></li></ul><p>示例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">HAL_UART_RxCpltCallback</span>(UART_HandleTypeDef *huart) &#123;<br>    if (huart == &amp;huart2) &#123;<br>        <span class="hljs-comment">// 在这里处理接收到的数据，例如打印到终端或者执行特定的操作</span><br>        <span class="hljs-comment">// 以下示例假设接收到的数据存储在 rxBuffer 中，并且数据长度为 RX_BUFFER_SIZE</span><br>        <span class="hljs-built_in">printf</span>(&quot;Received data: %s\n&quot;, rxBuffer);<br><br>        <span class="hljs-comment">// 启动下一次接收过程</span><br>        <span class="hljs-built_in">HAL_UART_Receive_IT</span>(&amp;huart2, rxBuffer, RX_BUFFER_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>补充一个代码规范：用户自定义的全局变量，放在<code>USER CODE PV</code>注释块中</li></ol><h2 id="串口DMA模式和接收不定长数据"><a href="#串口DMA模式和接收不定长数据" class="headerlink" title="串口DMA模式和接收不定长数据"></a>串口DMA模式和接收不定长数据</h2><h3 id="DMA的概念"><a href="#DMA的概念" class="headerlink" title="DMA的概念"></a>DMA的概念</h3><p>DMA（Direct Memory Access，<code>直接内存访问</code>）是一种计算机系统中用于实现高效数据传输的技术。它允许外部设备（如网络适配器、硬盘控制器、串口等）直接访问系统内存，而无需 CPU 的干预。DMA 可以大大提高数据传输的效率，因为它可以在数据传输过程中释放 CPU，使 CPU 可以同时执行其他任务。</p><ul><li><p>数据传输效率：DMA 允许<code>数据在外设和内存之间直接传输</code>，无需 CPU 的介入。这消除了 CPU 在数据传输期间的等待时间，从而提高了系统的总体效率。</p></li><li><p>减少 CPU 负载：由于 DMA 可以独立地管理数据传输，CPU 可以将更多的时间用于执行其他任务，从而减少了 CPU 的负载。这对于实时系统和多任务系统尤其有用。</p></li><li><p><code>多通道</code>支持：许多 DMA 控制器支持多个 DMA 通道，每个通道可以独立地管理一个数据传输任务。这允许系统<code>同时执行多个数据传输</code>，提高了系统的并发性。</p></li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p39.png" alt="形象理解DMA"></p><ul><li><p>工作原理：在 DMA 操作中，<code>CPU 配置 DMA 控制器来指定数据传输的源地址、目的地址和数据长度等参数</code>。一旦 DMA 控制器被配置好，它可以独立地控制数据传输，直到传输完成或者遇到错误。一旦数据传输完成，DMA 控制器触发一个<code>DMA传输完成中断</code>或者通知 CPU。</p></li><li><p>适用场景：DMA 主要用于大量数据的传输，例如大文件的读写、图像传输、音频处理等场景。</p></li></ul><table><thead><tr><th>中断模式</th><th>发送数据寄存器空终端、接收数据寄存器非空中断</th><th>每收&#x2F;发一个字节时</th></tr></thead><tbody><tr><td>DMA模式</td><td>DMA传输完成中断</td><td>收&#x2F;发完成时</td></tr></tbody></table><h4 id="四种情况的数据传输如下："><a href="#四种情况的数据传输如下：" class="headerlink" title="四种情况的数据传输如下："></a>四种情况的数据传输如下：</h4><p>Dirction ： DMA传输方向<br>(1)外设到内存 Peripheral To Memory<br>(2)内存到外设 Memory To Peripheral<br>(3)内存到内存 Memory To Memory<br>(4)外设到外设 Peripheral To Peripheral</p><h4 id="DMA基础工作原理"><a href="#DMA基础工作原理" class="headerlink" title="DMA基础工作原理"></a>DMA基础工作原理</h4><p>当用户将参数设置好，主要涉及<code>源地址</code>、<code>目标地址</code>、<code>传输数据量</code>这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 达到传输终点，结束DMA传输。</p><ul><li>当然，DMA 还有循环传输模式 当到达传输终点时会重新启动DMA传输。<ul><li>也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。</li></ul><p>　</p></li><li>总之，每次DMA传送由3个操作组成：<ul><li>从外设数据寄存器或者从当前外设&#x2F;存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；</li><li>存数据到外设数据寄存器或者当前外设&#x2F;存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是DMA_CPARx或DMA_CMARx寄存器指定的外设基地址或存储器单元；</li><li>执行一次DMA_CNDTRx寄存器的递减操作，该寄存器包含未完成的操作数目</li></ul></li></ul><h4 id="DMA传输方式"><a href="#DMA传输方式" class="headerlink" title="DMA传输方式"></a>DMA传输方式</h4><ul><li>方法1：<code>DMA_Mode_Normal</code>，正常模式<br>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次</li><li>方法2：<code>DMA_Mode_Circular</code> ，循环传输模式<br>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式</li></ul><h3 id="CubeMX配置DMA"><a href="#CubeMX配置DMA" class="headerlink" title="CubeMX配置DMA"></a>CubeMX配置DMA</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p40.png" alt="CubeMX配置DMA"></p><p><a href="https://blog.csdn.net/as480133937/article/details/104827639">详细参考配置教程</a></p><ul><li>DMA Request ： DMA传输的对应外设<ul><li>注意： 如果你是在DMA设置界面添加DMA 而没有开启对应外设的话 ，默认为MENTOMEN</li></ul></li><li>Channel DMA传输通道设置:<br>DMA1 : DMA1 Channel 0 - DMA1 Channel 7<br>DMA2: DMA2 Channel 1 - DMA1 Channel 5</li><li>Priority： 传输速度<br>最高优先级 Very Hight<br>高优先级 Hight<br>中等优先级 Medium<br>低优先级；Low</li><li>DMA指针递增设置<br>Increment Address：地址指针递增。<br>(1)左侧Src Memory 表示外设地址寄存器<br>功能：设置传输数据的时候<code>外设地址</code>是不变还是递增。如果设置为递增，那么下一次传输的时候地址加 Data Width个字节。<br>(2)右侧Dst Memory 表示内存地址寄存器<br>功能：设置传输数据时候<code>内存地址</code>是否递增。如果设置为递增，那么下一次传输的时候地址加 Data Width个字节。</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p41.png" alt="DMA指针递增设置"></p><ul><li>串口发送数据是将数据不断存进固定外设地址串口的发送数据寄存器(USARTx_TDR)。所以外设的地址是不递增。</li><li>而内存储器存储的是要发送的数据，所以地址指针要递增，保证数据依次被发出</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p42.png" alt="DMA指针递增原理"></p><ul><li>串口数据发送寄存器只能存储8bit,每次发送一个字节，所以数据长度选择Byte</li></ul><h3 id="函数介绍-3"><a href="#函数介绍-3" class="headerlink" title="函数介绍"></a>函数介绍</h3><ul><li>HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)<br>串口DMA模式发送</li><li>HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)<br>串口DMA模式接收</li></ul><p>前两个函数的形参和串口中断模式一样。</p><ul><li><p>HAL_UART_DMAPause(&amp;huart1) <br>暂停串口DMA</p></li><li><p>HAL_UART_DMAResume(&amp;huart1)<br> 恢复串口DMA</p><ul><li>作用： 恢复DMA的传输</li><li>返回值： 0 正在恢复 1 完成DMA恢复</li></ul></li><li><p>HAL_UART_DMAStop(&amp;huart1)<br>结束串口DMA</p></li></ul><h3 id="STM32-IDLE-接收空闲中断-可接收不定长数据"><a href="#STM32-IDLE-接收空闲中断-可接收不定长数据" class="headerlink" title="STM32 IDLE 接收空闲中断(可接收不定长数据)"></a>STM32 IDLE 接收空闲中断(可接收不定长数据)</h3><p>如果勾选了<code>为每个外设生成单独的.c.h文件</code>，在按照视频关闭dma半传输中断时会报错，需要在代码的开头加上:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">extern DM<span class="hljs-built_in">A_HandleTypeDef</span> hdm<span class="hljs-built_in">a_usart2</span>_rx；<br></code></pre></td></tr></table></figure><p>我们可以认为空闲中断发生时，一帧数据包就接收完成了。</p><h4 id="函数介绍-4"><a href="#函数介绍-4" class="headerlink" title="函数介绍"></a>函数介绍</h4><ol><li>接收数据函数<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">HAL_StatusTypeDef <span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-operator">*</span><span class="hljs-params">pData</span>, <span class="hljs-params">uint16_t</span> Size)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>uint16_t Size为可接收的最大数据size，一般可以直接<code>sizeof(receiveData)</code></li></ul><ol start="2"><li>回调函数<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint16_t</span> Size)</span><br></code></pre></td></tr></table></figure></li></ol><ul><li>使用回调函数的一个好习惯：先确认是哪个串口触发了回调函数  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(huart == &amp;huart2)</span></span>&#123;<br>    \\确认是需要处理的目标串口之后再进行函数处理<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>接收数据储存在receiveData数组中，在回调函数中处理之后，需要清零数组内容，以便下一次接收数据。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">memset(<span class="hljs-name">receiveData</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-name">receiveData</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="项目实战："><a href="#项目实战：" class="headerlink" title="项目实战："></a>项目实战：</h4><p>需求：接收电脑端发送的三种类型的数据：1,非1的单个数据，长数据</p><ul><li>收到1，发送<code>The LED Is Lit Up!</code>，点亮小灯</li><li>收到非1的单个数据，发送<code>Get Wrong Messages ~ Why Not TRY again?</code></li><li>收到长数据，发送<code>Get Long Messages ~YOU SEND :这里拼接上电脑端发送的长数据</code></li><li>while主程序为闪烁小灯<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">uint8_t receiveData<span class="hljs-literal">[<span class="hljs-number">50</span>]</span>;<br>volatile uint8_t tx_complete = <span class="hljs-number">1</span>;<br>void <span class="hljs-constructor">HAL_UART_TxCpltCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (huart-&gt;Instance<span class="hljs-operator"> == </span>USART2) &#123;<br>        tx_complete = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//串口空闲中断的回调函数</span><br>void <span class="hljs-constructor">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef <span class="hljs-operator">*</span><span class="hljs-params">huart</span>, <span class="hljs-params">uint16_t</span> Size)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(huart<span class="hljs-operator"> == </span>&amp;huart2)&#123; <br>    <span class="hljs-comment">//先确认是哪个串口触发了回调函数</span><br><span class="hljs-keyword">if</span>(Size &gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//接收到长数据</span><br><span class="hljs-built_in">char</span> message_long<span class="hljs-literal">[<span class="hljs-number">100</span>]</span>=<span class="hljs-string">&quot;Get Long Messages ~YOU SEND :&quot;</span>;<br>strcat(message_long,receiveData);<br><span class="hljs-keyword">if</span> (tx_complete) &#123;<br>tx_complete = <span class="hljs-number">0</span>; <br><span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_long,strlen(message_long));<br>&#125;<br>memset(receiveData, <span class="hljs-number">0</span>, sizeof(receiveData));<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//接收到短数据</span><br><span class="hljs-built_in">char</span> message_1<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Get Wrong Messages ~ Why Not TRY again?&quot;</span>;<br><span class="hljs-built_in">char</span> message_2<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;The LED Is Lit Up!&quot;</span>;<br><span class="hljs-keyword">if</span> (tx_complete) &#123;<br>tx_complete = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>==<span class="hljs-character">&#x27;1&#x27;</span>)&#123;<br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br><span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_2,strlen(message_2));<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_1,strlen(message_1));<br>&#125;<br>receiveData<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">0</span>;<br>&#125;<br><br>        <span class="hljs-comment">//记得开启下一次的串口接收函数</span><br><span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,<span class="hljs-params">sizeof</span>(<span class="hljs-params">receiveData</span>)</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main(void)<br>&#123;<br>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br>  <span class="hljs-constructor">HAL_Init()</span>;<br>  <span class="hljs-comment">/* Configure the system clock */</span><br>  <span class="hljs-constructor">SystemClock_Config()</span>;<br><br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  <span class="hljs-constructor">MX_GPIO_Init()</span>;<br>  <span class="hljs-constructor">MX_DMA_Init()</span>;<br>  <span class="hljs-constructor">MX_USART2_UART_Init()</span>;<br><br><span class="hljs-constructor">HAL_UARTEx_ReceiveToIdle_DMA(&amp;<span class="hljs-params">huart2</span>,<span class="hljs-params">receiveData</span>,<span class="hljs-params">sizeof</span>(<span class="hljs-params">receiveData</span>)</span>);<br> <br> <br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br><span class="hljs-comment">//Normal situation--Flashing light</span><br><span class="hljs-built_in">char</span> message_3<span class="hljs-literal">[]</span>=<span class="hljs-string">&quot;Normal situation : The LED is extincting ...&quot;</span>;<br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET)</span>;<br>  <span class="hljs-constructor">HAL_Delay(200)</span>;<br><span class="hljs-constructor">HAL_GPIO_WritePin(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_SET)</span>;<br><span class="hljs-constructor">HAL_Delay(200)</span>;<br><span class="hljs-keyword">if</span> (tx_complete) &#123;<br>tx_complete = <span class="hljs-number">0</span>; <br><span class="hljs-constructor">HAL_UART_Transmit_DMA(&amp;<span class="hljs-params">huart2</span>,(<span class="hljs-params">uint8_t</span><span class="hljs-operator">*</span>)</span>message_3,strlen(message_3));<br>&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><center class="half"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p43.png" width="430/"><img src="/images/STM32F103C8T6最小系统板-电控-学习指南/p44.png" width="430/"></center><h2 id="简单帧格式串口通信"><a href="#简单帧格式串口通信" class="headerlink" title="简单帧格式串口通信"></a>简单帧格式串口通信</h2><p><a href="https://blog.csdn.net/weixin_65489379/article/details/122792920">https://blog.csdn.net/weixin_65489379/article/details/122792920</a></p><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p46.png" alt="简单的帧格式"></p><p>常见的帧格式为：<br><code>帧头-帧size-数据部分-校验位-帧尾</code></p><h3 id="解析数据包"><a href="#解析数据包" class="headerlink" title="解析数据包"></a>解析数据包</h3><p>解析数据包就是对收到的数据内部按照帧格式进行解析</p><ul><li>该项目使用空闲中断DMA接收不定长数据，使用使用简单帧格式对三色LED灯进行控制，实现命令某几种颜色LED灯闪烁，某几种颜色的灯长时间熄灭的效果。</li><li>采用的简单帧格式为：帧头(0xAA)-帧size-数据部分-和校验</li><li>该项目的不足：在相对复杂的工程中，需要建立<code>数据缓冲区</code>，将解析数据包的步骤搬出中断，在主循环中进行，并且需要考虑<code>数据粘包</code>，<code>数据丢失</code>等情况。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HAL_UARTEx_RxEventCallback</span><span class="hljs-params">(UART_HandleTypeDef *huart, <span class="hljs-type">uint16_t</span> Size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uint8_t</span> Verify_Flag =<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//接收新消息之前需要重置FLAG</span><br>Red_Flag = <span class="hljs-number">0</span>;<br>    Green_Flag = <span class="hljs-number">0</span>;<br>    Yello_Flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(huart == &amp;huart2)&#123;<br>        <span class="hljs-comment">//不定长数据接收(控制外设的3色LED灯)</span><br><span class="hljs-keyword">if</span>(Size &gt;<span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">char</span> message_long[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;Get Long Messages ~&quot;</span>;<br><span class="hljs-comment">// 开始校验数据</span><br><span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">0</span>]== <span class="hljs-number">0xAA</span> )<span class="hljs-comment">//帧头校验</span><br><span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">1</span>]== Size)&#123;<span class="hljs-comment">//位数校验</span><br><span class="hljs-type">uint8_t</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Size<span class="hljs-number">-1</span>;i++)&#123;<br>sum+=receiveData[i];<br>&#125;<br><span class="hljs-keyword">if</span>(sum==receiveData[Size<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-comment">//和校验</span><br>Verify_Flag =<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(Verify_Flag)&#123;<br><span class="hljs-comment">//校验成功，开始解析数据</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;Size<span class="hljs-number">-1</span>;i+=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-type">uint8_t</span> state = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(receiveData[i+<span class="hljs-number">1</span>]== <span class="hljs-number">0xFF</span>)<br>state = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x01</span>)<span class="hljs-comment">//red</span><br>Red_Flag =state;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x02</span>)<span class="hljs-comment">//yello</span><br>Yello_Flag =state;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(receiveData[i]==<span class="hljs-number">0x03</span>)<span class="hljs-comment">//green</span><br>Green_Flag =state;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (tx_complete) &#123;<br>tx_complete = <span class="hljs-number">0</span>; <br><span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_long,<span class="hljs-built_in">strlen</span>(message_long));<br>&#125;<br><span class="hljs-built_in">memset</span>(receiveData, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(receiveData));<br>&#125;<br>        <span class="hljs-comment">//定长单个指令接受（控制LED_0）</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">char</span> message_1[]=<span class="hljs-string">&quot;Get Wrong Messages ~ Why Not TRY again?&quot;</span>;<br><span class="hljs-type">char</span> message_2[]=<span class="hljs-string">&quot;The LED Is Lit Up!&quot;</span>;<br><span class="hljs-keyword">if</span> (tx_complete) &#123;<br>tx_complete = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(receiveData[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br><span class="hljs-built_in">HAL_GPIO_WritePin</span>(LED_0_GPIO_Port, LED_0_Pin, GPIO_PIN_RESET);<br><span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_2,<span class="hljs-built_in">strlen</span>(message_2));<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">HAL_UART_Transmit_DMA</span>(&amp;huart2,(<span class="hljs-type">uint8_t</span>*)message_1,<span class="hljs-built_in">strlen</span>(message_1));<br>&#125;<br>receiveData[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">HAL_UARTEx_ReceiveToIdle_DMA</span>(&amp;huart2,receiveData,<span class="hljs-built_in">sizeof</span>(receiveData));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="蓝牙模式"><a href="#蓝牙模式" class="headerlink" title="蓝牙模式"></a>蓝牙模式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>蓝牙是一种短距的无线通讯技术，可实现固定设备、移动设备之间的数据交换。一般将蓝牙3.0之前的BR&#x2F;EDR蓝牙称为<code>传统蓝牙</code>，而将蓝牙4.0规范下的LE蓝牙称为<code>低功耗蓝牙</code>。</p></li><li><p>BLE（Bluetooh Low Energy）蓝牙低能耗技术是短距离、低成本、可互操作性的无线技术，它利用许多智能手段最大限度地降低功耗。</p><p>BLE技术的工作模式非常适合用于从微型无线传感器（每半秒交换一次数据）或使用完全异步通信的遥控器等其它外设传送数据。这些设备发送的数据量非常少（通常几个字节），而且发送次数也很少（例如每秒几次到每分钟一次，甚至更少）。</p></li><li><p><code>协议</code>概述<br>所谓协议，即将指定的字节按照一定的顺序排列起来，以便他人使用自己的设备时，能通过该协议同其他设备进行通信。协议一特点，就是有固定的帧格式，通过该格式发送，接收者通过解读帧格式，进而得到新息内容；</p></li></ol><ul><li>一般通信协议，一类通信是直接发生数据，当设备接送到数据时，<code>直接对数据进行解析</code>，当接受到的数据合法时，即为有效数据，该类型的通信协议，主要用在<code>有线通信协议</code>中，比如Modbus，Can通常采用的即为该类型的通信方式。</li></ul><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p45.png" alt="蓝牙BLE协议"></p><ul><li>另一类通信协议，则需要新建立连接，当双方<code>连接建立成功了方可通信</code>，例如<code>TCP、BLE</code>；BLE协议在需要进行通信时，即需要向外发送广播信号，告诉接收者，即将和它进行通信，接受者接收到广播内容后，确认是与自己通信，于是向广播者发送一响应信息，这样当广播者和接受者都有了对方的身份信息时，即表示双方连接成功。<ul><li>因此，在连接过程中，必定有相应的广播帧格式。在BLE通信过程中，假设设备A需要连其他设备假设为B，则A需要不断地发送广播信号（此过程一般有一个时间间隔，在没发送广播数据时间内，芯片处于低功耗状态），每发送一次广播包，称之为一次广播事件。</li></ul></li></ul><h1 id="IIC通信"><a href="#IIC通信" class="headerlink" title="IIC通信"></a>IIC通信</h1><h3 id="IIC通信概念"><a href="#IIC通信概念" class="headerlink" title="IIC通信概念"></a>IIC通信概念</h3><p><img src="/images/STM32F103C8T6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/p48.png" alt="IIC通信"></p><ul><li>串口通信是全双工通信，除了共GND外，两根线（TX,RX）都能同时传输数据<ul><li>异步通信模式，双方统一比特率，在合适时机设置或者读取数据线上的高低电平</li></ul></li><li>IIC通信是半双工通信，采用主从模式进行单线通信，必须先由主机向从机发送数据（询问）之后从机才能应答。<ul><li>传输数据的线为SDA线，另一根线为SCL线，提供同步时钟脉冲。<ul><li>同步通信</li></ul></li><li>可以通过ICC实现多设备通信。</li></ul></li></ul><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    <categories>
      
      <category>电控</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F407VET6最小系统板(电控)学习指南</title>
    <link href="/2024/03/02/STM32F407VET6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2024/03/02/STM32F407VET6%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF-%E7%94%B5%E6%8E%A7-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>跟着正点原子，参考官方手册，记录一下我的学习过程~</p><span id="more"></span> <h1 id="芯片解读"><a href="#芯片解读" class="headerlink" title="芯片解读"></a>芯片解读</h1><h2 id="芯片资源"><a href="#芯片资源" class="headerlink" title="芯片资源"></a>芯片资源</h2><h4 id="1-内核："><a href="#1-内核：" class="headerlink" title="1. 内核："></a>1. 内核：</h4><ul><li>32 位 高性能 ARM Cortex-M4 处理器</li><li>时钟：高达 <code>168MHZ</code>, 实际还可以超屏一点点</li><li>支持 FPU （浮点运算）和 DSP 指令<br>STM32F407VET6: 100 个引脚，7组IO。<br>分别为<code>GPIOA~GPIOG</code>，每组IO有16个IO口，共有112个IO口 ，通常称为 PAx、PBx、PCx、PDx、PEx、PFx、PGx，其中x为0-15。</li><li>大部分 IO 口都耐 5V( 模拟通道除外 )</li><li>支持调试： <code>SWD</code> 和 <code>JTAG</code> ， SWD只要2根数据线</li></ul><h4 id="2-时钟，复位和电源管理："><a href="#2-时钟，复位和电源管理：" class="headerlink" title="2. 时钟，复位和电源管理："></a>2. 时钟，复位和电源管理：</h4><p>① 1.8~3.6V 电源和 IO 电压<br>② 上电复位，掉电复位和可编程的电压监控<br>③ 强大的时钟系统</p><ul><li>4~26M 的外部高速晶振</li><li>内部 16MHz 的高速 RC 振荡器</li><li>内部 32KHz 低速 RC 振荡器，看门狗时钟</li><li>内部锁相环（ PLL ，倍频），一般系统时钟都是外部或者内部高速时钟经过 PLL 倍频后得到</li><li>外部低速 32.768K 的晶振，主要做 RTC 时钟源</li></ul><h4 id="3-低功耗："><a href="#3-低功耗：" class="headerlink" title="3. 低功耗："></a>3. 低功耗：</h4><ul><li>睡眠，停止和待机三种低功耗模式</li><li>可用电池为 <code>RTC</code> 和<code>备份寄存器供电</code></li></ul><h4 id="4-AD-模电信号转换为数电信号的通道"><a href="#4-AD-模电信号转换为数电信号的通道" class="headerlink" title="4. AD(模电信号转换为数电信号的通道):"></a>4. <code>AD</code>(模电信号转换为数电信号的通道):</h4><ul><li>3个12 位 AD 【多达 24 个外部测量通道】</li><li>内部通道可以用于内部温度测量</li><li>内置参考电压</li></ul><h4 id="5-DA-数电信号转换为模电信号的通道"><a href="#5-DA-数电信号转换为模电信号的通道" class="headerlink" title="5. DA(数电信号转换为模电信号的通道):"></a>5. DA(数电信号转换为模电信号的通道):</h4><p>2 个 12 位 DA通道</p><h4 id="6-DMA"><a href="#6-DMA" class="headerlink" title="6. DMA:"></a>6. DMA:</h4><p>16 个 DMA 通道 ，带 FIFO 和突发支持<br>支持外设：定时器， ADC,DAC,SDIO,I2S,SPI,I2C,和 USART。</p><ul><li>DMA是什么：<br>DMA，全称Direct Memory Access，即直接存储器访问。<br>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/138573828">关于DMA的详细介绍</a></p><h3 id="7-定时器：多达-17-个定时器"><a href="#7-定时器：多达-17-个定时器" class="headerlink" title="7.定时器：多达 17 个定时器"></a>7.定时器：多达 17 个定时器</h3><ul><li>10 个通用定时器（ TIM2 和 TIM5 是 32 位）</li><li>2 个基本定时器</li><li>2 个高级定时器</li><li>1 个系统定时器</li><li>2 个看门狗定时器</li></ul><h4 id="8-通信接口：多达-15-个通信接口"><a href="#8-通信接口：多达-15-个通信接口" class="headerlink" title="8. 通信接口：多达 15 个通信接口"></a>8. 通信接口：多达 15 个通信接口</h4><ul><li>3 个 I2C 接口</li><li>4 个串口</li><li>3 个 SPI 接口</li><li>2 个 CAN2.0</li><li>2 个 USB OTG</li><li>1 个 SDIO</li></ul><h2 id="芯片结构和引脚"><a href="#芯片结构和引脚" class="headerlink" title="芯片结构和引脚"></a>芯片结构和引脚</h2><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p8.png" alt="芯片结构"></p><p>引脚和功能的对应，查看芯片手册。</p><h2 id="STM32-最小系统包含的功能模块"><a href="#STM32-最小系统包含的功能模块" class="headerlink" title="STM32 最小系统包含的功能模块"></a>STM32 最小系统包含的功能模块</h2><ul><li><p>供电</p></li><li><p>复位</p></li><li><p>时钟：外部晶振（ 2 个）</p></li><li><p>Boot 启动模式选择</p><ul><li>STM32 直接通过两个引脚 Boot0 和 Boot1 设置启动模式：<br><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p7.png" alt="Boot启动模式"></li></ul></li><li><p>下载电路(串口 &#x2F;JTAG&#x2F;SWD)</p></li><li><p>后备电池</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>电控</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32CubeMX教程</title>
    <link href="/2024/03/02/STM32CubeMX%E6%95%99%E7%A8%8B/"/>
    <url>/2024/03/02/STM32CubeMX%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>从这里作为电控学习的起点叭~</p><span id="more"></span> <h1 id="简介和安装"><a href="#简介和安装" class="headerlink" title="简介和安装"></a>简介和安装</h1><p>STM32CubeMX是一个图形化的工具，也是配置和初始化C代码生成器（STM32 configuration and initialization C code generation），也就是自动生成开发初期关于芯片相关的一些初始化代码。</p><h2 id="STM32CubeMX和STM32CubeIDE的区别"><a href="#STM32CubeMX和STM32CubeIDE的区别" class="headerlink" title="STM32CubeMX和STM32CubeIDE的区别"></a>STM32CubeMX和STM32CubeIDE的区别</h2><ul><li>STM32CubeMX 是个图形化配置工具，最大的好处是帮用户生成相应的初始化代码。</li><li>STM32CubeIDE 是编译器，最大的功能是帮助用户编译调试代码，包括 STM32CubeMX 生成的项目代码。STM32CubeIDE 也同时集成了STM32CubeMX工具。</li></ul><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><ul><li><p>Stsp 1: Oracle官方下载<code>JRE</code><br>由于STM32CubeMX软件是基于JAVA环境运行的，所以需要安装JRE才能使用。在官网下载即可：<a href="https://www.oracle.com/cn/java/technologies/downloads/#jdk21-windows">这里是官网下载的地址</a></p></li><li><p>Step 2：ST官方下载<code>STM32CubeMX</code>工具<br><a href="https://www.st.com/content/st_com/en/stm32cubemx.html">官网下载</a></p></li><li><p><code>HAL库</code>安装：</p><ul><li>STM32 HAL固件库是Hardware Abstraction Layer的缩写，中文名称是：硬件抽象层。HAL库是ST公司为STM32的MCU最新推出的抽象层嵌入式软件，为更方便的实现跨STM32产品的最大可移植性。</li><li>HAL库有在线安装、离线安装两种方式。建议使用在线安装，简单省事；<code>不同芯片型号对应的HAL库不一样，要分别安装</code>。</li><li>在线安装：打开安装好的 STM32CubeMX 软件  点上面<code>Help -&gt; Manage embedded software packages -&gt; 选择芯片型号 -&gt; “Install Now” </code></li></ul><p>  <img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p1.png" alt="HAL库安装"></p></li><li><p>IDE安装：这里选择<code>Keil MDK5</code>:<br>Keil是德国知名软件公司Keil开发的微控制器软件开发平台，是目前ARM内核单片机开发的主流工具。<br> Keil提供了包括C编译器、宏汇编、连接器、库管理和一个功能强大的仿真调试器在内的完整开发方案，通过一个集成开发环境（uVision）将这些功能组合在一起。</p></li><li><p><a href="https://blog.csdn.net/weixin_44543463/article/details/120535830">Keil MDK5 安装教程</a></p><ul><li>安装注意事项：<br>1 ）安装路径为英文路径（不要是中文路径）。<br>2 ） 系统用户名不能为中文<br>3 ）多个版本 MDK （ Keil ）不要安装在同一目录。<br>4 ） MDK5 需要加载芯片对应的支持包。</li></ul></li><li><p>USB 串口驱动安装</p><ul><li>USB串口的作用：<br>1 ）可以当串口使用。<br>2 ）使USB 串口连接到 STM32 的串口1(STM32<br>ISP 下载只能是串口 1) ，可用串口下载程序。<br>3 ）可用 USB 供电</li><li>USB 串口驱动芯片型号：<code>CH340</code><ul><li><a href="https://blog.csdn.net/jn10010537/article/details/109169023">Windows下CH340串口驱动安装教程</a><br>  <img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p7.png" alt="CH340驱动安装成功"></li></ul></li><li>串口下载工具： mcuisp(FlyMcu)<ul><li>FlyMcu 模拟仿真软件是一款用于 STM32 芯片 ISP 串口烧录程序的专用工具，免费，且较为非常容易下手，好用便捷。</li><li>注意：STM32 芯片的 ISP 下载，只能使用<code>串口1（USART1）</code>，对应的串口发送<code>接收引脚 PA9、PA10</code>。不能使用其他串口来代替。</li><li><a href="https://blog.csdn.net/qq_52102933/article/details/126882848">FlyMcu安装教程</a></li></ul></li></ul></li><li><p>JLINK驱动安装：安装了驱动之后，就可以在 windows 下配合MDK 进行程序下载和调试。</p><ul><li><a href="https://blog.csdn.net/qq_41990294/article/details/123821868">JLINK安装教程</a></li></ul></li></ul><h1 id="快速开始（以STM32F407VEST为例）"><a href="#快速开始（以STM32F407VEST为例）" class="headerlink" title="快速开始（以STM32F407VEST为例）"></a>快速开始（以STM32F407VEST为例）</h1><p>补充：stm32系列的命名规则：</p><p> <img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p5.png" alt="stm32系列的命名规则"></p><h2 id="选择具体型号的芯片"><a href="#选择具体型号的芯片" class="headerlink" title="选择具体型号的芯片"></a>选择具体型号的芯片</h2><p>在首页点击<code>ACCESS TO MCU SELECTOR</code>，搜索选择具体型号的芯片，点击<code>Start Project</code></p><ul><li>常用的芯片可以点击<img src="/.io//0173D8BF.png">收藏起来，不用每次都搜集了。</li></ul><p> <img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p2.png" alt="芯片导入"></p><h2 id="配置系统核心"><a href="#配置系统核心" class="headerlink" title="配置系统核心"></a>配置系统核心</h2><p>选择左侧<code>System Core</code>：</p><h3 id="Step-1：-配置外部时钟-（晶振）-输入"><a href="#Step-1：-配置外部时钟-（晶振）-输入" class="headerlink" title="Step 1： 配置外部时钟 （晶振） 输入"></a>Step 1： 配置外部时钟 （晶振） 输入</h3><p>stm32主控芯片的内部是有两个时钟的，分别是内部高速和内部低速，但是一般不会特别精准，所以需要外接时钟电路：</p><ul><li>外接时钟电路，一般高速晶振的频率是8 MHZ，通过倍频器可以达到72 MHZ。低速晶振的频率是32.768KHZ。</li></ul><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p3.png" alt="RCC配置外部高频晶振"></p><p>配置好之后，芯片晶振对应的引脚变为绿色。</p><h3 id="Step-2：-配置调试引脚"><a href="#Step-2：-配置调试引脚" class="headerlink" title="Step 2： 配置调试引脚"></a>Step 2： 配置调试引脚</h3><p>选择<code>SYS</code>选项 -&gt; <code>Serial Wire</code></p><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p.png" alt="本人使用ST-link，故选择SW，其他调试器请按照对应的进行选择"></p><p>配置好之后，芯片的引脚变为绿色。</p><ul><li>至于为什么需要配置Serial Wire？<br>原因是，STM32的GPIO口都是有复用功能。 其中，PA13与PA14都有两种功能 :<br> PA13可以是JTMS，也可以是SWDIO。STM32默认是JTAG模式，所以PA13默认是JTMS，并不是SWDIO。<ul><li>在Debug栏目，选择Serial Wire（SWD模式）之后，PA13是SWDIO，PA14是SWCLK。然后PA15，PB3，PB就只是普通的GPIO。</li></ul></li></ul><h4 id="SWD简介"><a href="#SWD简介" class="headerlink" title="SWD简介"></a>SWD简介</h4><p>SWD是Serial Wire Debug的简称，翻译成中文是”串行线调试”。 SWD是ARM目前支持的两种调试端口之一，另一个调试端口叫做JTAG Debug Port，也就是我们常用的J-link上面的调试端口（JTAG模式下）。</p><p>基于ARM CoreSight调试构架，SWD可以通过传输数据包来读写芯片的寄存器。SWD是用于访问ARM调试接口的双线协议。它是ARM调试接口规范(ARM Debug Interface Architecture Specification)的一部分，是JTAG的替代品。SWD的物理层由两条线组成：</p><ul><li>SWDIO: 双向数据线</li><li>SWCLK: host驱动的时钟线</li></ul><p>详细了解SWD，可以看看这些：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/585888851">搞懂ARM Debug Interface之SWD</a></li><li><a href="https://blog.csdn.net/nianzhu2937/article/details/105226788">debug: Serial wire、JTAG-4、JTAG-5的区别，以及如何应用</a></li></ul><h3 id="Step-3：-配置时钟分频"><a href="#Step-3：-配置时钟分频" class="headerlink" title="Step 3： 配置时钟分频"></a>Step 3： 配置时钟分频</h3><p>点击上方<code>Clock Configuration</code><br>修改想要的时钟频率，一般选最大速度。F407最大速度为168Mhz。修改之后软件会自动分频。</p><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p4.png" alt="配置时钟分频"></p><p>基础配置到此结束，接下来就是按照需求配置引脚。</p><h2 id="按照需求配置引脚"><a href="#按照需求配置引脚" class="headerlink" title="按照需求配置引脚"></a>按照需求配置引脚</h2><h1 id="学会阅读开发手册"><a href="#学会阅读开发手册" class="headerlink" title="学会阅读开发手册"></a>学会阅读开发手册</h1><p>学习STM32F407主要下载这几个手册。不光学习STM32需要这类手册，学习FPGA、DSP也是这些类型的手册，熟练查阅和使用这些手册也是电子工程师必备的知识之一。</p><ul><li><p>参考手册（Reference Manual）<br>对芯片每个外设的具体描述和功能介绍，比如我们要查USART，SPI，DMA相关寄存器和功能的介绍就可以使用这个手册。</p></li><li><p>数据手册（Data Sheet）<br>在我们要画PCB的时候用到这个手册的情况比较多，这个手册上面有关于这个系列芯片的引脚定义、电气特性、机械封装、料号定义等信息。</p></li><li><p>勘误手册（Errata Sheet）<br>描述了芯片某些功能的局限性，并给出解决办法。这个手册也比较重要，有时候我们觉得有些地方调试老是出问题，就需要查找一下，看看是否是硬件bug。</p></li><li><p>闪存编程手册（Flash Programming Manual）<br>芯片的片上Flash操作指南，比如芯片的擦除，编程，闪存读写保护，选项字节信息等。</p></li><li><p>内核编程手册（Cortex-M Programming Manual）<br>对内核的系统控制块的介绍。这个手册有时候也要用到，比如我们需要了解NVIC和SysTick相关的寄存器，就需要使用这个手册。这个手册可以在ARM官方网站下载，也可以到ST官网下载，区别是ARM官网下载的手册是通用的，而ST的是针对自家芯片做的。有时候在参考手册上面找不到相关寄存器的信息时，就需要用到这个手册。</p></li><li><p><code>应用笔记</code>（Application Note）<br>针对不同应用主题的描述性文档，部分笔记还会有配套的固件例程。应用笔记的重要性不言而喻，很多时候官方对一些应用做出了解决方案，都会以应用笔记的形式发布。</p></li><li><p>用户手册（User Manual）<br>一般是对某个软件库的说明文档。</p></li><li><p>Cortex-M3&#x2F;M4权威指南<br>这也是非常重要的参考资料，了解了内核才能更好的利用M3&#x2F;M4。<br><a href="http://www.armbbs.cn/forum.php?mod=viewthread&tid=2161">论坛下载地址</a></p></li></ul><h2 id="查找手册方法"><a href="#查找手册方法" class="headerlink" title="查找手册方法"></a>查找手册方法</h2><p>进入<a href="http://www.st.com/">ST官方地址</a>，页面上侧中间编辑框输入STM32F407检索,<code>Profucts -&gt; Resources</code>,下载需要的技术手册的PDF即可。</p><ul><li><a href="http://www.stmcu.org.cn/">ST中文社区</a>，里面的资料全部由ST中国区的人负责更新和整理，包含了所有ST公司的MCU资料，比如：STM32F4最新的芯片文档（参考手册、数据手册、勘误手册、编程手册等）、软件资源（固件库、配置工具、PC软件等）、硬件资源（各种官方评估板）等。</li></ul><h2 id="正点原子的教程"><a href="#正点原子的教程" class="headerlink" title="正点原子的教程"></a>正点原子的教程</h2><p><a href="http://www.openedv.com/docs/boards/stm32/zdyz_stm32f407_mini_sysboard.html">教程看这里</a></p><h1 id="程序下载的五种方式"><a href="#程序下载的五种方式" class="headerlink" title="程序下载的五种方式"></a>程序下载的五种方式</h1><h2 id="一-JLINK烧录程序"><a href="#一-JLINK烧录程序" class="headerlink" title="一.JLINK烧录程序"></a>一.JLINK烧录程序</h2><p>JLINK 是一个兼容 JTAG 的仿真器，可以<code>烧录程序和调试</code>。</p><p>调试 ARM ，需要遵循 ARM 的调试接口协议， JTAG 就是其中的一种。JTAG 是一种国际标准测试协议，也叫 ARM 调试协议。现在多数的高级器件都支持 JTAG 协议，如 DSP 、 FPGA 器件等。</p><ul><li>需要下载JLINK驱动<br><a href="https://blog.csdn.net/qq_41990294/article/details/123821868">JLINK驱动安装教程</a></li></ul><h3 id="硬件连线"><a href="#硬件连线" class="headerlink" title="硬件连线"></a>硬件连线</h3><p>烧 STM32 只要用 4 条杜邦线就可以了，和 STM32 ST-LINK Utility 下载连线一样，采用SWD 接口模式。<br>即：<code>GND接GND,SWDIO接SWDIO(TMS),SWCLK接SWCLK(TCK),3V3接3V3</code>。</p><p><a href="https://blog.csdn.net/xinghuanmeiying/article/details/78026561">正版ST-link&#x2F;V2 J-LINK JTAG&#x2F;SWD引脚定义和注意事项</a></p><h3 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h3><h2 id="二-使用ch340串口烧录程序"><a href="#二-使用ch340串口烧录程序" class="headerlink" title="二.使用ch340串口烧录程序"></a>二.使用ch340串口烧录程序</h2><p><a href="https://blog.csdn.net/qq_38326581/article/details/109084359">教程</a></p><h2 id="三-使用STLink烧录程序"><a href="#三-使用STLink烧录程序" class="headerlink" title="三.使用STLink烧录程序"></a>三.使用STLink烧录程序</h2><p><a href="https://blog.csdn.net/qq_52102933/article/details/126830904">教程</a></p><h3 id="在Keil中配置ST-Link"><a href="#在Keil中配置ST-Link" class="headerlink" title="在Keil中配置ST-Link"></a>在Keil中配置ST-Link</h3><ol><li>点击魔术棒：</li></ol><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p9.png" alt="连接STLink"></p><ol start="2"><li>设置“Cortex-M Target Driver Setup”窗口中的“Debug”页面。</li></ol><ul><li>点击“Debug”。</li><li>将“Unit”选择为“ST-Link&#x2F;V2”。</li><li>将Port设置为“<code>SW</code>”。<br>使用 JTAG 需要占用比 SWD 模式更多的 IO 口，而在开发板上这些 IO 口可能被其他外设用到，可能造成部分外设无法使用。所以在调试的时候，一定要选择 SW 模式。</li><li>设置数据传输速率。</li></ul><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p10.png" alt="设置STLink参数"></p><ol start="3"><li>设置“Cortex-M Target Driver Setup”窗口中的“Flash Download”页面</li></ol><ul><li>点击“Flash Download”。</li><li>选择“Erase Full Chip”。</li><li>勾选“Program”、“Verify”、“Reset and Run”。</li><li>添加“Flash Program Algorithm”，我使用的是STM32F429，所以选择“STM32F4xx Flash”。</li><li>最后点击“确定”，完成配置。</li></ul><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p11.png" alt="设置STLink参数"></p><ol start="4"><li>确认一下，“Utilities”页中，“Use Debug Driver”和“Update Target before Debugging”两项已经勾选上。<br>  “Use Debug Driver”指的是选择 ST-Link 来给目标器件的 FLASH 烧录编程。<br>  “Update Target before Debugging”指的是先将程序烧录到 FLASH 上，再开始调试。</li></ol><h3 id="F8烧录程序"><a href="#F8烧录程序" class="headerlink" title="F8烧录程序"></a>F8烧录程序</h3><p><img src="/images/STM32CubeMX%E6%95%99%E7%A8%8B/p12.png" alt="烧录程序"></p><h2 id="断电后，重新供电开机要先复位"><a href="#断电后，重新供电开机要先复位" class="headerlink" title="断电后，重新供电开机要先复位"></a>断电后，重新供电开机要先复位</h2>]]></content>
    
    
    <categories>
      
      <category>电控</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用指南</title>
    <link href="/2024/02/19/Docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/02/19/Docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>码头工人，启动！</p><span id="more"></span> <h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>Docker容器是与系统其他部分隔离开的一系列进程，运行这些进程所需的所有文件都由另一个镜像提供，从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多，并且支持在多种主流云平台（PaaS）和本地系统上部署。Docker容器很好地解决了“开发环境能正常跑，一上线就各种崩”的尴尬。</p><h2 id="Docker容器的特点："><a href="#Docker容器的特点：" class="headerlink" title="Docker容器的特点："></a>Docker容器的特点：</h2><ul><li>轻量</li><li>快速：容器的启动和创建无需启动GuestOS，可以实现秒级甚至毫秒级的启动。</li><li>可移植性：Docker容器技术是将应用及所依赖的库和运行时的环境技术改造包成容器镜像，可以在不同的平台运行。</li><li>自动化：容器生态中的容器编排工作（如：Kubernetes）可帮助我们实现容器的自动化管理。</li></ul><p>使用表格对比如下：</p><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h2 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h2><ul><li>打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</li><li>分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</li><li>部署：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</li></ul><h2 id="镜像、容器"><a href="#镜像、容器" class="headerlink" title="镜像、容器"></a>镜像、容器</h2><ul><li>镜像：可以理解为软件安装包，可以方便的进行传播和安装。</li><li>容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</li></ul><h1 id="基本教程"><a href="#基本教程" class="headerlink" title="基本教程"></a>基本教程</h1><p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">基础教程网站看这里！</a></p><h1 id="怎么编写Dockerfile"><a href="#怎么编写Dockerfile" class="headerlink" title="怎么编写Dockerfile"></a>怎么编写Dockerfile</h1><p>Dockerfile是用来描述文件的构成的文本文档，其中包含了用户可以在使用行调用以组合Image的所有命令，用户还可以使用Docker build实现连续执行多个命令指今行的自动构建。</p><p>Dockerfile的语法非常简单，常用的只有11个：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>基于哪个镜像来实现</td></tr><tr><td>MAINTAINER</td><td>镜像的创建者</td></tr><tr><td>ENV</td><td>声明环境变量</td></tr><tr><td>RUN</td><td>执行的命令</td></tr><tr><td>ADD</td><td>添加宿主机文件到容器里，有需要解压的文件会自动解压</td></tr><tr><td>COPY</td><td>添加宿主机文件到容器里</td></tr><tr><td>WORKDIR</td><td>工作目录</td></tr><tr><td>EXPOSE</td><td>容器内应用可使用的端口</td></tr><tr><td>CMD</td><td>容器启动后所执行的程序，如果执行docker run后面跟启动命令会被覆盖掉</td></tr><tr><td>ENTRYPOINT</td><td>与CMD功能相同，但需docker run不会覆盖，如果需要覆盖可增加参数-entrypoint来覆盖</td></tr><tr><td>VOLUME</td><td>将宿主机的目录挂载到容器里</td></tr></tbody></table><h3 id="一些命令的详细介绍"><a href="#一些命令的详细介绍" class="headerlink" title="一些命令的详细介绍"></a>一些命令的详细介绍</h3><ul><li><p>FROM：定制的镜像都是基于 FROM 的镜像，例如 ：<br><code>FROM ros:humble</code> , 这个Docker镜像是从名为 ros 的镜像中的 humble 版本构建的。（ros 是ROS官方提供的Docker镜像，humble 是其版本或标签）。<br>后续的操作都是基于 ros。</p></li><li><p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p><ul><li>shell 格式：  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> &lt;命令行命令&gt;<br><span class="hljs-comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure></li><li>exec 格式：  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">RUN</span> [<span class="hljs-string">&quot;可执行文件&quot;</span>, <span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>]<br># 例如：<br># <span class="hljs-keyword">RUN</span> [<span class="hljs-string">&quot;./test.php&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;offline&quot;</span>] 等价于 <span class="hljs-keyword">RUN</span> ./<span class="hljs-keyword">test</span>.php dev offline<br></code></pre></td></tr></table></figure></li><li>设置在容器内部执行命令时所使用的Shell类型，指定为bash的命令：<br><code>SHELL [&quot;/bin/bash&quot;, &quot;-c&quot;]</code></li><li>Dockerfile 的指令每执行一次都会在 docker 上新建一层。过多无意义的层，会造成镜像膨胀过大。以<code>&amp;&amp;</code> 符号连接命令，这样执行后，只会创建 1 层镜像。</li></ul></li><li><p>ENV： 设置环境变量，将在Docker容器启动时生效，并可供容器内的应用程序或脚本使用。</p><ul><li>格式：<code>ENV &lt;key&gt; &lt;value&gt; </code></li><li>例如：  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ENV NVIDI<span class="hljs-built_in">A_VISIBLE</span>_DEVICES all<br>ENV NVIDI<span class="hljs-built_in">A_DRIVER</span>_CAPABILITIES compute,utility,graphics,video<br></code></pre></td></tr></table></figure></li><li>NVIDIA_VISIBLE_DEVICES: 使用CUDA环境变量CUDA_VISIBLE_DEVICES来限定CUDA程序所能使用的GPU设备</li><li>NVIDIA_DRIVER_CAPABILITIES: 设置容器中允许使用显卡的某些能力</li></ul></li><li><p>NVIDIA_DRIVER_CAPABILITIES 变量的可能值是:</p></li></ul><table><thead><tr><th>可能的值</th><th>描述</th></tr></thead><tbody><tr><td><code>compute,video</code> 或 <code>graphics,utility</code></td><td>容器需要的驱动程序功能的逗号分隔列表。</td></tr><tr><td><code>all</code></td><td>启用所有可用的驱动程序功能。</td></tr><tr><td>为空或未设置</td><td>使用默认驱动程序功能：<code>utility</code>，<code>compute</code>。</td></tr></tbody></table><p>下面提供了支持的驱动程序功能：</p><table><thead><tr><th>驱动能力</th><th>描述</th></tr></thead><tbody><tr><td><code>compute</code></td><td>CUDA 和 OpenCL 应用程序需要。</td></tr><tr><td><code>compat32</code></td><td>运行 32 位应用程序所必需的。</td></tr><tr><td><code>graphics</code></td><td>运行 OpenGL 和 Vulkan 应用程序所必需的。</td></tr><tr><td><code>utility</code></td><td>需要使用 <code>nvidia-smi</code> 和 NVML。</td></tr><tr><td><code>video</code></td><td>需要使用视频编解码器 SDK。</td></tr><tr><td><code>display</code></td><td>利用 X11 显示所需的。</td></tr><tr><td><code>all</code></td><td>启用所有可用的驱动程序功能。</td></tr></tbody></table><ul><li>CMD ：<br>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:<ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。<br>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li></ul></li></ul><p>注意：如果 Dockerfile 中如果存在<code>多个 CMD 指令，仅最后一个生效</code>。</p><ul><li><p>COPY :复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] <span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>...  <span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span><br>COPY [--chown=<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>] [&quot;<span class="hljs-tag">&lt;<span class="hljs-name">源路径1</span>&gt;</span>&quot;,...  &quot;<span class="hljs-tag">&lt;<span class="hljs-name">目标路径</span>&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><ul><li>[–chown&#x3D;<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</group></user></li><li>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。<br>  例如：  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure></li><li>&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</li></ul></li><li><p>EXPOSE : 仅仅只是声明端口。</p><ul><li>作用：<br>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>WORKDIR :<br>指定工作目录。<br>用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><ul><li>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu<br><br><span class="hljs-comment"># 设置工作目录为 /app</span><br>WORKDIR /app<br><br><span class="hljs-comment"># 将当前目录下的所有文件复制到 /app 目录下</span><br>COPY . .<br><br><span class="hljs-comment"># 在 /app 目录下执行命令</span><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update &amp;&amp; apt-<span class="hljs-built_in">get</span> install -y python3<br><br><span class="hljs-comment"># 当容器启动时，默认进入 /app 目录</span><br>CMD [<span class="hljs-string">&quot;python3&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Dockerfile的基本结构"><a href="#Dockerfile的基本结构" class="headerlink" title="Dockerfile的基本结构"></a>Dockerfile的基本结构</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">11</span><br><span class="hljs-keyword">MAINTAINER</span> easydoc.net<br><br><span class="hljs-comment"># 复制代码</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> . /app</span><br><br><span class="hljs-comment"># 设置容器启动后的默认运行目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 运行命令，安装依赖</span><br>RRUN apt-get update &amp;&amp; \             <span class="hljs-comment"># 更新Ubuntu软件包列表</span><br>    apt-get -y install \             <span class="hljs-comment"># 使用apt-get命令安装一系列软件包,-y标志用于在安装过程中自动确认所有的提示信息</span><br>    vim wget curl \                  <span class="hljs-comment"># 安装vim、wget和curl这三个工具</span><br>    libopencv-dev \                  <span class="hljs-comment"># 安装OpenCV的开发文件</span><br>    python3 python3-pip \            <span class="hljs-comment"># 安装Python3解释器和Python3的包管理工具pip</span><br>    &amp;&amp; rm -rf /var/lib/apt/lists/*   <span class="hljs-comment"># 清理apt-get update生成的缓存文件，以减少Docker镜像的大小</span><br><br><span class="hljs-comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span><br><span class="hljs-comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span><br><span class="hljs-comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> node app.js</span><br><br><span class="hljs-comment"># ENV 设置环境变量</span><br><span class="hljs-keyword">ENV</span> NVIDIA_VISIBLE_DEVICES all<br><span class="hljs-keyword">ENV</span> NVIDIA_DRIVER_CAPABILITIES compute,utility,graphics,video<br></code></pre></td></tr></table></figure><h1 id="Build-为镜像（安装包）和运行"><a href="#Build-为镜像（安装包）和运行" class="headerlink" title="Build 为镜像（安装包）和运行"></a>Build 为镜像（安装包）和运行</h1><p>在 Dockerfile 文件的存放目录下，执行构建动作：<br>step 1 : 编译</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">docker <span class="hljs-keyword">build </span>-t test:<span class="hljs-built_in">v1</span> .<br></code></pre></td></tr></table></figure><p><code>-t</code> 设置镜像名字和版本号<br><a href="https://docs.docker.com/engine/reference/commandline/build/">命令参考</a></p><p>step 2 ：运行</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span>-hello <span class="hljs-keyword">test</span>:v1<br></code></pre></td></tr></table></figure><p><code>-p</code> 映射容器内端口到宿主机</p><p><code>--name</code> 容器名字</p><p><code>-d</code> 后台运行</p><p><a href="https://docs.docker.com/engine/reference/run/">命令参考文档</a></p><p>更多相关命令：</p><ul><li>docker ps 查看当前运行中的容器</li><li>docker images 查看镜像列表</li><li>docker rm container-id 删除指定 id 的容器</li><li>docker stop&#x2F;start container-id 停止&#x2F;启动指定 id 的容器</li><li>docker rmi image-id 删除指定 id 的镜像</li><li>docker volume ls 查看 volume 列表</li><li>docker network ls 查看网络列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV光流跟踪项目</title>
    <link href="/2024/02/17/OpenCV%E5%85%89%E6%B5%81%E8%B7%9F%E8%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/02/17/OpenCV%E5%85%89%E6%B5%81%E8%B7%9F%E8%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>交科的视觉项目，使用CV的光流跟踪对轻轨前进的速度进行解算。</p><span id="more"></span> <h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><h2 id="整体功能设计"><a href="#整体功能设计" class="headerlink" title="整体功能设计"></a>整体功能设计</h2><ol><li>光流demo</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32最小系统板</title>
    <link href="/2024/02/13/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/"/>
    <url>/2024/02/13/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>我的第一块板子！</p><span id="more"></span> <h1 id="MCU芯片介绍"><a href="#MCU芯片介绍" class="headerlink" title="MCU芯片介绍"></a>MCU芯片介绍</h1><ol><li><p>MCU即<code>微控制单元</code>（Micro Controller Unit），又称<code>单片机</code>（Single Chip Microcomputer），是将CPU、存储、外围功能都整合在单一芯片上具有控制功能的芯片级计算机，作为高度集成的微型计算机控制系统，单片机具有系统结构简单、可靠性高、处理功能强、低电压和低功耗、环境适应能力强等特点，已广泛应用于汽车电子、工业控制、仪器仪表、家电等领域。</p></li><li><p>构成MCU的几个重要组件包括：</p></li></ol><ul><li><p>中央处理器（CPU）<br>CPU是单片机的大脑。它由算术逻辑单元(ALU)和控制单元(CU)组成。CPU读取、解码和执行指令以执行算术、逻辑和数据传输操作。</p></li><li><p>存储单元<br>任何计算系统都需要两种类型的存储器：<code>程序存储器</code>和<code>数据存储器</code>。</p><ul><li>程序存储器，顾名思义，包含程序，即要由CPU执行的指令。</li><li>数据存储器需要在执行指令时存储临时数据。</li><li>通常，<code>程序存储器是只读存储器（ROM），数据存储器是随机存取存储器（RAM）</code>。</li></ul></li><li><p>输入&#x2F;输出端口<br>单片机与外部世界的接口由输入&#x2F;输出端口（I&#x2F;O端口）提供。</p><ul><li>开关、键盘等输入设备以二进制数据的形式从用户向CPU提供信息。CPU在接收到来自输入设备的数据后，执行适当的指令并通过LED、显示器、打印机等输出设备做出响应。</li></ul></li><li><p>定时器&#x2F;计数器<br>单片机的重要组件之一是定时器和计数器。它们提供时间延迟和计数外部事件的操作。此外，定时器和计数器可以提供<code>函数生成、脉宽调制、时钟控制</code>等。</p></li><li><p>总线</p></li></ul><p>单片机的另一个重要组件是系统总线。系统总线是一组连接线，将CPU与其他外围设备（如内存、I&#x2F;O端口和其他支持组件）连接起来。</p><h1 id="主控芯片"><a href="#主控芯片" class="headerlink" title="主控芯片"></a>主控芯片</h1><p>型号：STM32F103VGT6</p><h2 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h2><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p12.png" alt="引脚说明1"></p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p13.png" alt="引脚说明2"></p><h3 id="温度感应器"><a href="#温度感应器" class="headerlink" title="温度感应器"></a>温度感应器</h3><p>温度传感器必须产生随温度线性变化的电压。转换范围在2 V &lt;VDDA ❤️.6 V之间。温度传感器内部连接到ADC1_IN16输入通道，该通道用于将传感器输出电压转换为数字值。</p><h2 id="Boot-modes"><a href="#Boot-modes" class="headerlink" title="Boot modes"></a>Boot modes</h2><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p1.png" alt="Boot modes"></p><ol><li><p>芯片手册的原文如下：</p><blockquote><p>At startup, boot pins are used to select one of three boot options:</p><ul><li>Boot from <code>user Flash</code>: you have an option to boot from any of two memory banks.</li></ul></blockquote><ul><li>By default, boot from Flash memory bank 1 is selected. </li><li>You can choose to boot from Flash memory bank 2 by setting a bit in the option bytes.<blockquote><ul><li>Boot from <code>system memory</code></li><li>Boot from <code>embedded SRAM</code><br>The boot loader is located in system memory. It is used to reprogram the Flash memory by<br>using USART1.</li></ul></blockquote></li></ul></li><li><p>详解：</p></li></ol><ul><li><p>第一种方式<code>(boot0 = 0)</code>：Flash memory启动方式<br>启动地址：0x08000000 是STM32内置的Flash，一般我们使用<code>JTAG或者SWD模式下载程序</code>时，就是下载到这个里面，重启后也直接从这启动程序。<br><code>基本上都是采用这种模式</code>。</p></li><li><p>第二种方式<code>(boot0 = 1；boot1 = 0)</code>：System memory启动方式<br>启动地址：0x1FFF0000从系统存储器启动，这种模式启动的程序功能是由厂家设置的。</p><ul><li>一般来说，这种启动方式用的比较少。系统存储器是芯片内部一块特定的区域，STM32在出厂时，由ST在这个区域内部预置了一段BootLoader， 也就是我们常说的ISP程序， 这是一块ROM，出厂后无法修改。一般来说，我们选用这种启动模式时，是为了<code>从串口下载程序</code>，因为在厂家提供的BootLoader 中，提供了串口下载程序的固件，可以通过这个BootLoader将程序下载到系统的Flash中。<br>  但是这个下载方式需要以下步骤：</li><li>将BOOT0设置为1，BOOT1设置为0，然后按下复位键，这样才能从系统存储器启动BootLoader</li><li>最后在BootLoader的帮助下，通过串口下载程序到Flash中</li><li>程序下载完成后，又有需要将BOOT0设置为GND，<code>手动复位</code>，这样，STM32才可以从Flash中启动可以看到， 利用串口下载程序还是比较的麻烦，需要跳帽跳来跳去的，非常的不注重用户体验。</li></ul></li><li><p>第三种方式(boot0 &#x3D; 1;boot1 &#x3D; 1)：SRAM启动方式。<br>启动地址：0x20000000 内置SRAM，既然是SRAM，自然也就<code>没有程序存储</code>的能力了.</p><ul><li>这个模式一般用于<code>程序调试</code>。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，在将程序下载到SRAM中。</li></ul></li></ul><h3 id="关于flash死锁的解决办法-Flash-memory启动方式"><a href="#关于flash死锁的解决办法-Flash-memory启动方式" class="headerlink" title="关于flash死锁的解决办法(Flash memory启动方式)"></a>关于flash死锁的解决办法(Flash memory启动方式)</h3><p>开发调试过程中，由于某种原因导致内部Flash锁死，无法连接SWD以及JTAG调试，无法读到设备，可以通过修改BOOT模式重新刷写代码。修改为<code>BOOT0=1，BOOT1=0</code>即可从系统存储器启动，ST出厂时自带Bootloader程序，SWD以及JTAG调试接口都是专用的。<code>重新烧写程序后，将BOOT模式重新更换到BOOT0=0，BOOT1=X</code>即可正常使用。</p><blockquote><p>在芯片中，Boot1的引脚就是BOOT0,Boot1的引脚是PB2。<br>我采用了第一种Flash memory启动方式，需要将boot0和&gt;boot1默认为低电平，摁下boot0的按键，boot0变为高电平。</p></blockquote><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p3.png" alt="启动模式"></p><h2 id="Power-supply-schemes"><a href="#Power-supply-schemes" class="headerlink" title="Power supply schemes"></a>Power supply schemes</h2><p>芯片手册的原文：</p><blockquote><ul><li>VDD &#x3D; 2.0 to 3.6 V: external power supply for I&#x2F;Os and the internal regulator.<br>Provided externally through VDD pins.</li><li>VSSA, VDDA &#x3D; 2.0 to 3.6 V: external analog power supplies for ADC, DAC, Reset blocks,<br>RCs and PLL (minimum voltage to be applied to VDDA is 2.4 V when the ADC or DAC<br>is used). VDDA and VSSA must be connected to VDD and VSS, respectively.</li><li>VBAT &#x3D; 1.8 to 3.6 V: power supply for RTC, external clock 32 kHz oscillator and backup<br>registers (through power switch) when VDD is not present.</li></ul></blockquote><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p11.png" alt="电源电路"></p><p>从官方的电路图可知：</p><ul><li><p>每个VDD各接一个100nF陶瓷电容，其中VDD3需要再接一个4.7uF的钽电容；</p></li><li><p>VDDA：接10nF陶瓷电容+1uF钽电容；</p></li><li><p>VREF+：可接VDDA，也可接外部参考源，此时也需要接10nF陶瓷电容+1uF钽电容；</p></li></ul><p>在这里，我选择了最常用的3.3V。</p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p2.png" alt="滤波电容"></p><h2 id="电源设计"><a href="#电源设计" class="headerlink" title="电源设计"></a>电源设计</h2><p>我们用电池给PCB板供电，电池电压可能是3.7V、7.4V或者是12V的。然而，板上的元器件需要的供电电压，可能与外部电源电压不符。比如，单片机往往需要3.3V供电，一些超声波传感器需要5V供电，有些电机还需要12V供电。这样就要求我们，通过<code>设计升压、降压或者升降压电路</code>，<code>变换外部电源输入</code>从而满足所有元器件的要求。这也就是这里所说的——电源设计。</p><ol><li>我们常使用线性稳压器(LDO)来完成电压的转换。这里使用的型号为me6206a33,3.3V固定输出，Iout&#x3D;300mA，Vin&#x3D;6V(Max)。<br>参考该元件的说明书，可以知道LDO的电路连接方式：</li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p10.png" alt="LDO电路连接"></p><ol start="2"><li>参考芯片手册中关于电源的说明：<blockquote><p>Power supply schemes</p><ul><li>VDD &#x3D; 2.0 to 3.6 V: <br>external power supply for I&#x2F;Os and the internal regulator.<br>Provided externally through VDD pins.</li><li>VSSA, VDDA &#x3D; 2.0 to 3.6 V: <br>external analog power supplies for ADC, DAC, Reset blocks,<br>RCs and PLL (minimum voltage to be applied to VDDA is 2.4 V when the ADC or DAC<br>is used). <br>VDDA and VSSA must be connected to VDD and VSS, respectively.</li><li>VBAT &#x3D; 1.8 to 3.6 V: power supply for RTC, external clock 32 kHz oscillator and backup<br>registers (through power switch) when VDD is not present.</li></ul></blockquote></li></ol><p>再结合官方给出的电源设计图，可知VDD为正，VSS为负，直接接在滤波电容上。</p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p11.png" alt="电源电路"></p><p>STM32的工作电压(VDD )为2.0～3.6V，通过内置的电压调节器提供所需的1.8V电源，当主电源VDD 掉电后，通过VBAT 脚为实时时钟(RTC)和备份寄存器提供电源。</p><table><thead><tr><th>VCC</th><th>电路的供电正电压</th><th>VDDD</th><th>芯片的工作数字正电压</th></tr></thead><tbody><tr><td>GND</td><td>电路的供电负电压</td><td>VSSD</td><td>芯片的工作数字正电压</td></tr><tr><td>VDD</td><td>芯片的工作正电压</td><td>VREF+</td><td>ADC基准参考正电压</td></tr><tr><td>VSS</td><td>芯片的工作负电压</td><td>VREF-</td><td>ADC基准参考负电压</td></tr><tr><td>VDDA</td><td>芯片的工作模拟正电压</td><td>VBAT</td><td>电池或其他电源供电</td></tr><tr><td>VSSA</td><td>芯片的工作模拟负电压</td><td>VEE</td><td>负电压供电</td></tr></tbody></table><ul><li><code>RTC电源管脚</code>为VBAT, 电源范围为1.8~3.6V，主要用于RTC时钟的供电， RTC在大部分场合用于保存一些重要的参数，比如在电脑主板上用于保存boss的信息， 如果这个电源丢了将导致无法重启，在单片机中低功耗设备常常也会使用这个RTC进行定时的唤醒功能，在普通的MCU中常用于做实时时钟。</li><li><code>VDD</code>为数字电源，电源范围也是1.8~3.6V，在芯片内部集成了电压转化器，一般芯片内核供电为1.2V，图示的Regulator为转换器，将VDD电源稳压至1.2V。数据手册建议加入11个100nF和4.7uF的电容，不过实际应用中，只需要每个VDD加入一个100nF的去耦电容。</li><li><code>ADC和DAC</code>:模拟电源部分，V_DDA的电源用于芯片模拟器件，PLL锁相环等供电，还用于ADC和DAC模数数模转化器供电，图示的VREF为ADC和DAC的参考电压，在一些常用的设计中，可将这个参考电源直接与VREF相连接，但是在一些微弱信号的模拟电路中，建议接一个<code>电压基准芯片</code>，以确保参考<code>电压的稳定</code>。<ul><li>数据手册建议VDDA加入一个10nF和1uF的电容， 在这我们使用<code>10uF+100nF</code>的电容，而VREF也是建议使用10nF+1uF，我们还是采用10uF+100nF。</li><li><code>ADC(模数转换器)</code><br>  STM32F103系列嵌入了三个12位模数转换器，ADC可由DMA控制器提供服务，模拟看门狗功能可以精确地<code>监视所有选定通道的转换电压</code>，当转换后的电压超过设定的阈值后，将产生中断。</li><li><code>DAC(数模转换器)</code><br>  STM32F103系列提供二个12位缓冲DAC通道，可用于将两个数字信号转换为两个模拟电压信号输出，设计结构有集成电阻串和反向配置的放大器组成。</li></ul></li></ul><h3 id="独立的A-D转换器供电和参考电压"><a href="#独立的A-D转换器供电和参考电压" class="headerlink" title="独立的A&#x2F;D转换器供电和参考电压"></a>独立的A&#x2F;D转换器供电和参考电压</h3><p>为了提高转换的精确度，ADC使用一个独立的电源供电，过滤和屏蔽来自印刷电路板上的毛刺干扰，ADC的电源引脚为VDDA，独立的电源地VSSA，如果有VREF- 引脚(根据封装而定)，它必须连接到VSSA，确保共地。</p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p15.png" alt="ADC独立供电"></p><h3 id="电池备份区域"><a href="#电池备份区域" class="headerlink" title="电池备份区域"></a>电池备份区域</h3><p>使用电池或其他电源连接到VBAT 脚上，当VDD 断电时，可以保存备份寄存器的内容和维持RTC的功能。</p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p14.png" alt="电池备份区域"></p><h2 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h2><ol><li>芯片中复位电路的引脚为<code>NRST</code>,查看芯片手册中的“<code>NRST pin characteristics</code>”,原文说明：<blockquote><p>The NRST pin input driver uses CMOS technology. It is connected to a permanent pull-up<br>resistor, RPU (see Table 49).<br>Unless otherwise specified, the parameters given in Table 52 are derived from tests<br>performed under ambient temperature and VDD supply voltage conditions summarized in<br>Table 10</p></blockquote></li></ol><p>可知，默认该引脚上拉，摁下复位按键的时候，连接低电平。</p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p0.png" alt="NRST的输入电位要求"></p><p>一般来说，我们接GND和VCC，都能满足NRST的输入电位要求。</p><ol start="2"><li>在复位电路的设计中，添加了一个电容，作用为<code>按键消抖</code>：<br>由于电容两端电压不能突变，使得按键两端的电压平缓变化，直至电容充放电到达一定电压阈值时，单片机才读取到电平变化。<br><a href="https://blog.csdn.net/yechongbinbin/article/details/114821661">单片机按键消抖及原理（硬件和软件方法详解）</a></li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p4.png" alt="NRST复位电路"></p><h2 id="时钟电路-外部晶振"><a href="#时钟电路-外部晶振" class="headerlink" title="时钟电路(外部晶振)"></a>时钟电路(外部晶振)</h2><ol><li><p>stm32主控芯片的内部是有两个时钟的，分别是内部高速和内部低速，但是一般不会特别精准，所以需要外接时钟电路。</p></li><li><p>外接时钟电路，一般高速晶振的频率是8 MHZ，通过倍频器可以达到72 MHZ。低速晶振的频率是32.768KHZ。</p></li></ol><ul><li>36.768KHZ是2的15次方，是可以分频到最小单位HZ的。</li></ul><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p5.png" alt="高速外部晶振"></p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p6.png" alt="低速外部晶振"></p><ol start="3"><li>芯片手册提供了高速外部晶振的典型电路：</li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p7.png" alt="高速外部晶振典型电路"></p><blockquote><p>For CL1 and CL2, it is recommended to use high-quality external ceramic capacitors in the<br><code>5 pF to 25 pF</code> range (typ.), designed for high-frequency applications, and selected to match<br>the requirements of the crystal or resonator (see Figure 20). CL1 and CL2 are usually the<br>same size. The crystal manufacturer typically specifies a load capacitance which is the<br>series combination of CL1 and CL2. PCB and MCU pin capacitance must be included (<code>10 pF can be used as a rough estimate of the combined pin and board capacitance</code>) when sizing<br>CL1 and CL2. </p></blockquote><p>官方给出了两个电容的大小范围，只要在<code>5 pF to 25 pF</code> range (typ.)之间应该不会有什么问题，更严谨一点，可以参考官方给的计算公式：</p><blockquote><p>Note: For CL1 and CL2, it is recommended to use high-quality ceramic capacitors in the 5 pF to 15 pF range selected to match the requirements of the crystal or resonator (see Figure 21).<br> <code>CL1 and CL2, are usually the same size</code>. The crystal manufacturer typically specifies a load<br>capacitance which is the series combination of CL1 and CL2.</p></blockquote><blockquote><p>Load capacitance CL has the following formula: <code>CL = CL1 x CL2 / (CL1 + CL2) + Cstray </code>where<br>Cstray is the pin capacitance and board or trace PCB-related capacitance. Typically, it is<br>between 2 pF and 7 pF.</p></blockquote><blockquote><p>Caution: To avoid exceeding the maximum value of CL1 and CL2 (15 pF) it is strongly recommended to use a resonator with a load capacitance CL ≤ 7 pF. Never use a resonator with a load capacitance of 12.5 pF.</p><blockquote><p>警告: 为了避免超过 CL1和 CL2(15pF)的最大值，强烈建议使用使用负载电容 CL ≤7pF 的谐振器。永远不要使用负载的谐振器电容为12.5 pF。</p></blockquote></blockquote><blockquote><p>Example: if you choose a resonator with a load capacitance of CL &#x3D; 6 pF, and Cstray &#x3D; 2 pF,<br>then CL1 &#x3D; CL2 &#x3D; 8 pF</p><blockquote><p>如果你选择一个谐振器，其负载电容为 CL &#x3D; 6pF，而 Cstray &#x3D; 2pF,<br>那么 CL1 &#x3D; CL2 &#x3D; 8pF.</p></blockquote></blockquote><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p8.png" alt="无源晶振"></p><p>图中的20pF是CL，也就是负载电容的值，高速晶振的Cstray，官方给的估计值为10pF，带入公式计算CL1和CL2，可求出二者电容均为20pF。</p><p>同理，可以绘制外部低速晶振电路。</p><ol start="4"><li>主控芯片给了两组外部时钟电路的引脚，其中：</li></ol><ul><li><code>OSC_IN</code>和<code>OSC_OUT</code>分别为外部高速时钟的引脚</li><li><code>OSC32_IN</code>和<code>OSC32_OUT</code>分别为外部低速时钟的引脚</li></ul><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p9.png" alt="外部晶振电路"></p><h2 id="串口转USB"><a href="#串口转USB" class="headerlink" title="串口转USB"></a>串口转USB</h2><h3 id="CH340"><a href="#CH340" class="headerlink" title="CH340"></a>CH340</h3><ol><li>CH340 是一个 USB 总线的转接芯片，实现 USB 转串口或者 USB 转打印口。<br> 在串口方式下，CH340 提供常用的 MODEM 联络信号，用于为计算机扩展异步串口，或者将普通的串口设备直接升级到 USB 总线。</li><li>我选择的是SOP-8 封装，标准的 8 脚贴片，型号为CH340N。</li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p16.png" alt="CH340的引脚介绍1"></p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p17.png" alt="CH340的引脚介绍2"></p><ul><li>两个芯片的串口接线就是RX和TX反着对应，发对收。</li></ul><h3 id="USB接口"><a href="#USB接口" class="headerlink" title="USB接口"></a>USB接口</h3><ol><li>USB接口的版本：</li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p18.png" alt="USB 传输标准与接口"></p><h3 id="Type-C"><a href="#Type-C" class="headerlink" title="Type C"></a>Type C</h3><ol><li>Type C是一组对称的连接器，在使用的过程中不需要如同使用 USBA，MinUSB，MicroUSB 那样来辨别接口方向。<br>特点：</li></ol><ul><li>①可盲插、无方向性</li><li>②PD最大支持功率100W（20V&#x2F;5A）</li><li>③单组最高速率支持10Gbps。</li><li>④能够给不同电压的设备充电。</li></ul><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p19.png" alt="USB Type C 母口"></p><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p20.png" alt="USB Type C 公口"></p><p>从上图的 Type C 公头和母口的引脚排列可以知道 Type C 的引脚功能是上下对称的，所以公头无论以什么方向接入母口两者的功能引脚都可以完美对接。</p><ol start="2"><li>具体引脚，及其详细描述查看如下表格：</li></ol><table><thead><tr><th align="center">Pin</th><th align="center">名称</th><th align="center">功能描述</th><th align="center">Pin</th><th align="center">名称</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">A1</td><td align="center">GND</td><td align="center">接地</td><td align="center">B12</td><td align="center">GND</td><td align="center">接地</td></tr><tr><td align="center">A2</td><td align="center">SSTXp1</td><td align="center">SuperSpeed 差分信号<code>#1</code>，TX，正</td><td align="center">B11</td><td align="center">SSRXp1</td><td align="center">SuperSpeed 差分信号<code>#1</code>，RX，正</td></tr><tr><td align="center">A3</td><td align="center">SSTXn1</td><td align="center">SuperSpeed 差分信号<code>#1</code>，TX，负</td><td align="center">B10</td><td align="center">SSRXn1</td><td align="center">SuperSpeed 差分信号<code>#1</code>，RX，负</td></tr><tr><td align="center">A4</td><td align="center">VBUS</td><td align="center">总线电源</td><td align="center">B9</td><td align="center">VBUS</td><td align="center">总线电源</td></tr><tr><td align="center">A5</td><td align="center">CC1</td><td align="center">Configuration channel</td><td align="center">B8</td><td align="center">SBU2</td><td align="center">Sideband use (SBU)</td></tr><tr><td align="center">A6</td><td align="center">Dp1</td><td align="center">USB 2.0 差分信号，position 1，正</td><td align="center">B7</td><td align="center">Dn2</td><td align="center">USB 2.0 差分信号，position 2，负</td></tr><tr><td align="center">A7</td><td align="center">Dn1</td><td align="center">USB 2.0 差分信号，position 1，负</td><td align="center">B6</td><td align="center">Dp2</td><td align="center">USB 2.0 差分信号，position 2，正</td></tr><tr><td align="center">A8</td><td align="center">SBU1</td><td align="center">Sideband use (SBU)</td><td align="center">B5</td><td align="center">CC2</td><td align="center">Configuration channel</td></tr><tr><td align="center">A9</td><td align="center">VBUS</td><td align="center">总线电源</td><td align="center">B4</td><td align="center">VBUS</td><td align="center">总线电源</td></tr><tr><td align="center">A10</td><td align="center">SSRXn2</td><td align="center">SuperSpeed 差分信号<code>#2</code>，RX，负</td><td align="center">B3</td><td align="center">SSTXn2</td><td align="center">SuperSpeed 差分信号<code>#2</code>，TX，负</td></tr><tr><td align="center">A11</td><td align="center">SSRXp2</td><td align="center">SuperSpeed 差分信号<code>#2</code>，RX，正</td><td align="center">B2</td><td align="center">SSTXp2</td><td align="center">SuperSpeed 差分信号<code>#2</code>，TX，正</td></tr><tr><td align="center">A12</td><td align="center">GND</td><td align="center">接地</td><td align="center">B1</td><td align="center">GND</td><td align="center">接地</td></tr></tbody></table><ul><li>有24根信号，其中电源和地占了9根，有4个地和4个Vbus，用于提升电流传输能力。</li><li>A6、A7：用于传输USB2.0的两组信号是交叉连接的，所以会使得插头以任意方向插入时数据都是连通的。</li><li>A2、A3，A10、A11：有两组（8根）高速数据通路，用于传输数据</li><li>CC1、CC2：用于传输方向确认和正反插确认，以及USB PD BCM码信号传输功能，实现负载的功能配置，当其中一根作为TypeC接口的配置信号时，另一根则变成供电电源。（SUB1\SUB2作为辅助信号，在一些特殊模式下使用）。</li></ul><ol start="3"><li>我在选择type-c接口的时候，选择了16脚的，因为6脚的只能充电。</li></ol><ul><li><p><code>16Pin Type C</code> 在 24Pin 全功能版本的基础上移除了 USB3.0 的 TX1&#x2F;2、RX1&#x2F;2 引脚，保留了 SBU1&#x2F;2、CC1&#x2F;2、USB2.0 的 D+ 和 D- 引脚，除了不支持 USB3.0&#x2F;3.1 高速传输外，其他没有任何的差别，同样可以支持 PD 快充、音频传输、HDMI 传输、调试模式等其他功能。</p><ul><li><code>16 Pin Type C </code>实际上仅有12 Pin，这是因为 16 Pin 接口在设计时将 Type C 母口两端的两个 <code>Vbus 和 GND</code> 引脚两两相互靠近，注意仅仅是相互靠近并不是共用引脚所以接口实际还是存在 16 Pin，但对于<code>其封装只要 12 Pin</code>，其中<code>相互靠近的引脚共用一个封装引脚</code>，具体可以看下图的实物图。</li></ul></li><li><p>对于仅需支持充电，那么 USB2.0 D+ 和 D- 引脚也可移除进一步节约接口制造成本。<code>6Pin Type C </code>仅保留Vbus、GND、CC1、CC2 引脚。接口两侧同样对称分布 Vbus 和 GND ，CC1，CC2 引脚用于支持正反接入，以及快充协议的支持</p></li></ul><h4 id="DFP、UFP、DRP用途解析"><a href="#DFP、UFP、DRP用途解析" class="headerlink" title="DFP、UFP、DRP用途解析"></a>DFP、UFP、DRP用途解析</h4><ul><li>①DFP：下行端口，可以理解为一个Host，DFP作为source给VBUS和vcon供电的，简单理解为一个提供电源的设备，如：电源适配器。</li><li>②UFP：上行端口，可以理解为Device，UFP可以理解为受电端口，DFP为供电端口，UFP从VBUS中取电，并可提供数据。典型设备如：U盘、移动硬盘。</li><li>③DRP：双角色端口，DRP既可以做DFP又可以做UFP，也可以在DFP和UFP间动态切换，典型设备是：笔记本电脑。</li></ul><h4 id="Type-C-接口-CC1-2-作用"><a href="#Type-C-接口-CC1-2-作用" class="headerlink" title="Type C 接口 CC1&#x2F;2 作用"></a>Type C 接口 CC1&#x2F;2 作用</h4><blockquote><p>PD 快充协议对电源设备的识别通过 CC1 和 CC2 引脚来进行，避免 QC 协议中 对 DP 和 DM 引脚的占用。使得 PD 协议快充在充电的同时，数据传输也可以稳定进行。</p></blockquote><p><code>CC：配置通道</code>，作用是检测USB连接，检测正反插，USB设备间数据与VBUS的连接建立与管理。</p><ul><li>探测连接，区分正反面，区分DFP和UFP的主从关系。</li><li>配置Vbus，有USB TypeC和USB Power Delivery两种模式。</li><li>配置Vconn，当线缆里有Emark芯片的时候，一路CC通道传输CC信号，另一路CC通道变成Vconn，给EMark芯片供电。<ul><li>如果CC通道连接其他配置，如连接音频配件、DP、PCIE时，CC通道配置是不同的。</li></ul></li></ul><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p21.png" alt="TypeC的CC通道连接图"><br>上图分析：</p><ul><li>在DFP的CC pin有<code>上拉电阻Rp</code>，在UFP有<code>下拉电阻Rd</code>。</li><li>在未连接时，DFP的VBUS是无输出的，连接后CC pin相连，DFP的CC pin会检测到UFP的下拉电阻Rd，说明连接上了，DFP就打开Vbus电源开关，输出电源给UFP。而哪个CC pin（CC1、CC2）检测到下拉电阻就确定接口插入的方向，顺便切换RX\TX。</li><li>电阻Rd&#x3D;5.1k，电阻Rp为不确定的值，USB TypeC有几种<code>供电模式，靠Rp</code>的值来甄别，Rp的值不一样，CC pin检测的电源就不一样，然后来控制DFP端执行哪种供电模式。</li></ul><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p22.png" alt="DFP端执行的供电模式"></p><p><a href="https://blog.csdn.net/qq_43533553/article/details/124973694">CC识别模式</a></p><h3 id="SWIO和SWCLK引脚"><a href="#SWIO和SWCLK引脚" class="headerlink" title="SWIO和SWCLK引脚"></a>SWIO和SWCLK引脚</h3><ol><li>SWIO和SWCLK分别是JTAG接口中用于<code>数据引脚</code>和<code>时钟引脚</code>的信号线。在STM32F103C8T6芯片中，它们通常用于调试和测试，以便开发人员可以检查芯片中各种模块的状态和执行跟踪。它们也可用于编程和其他与芯片的内部工作有关的操作。</li><li>PA13的引脚就是SWIO的引脚。</li></ol><h1 id="PCB布局和飞线"><a href="#PCB布局和飞线" class="headerlink" title="PCB布局和飞线"></a>PCB布局和飞线</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ol><li>外部晶振的滤波电容要靠近外部晶振，外部晶振要靠近主控芯片</li><li>参考入门笔记里面的布局和飞线原则</li><li>3D视图可以查看成品效果</li></ol><p><img src="/images/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF/p23.jpg" alt="成品效果1.0"></p><h1 id="第一次画板子存在的问题和后续优化的安排"><a href="#第一次画板子存在的问题和后续优化的安排" class="headerlink" title="第一次画板子存在的问题和后续优化的安排"></a>第一次画板子存在的问题和后续优化的安排</h1><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol><li>滤波电容要靠近电流流入的io口</li><li>排针的顺序分布要按着芯片引脚的实际顺序来，不要按着顺序从A0直接到A15，布线太痛苦了，而且很丑很不优雅</li><li>晶振越接近芯片引脚越好</li><li>晶振和电源模块还可以选择更小的封装</li><li>type-c的四个固定脚要焊上，不然容易掉</li><li>电流线20mils以上，信号线10mils也ok</li></ol><h1 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h1><ol><li>开学后，重新做一下stm32的最小系统板</li><li>逐步摸索stm32的其他模块，扩大板子的功能</li><li>同时跟上学电控，了解板子的使用，以及学会使用成品板</li><li>学一下有刷电机和无刷电机，画驱动四轮正反转的板子</li><li>学一下通信部分怎么画</li></ol>]]></content>
    
    
    <categories>
      
      <category>硬件方向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PCB设计项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCB设计入门笔记</title>
    <link href="/2024/02/12/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/12/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>使用立创EDA进行简单的PCB设计</p><span id="more"></span> <h1 id="基础入门知识"><a href="#基础入门知识" class="headerlink" title="基础入门知识"></a>基础入门知识</h1><h2 id="一些软件"><a href="#一些软件" class="headerlink" title="一些软件"></a>一些软件</h2><ul><li>Autun Designer(适合复杂工程以及工作使用)</li><li>立创EDA (国内软件，更简单易学)</li><li>Multisim ：主要是做电路仿真(原理图)</li></ul><h2 id="元件封装"><a href="#元件封装" class="headerlink" title="元件封装"></a>元件封装</h2><p>元件封装，简单的说，一是指<code>元件的包装方式</code>，二是指<code>元件的焊盘形状与尺寸</code>。<br>在绘制PCB板的时候，首先要保证元件封装绘制正确，否则元件很可能无法焊接到成品板上。</p><p>不同的厂家生产的各类元器件的形状、尺寸上都有较大的差异，因此元件的封装也有很多不同的形式。但是总体而言，目前的封装主要分为两类。一类是<code>直插式</code>，一类是<code>贴片式</code>。另外，详细划分，又可以划分为以下多类：</p><ul><li>SOP&#x2F;SOIC封装：Small outline package 小外形封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p1.png" alt="SOP/SOIC封装"></p><ul><li>PLCC封装：Plastic leaded chip charrier 塑料J引线芯片封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p2.png" alt="PLCC封装"></p><ul><li>QFP封装：Quid flat package 四侧引脚扁平封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p3.png" alt="QFP封装"></p><ul><li>QFN封装：Quid flat non-leaded 四侧无引脚扁平封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p4.png" alt="QFN封装"></p><ul><li>BGA封装：Ball grid array package 球栅阵列封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p5.png" alt="BGA封装"></p><ul><li>CSP封装：Chip scale package 芯片级封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p6.png" alt="CSP封装"></p><ul><li>SIP封装：Single in-line package 单列直插封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p7.png" alt="SIP封装"></p><ul><li>DIP封装：Double in-line package 双列直插封装</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p8.png" alt="DIP封装"></p><h2 id="基础元件"><a href="#基础元件" class="headerlink" title="基础元件"></a>基础元件</h2><ol><li><p><code>电阻</code>比较简单，通常使用到的都是贴片电阻。</p></li><li><p><code>电容</code>复杂一些，常用的类型有：陶瓷电容、电解电容等。</p></li></ol><ul><li>陶瓷电容属于<code>无极性电容</code>，通常有X7R电容和Y5V电容两种，个头都比较小。<ul><li>一般而言，陶瓷电容的容值都比较小，而电解电容的容值更大。</li></ul></li><li>电解电容是<code>有极性电容</code>，包括铝电解电容、钽电解电容（坦电容）等。<ul><li>另外，铝电解电容的个头一般很大，且是直插式封装；而坦电容个头较小，贴片封装。 原理图中，有些电容旁边带有<code>+号</code>，这就代表了有极性电容。</li></ul></li></ul><ol start="3"><li><code>电感</code>常用的是贴片叠层电感和贴片功率电感。</li></ol><ul><li>贴片叠层电感体积很小，而<code>贴片功率电感</code>体积稍大，更适合<code>大电流、高感值</code>的场合。</li></ul><ol start="4"><li><p><code>磁珠</code>实际上是单匝的线圈，也可以说是单匝电感，其电感量很小。专用于<code>抑制信号线、电源线上的高频噪声和尖峰干扰</code>。</p></li><li><p><code>二极管</code>比较常用的是<code>LED灯二极管</code>、<code>肖特基二极管</code>。</p></li></ol><ul><li>肖特基二极管： 具有低正向压降和非常快速的开关动作的半导体二极管</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p9.png" alt="肖特基二极管电路符号"></p><ol start="6"><li><code>三极管</code>常用的有三极管和场效应管（MOS管）。</li></ol><ul><li><code>三极管</code>是<code>电流控制元件</code>，分为PNP和NPN两类，三极分别为基极、发射极、集电极。* <code>MOS管</code>是<code>电压控制元件</code>，分为P沟道和N沟道两类，另一种分法是增强型和绝栅型，三极分别为栅极、源极、漏极。</li></ul><h2 id="数字0402、0603代表什么"><a href="#数字0402、0603代表什么" class="headerlink" title="数字0402、0603代表什么"></a>数字0402、0603代表什么</h2><p>这些数字指的是电阻、电容、电感等贴片元件的封装大小。</p><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p10.png" alt="封装尺寸说明"></p><h2 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h2><p>石英晶体振荡器是利用石英晶体的<code>压电效应</code>制成的一种<code>谐振</code>器件.</p><ol><li>它的基本构成大致是：从一块石英晶体上按一定方位角切下薄片，在它的两个对应面上涂敷银层作为电极，在每个电极上各焊一根引线接到管脚上，再加上封装外壳就构成了石英晶体谐振器，简称为石英晶体或晶体、晶振。其产品一般用金属外壳封装，也有用玻璃壳、陶瓷或塑料封装的。</li><li>压电效应：若在石英晶体的两个电极上加上一电场，晶片就会产生机械变形。反之，若在晶片的两侧施加机械压力，则在晶片相应的方向上将产生电场，这种物理现象称为压电效应。</li><li>晶体的等效阻抗具有<code>串联谐振</code>，其中Cs在晶体工作频率下与电感Ls谐振。该频率称为晶体系列频率ƒs。除了这个串联频率之外，当Ls和Cs与并联电容器Cp谐振时产生<code>并联谐振</code>，如下图所示。</li></ol><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p.png" alt="晶振频率"></p><ol start="4"><li><code>晶振的作用</code>:在各种电路中，产生震荡频率,为系统提供基本的时钟信号。（频率越高，单片机运行的速度越快）</li></ol><ul><li>通常一个系统共用一个晶振，便于各部分保持同步。有些通讯系统的基频和射频使用不同的晶振，而通过电子调整频率的方法保持同步。</li><li>CPU和单片机都是以周期为最小工作单位的。例如给CPU一个1秒的方波，为了给CPU一个11111111的信号，但是CPU怎么分辨这是一个1还是八个1，依靠的就是周期，周期的确定，就是依靠的晶振和震荡电路实现的。</li></ul><ol start="5"><li><code>晶振的分类</code>： <br>晶体振荡器也分为<code>无源晶振</code> 和<code>有源晶振</code>两种类型。<br>无源晶振与有源晶振（谐振）的英文名称不同，无源晶振为crystal（晶体），而有源晶振则叫做oscillator（振荡器）。</li></ol><ul><li>无源晶振需要借助于时钟电路才能产生振荡信号，自身无法振荡起来，所以“无源晶振”这个说法并不准确（需要外围电路、成本低）。</li><li>有源晶振是一个完整的谐振振荡器。<code>石英晶体振荡器</code>与<code>石英晶体谐振器</code>都是提供稳定电路频率的一种电子器件（自带振荡，真正意义上的晶振，成本较高，稳定性强）。<ul><li>石英晶体振荡器是利用石英晶体的压电效应来起振，而石英晶体谐振器是利用石英晶体和内置IC共同作用来工作的。</li><li>振荡器直接应用于电路中，谐振器工作时一般需要提供3.3V电压来维持工作。</li><li>振荡器比谐振器多了一个重要技术参数：谐振电阻（RR），谐振器没有电阻要求。RR的大小直接影响电路的性能，因此这是各商家竞争的一个重要参数。</li></ul></li></ul><h2 id="电源设计"><a href="#电源设计" class="headerlink" title="电源设计"></a>电源设计</h2><p>电源，指的就是给PCB板供电的电源。</p><p>实际应用中常会遇到这种情况：我们用电池给PCB板供电，电池电压可能是3.7V、7.4V或者是12V的。然而，板上的元器件需要的供电电压，可能与外部电源电压不符。比如，单片机往往需要3.3V供电，一些超声波传感器需要5V供电，有些电机还需要12V供电。这样就要求我们，通过<code>设计升压、降压或者升降压电路</code>，<code>变换外部电源输入</code>从而满足所有元器件的要求。这也就是这里所说的——电源设计。</p><p>通常PCB设计中使用的电源有两类：<code>开关电源</code>和<code>线性电源</code>。（这里主要说直流电源）</p><ul><li><p>开关电源，优势在于效率高。但是其有纹波，外围电路复杂，体积大，设计比较困难。通常包括有，升压（Boost）、降压（Buck）、升降压（Buck-Boost）和反相等电路。</p></li><li><p>线性电源，优势在于外围电路简单，体积小，纹波很小。但是效率低、发热严重。一般而言，线性电源只能做降压，而不能升压，降压的那一部分全都化作发热耗散掉了，所以效率低。</p><ul><li>另外，还有一类线性电源叫做LDO（低压差线性稳压器），它的特点是可以在降压压差很低的情况下使用。</li></ul></li></ul><p>如果要从头设计一个开关电源，需要把电源芯片的文档看得很熟，然后按照其计算方法，把用到的电阻阻值、电感感值、电容容值都计算出来。</p><p>开关电源文档上都会有典型应用，平时多看文档说明书，学会借鉴。</p><h2 id="VCC、VDD和VSS"><a href="#VCC、VDD和VSS" class="headerlink" title="VCC、VDD和VSS"></a>VCC、VDD和VSS</h2><ol><li>解释 ：</li></ol><ul><li>VCC：C&#x3D;circuit 表示电路的意思, 即<code>接入电路的电压</code>；</li><li>VDD：D&#x3D;device 表示器件的意思, 即<code>器件内部的工作电压</code>； </li><li>VSS：S&#x3D;series 表示公共连接的意思，通常指<code>电路公共接地端电压</code>。</li></ul><ol start="2"><li>说明</li></ol><ul><li>对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压（通常Vcc&gt;Vdd），VSS是接地点。 </li><li>有些IC既有VDD引脚又有VCC引脚，说明这种器件自身带有电压转换功能。 </li><li>在场效应管（或COMS器件）中，VDD为漏极，VSS为源极，VDD和VSS指的是元件引脚，而不表示供电电压。</li></ul><h1 id="封装实践"><a href="#封装实践" class="headerlink" title="封装实践"></a>封装实践</h1><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p11.png" alt="封装模式的选择"></p><p>在嘉立创EDA专业版中支持2种符号库管理：</p><ul><li>简易模式： 与标准版建库兼容</li><li>专业模式： 支持更多复用功能</li></ul><h2 id="简易模式：建立0603大小的贴片电阻器件"><a href="#简易模式：建立0603大小的贴片电阻器件" class="headerlink" title="简易模式：建立0603大小的贴片电阻器件"></a>简易模式：建立0603大小的贴片电阻器件</h2><p>点击<code>新建器件</code>，命名符合规范：R0603,R表示电阻，0603为尺寸规则。</p><p>这里的分类是元器件的分类，起初默认没有，需要自己新建。根据需要添加描述。</p><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/0.png" alt="设置"></p><p>再点击保存，进入器件的编辑页面。</p><h3 id="新建元器件"><a href="#新建元器件" class="headerlink" title="新建元器件"></a>新建元器件</h3><ul><li>位号修改为R，因为我们的器件是电阻。</li><li>开始新建电阻的符号（中间是矩形，两侧引脚引出），先将<code>格点尺寸固定为0.05</code></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p12.png" alt="基础设置"></p><ul><li>点击<code>放置</code>，绘制一个<code>矩形</code>，调整为合适的大小，再放置两个引脚，<code>摁空格键进行旋转</code>，Ctrl+S保存。</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p13.png" alt="新建元器件"></p><h3 id="新建封装"><a href="#新建封装" class="headerlink" title="新建封装"></a>新建封装</h3><p>点击<code>文件-新建-封装</code></p><ul><li>命名仍为R0603,分类表示是封装的分类，描述按需要填写。</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/1.png" alt="封装分类"></p><ul><li><p>点击保存，进入封装界面。</p></li><li><p>封装的大小直接决定实物能否成功焊接，需要按照厂商的数据手册进行设计。</p></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/2.png" alt="电阻封装数据手册"></p><ul><li>放置一个焊盘，选择图层为<code>顶层</code>，形状为<code>矩形</code>,根据数据手册的封装尺寸设置<code>长和宽</code>。数据手册的焊盘有两个，因此复制一下，修改一下焊盘编号，要求<code>焊盘编号和引脚的编号一一对应</code>。</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/3.png" alt="电阻封装数据手册"></p><ul><li><p>点击<code>工具-智能尺寸</code>，设置两个焊盘之间的间距。之后退出智能尺寸，这样焊盘就绘制完成了。</p></li><li><p>选择图层为<code>顶层丝印层</code>，放置<code>线条-折线</code>,绘制边框用于提示作用，再Ctrl+S保存。</p></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/22.png" alt="电阻封装绘制"></p><h3 id="绑定到个人库"><a href="#绑定到个人库" class="headerlink" title="绑定到个人库"></a>绑定到个人库</h3><p>回到符号编辑器页面，选择<code>封装-个人-电阻-R0603-确认</code>进行绑定。</p><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/222.png" alt="绑定到个人库"></p><ul><li>更新3D模型：目前嘉立创不支持用户自己绘制3D模型，可以直接在系统中搜索相同尺寸的模型更新。</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/4.png" alt="更新3D模型"></p><h3 id="在工程中使用个人库中的封装电阻"><a href="#在工程中使用个人库中的封装电阻" class="headerlink" title="在工程中使用个人库中的封装电阻"></a>在工程中使用个人库中的封装电阻</h3><p>在自己的工程中，点击下方的库，选择个人，找到R0603电阻封装，点击放置即可。</p><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p14.png" alt="在工程中使用个人库中的封装电阻"></p><h2 id="专业模式：建立贴片LM393封装元器件"><a href="#专业模式：建立贴片LM393封装元器件" class="headerlink" title="专业模式：建立贴片LM393封装元器件"></a>专业模式：建立贴片LM393封装元器件</h2><ul><li>先切换为专业模式，然后新建器件，器件分类需要新建<code>比较器</code>，保存进入器件编辑界面。</li><li>专业模式下还需要对符号分类进行设置，新建<code>比较器</code>符号分类。</li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p15.png" alt="新建器件设置"></p><ul><li><p>新建符号：打开LM393数据手册，然后在界面中点击<code>向导</code>，选择类型为DIP，左右引脚均为4，其余参数默认，点击<code>生成符号</code>。</p></li><li><p>根据数据手册中的引脚设置，编辑器件的引脚标签。</p></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/5.png" alt="新建符号"></p><h2 id="如果引脚很多切由多个独立部分组成，可以分离设计封装"><a href="#如果引脚很多切由多个独立部分组成，可以分离设计封装" class="headerlink" title="如果引脚很多切由多个独立部分组成，可以分离设计封装"></a>如果引脚很多切由多个独立部分组成，可以分离设计封装</h2><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/55.png" alt="LM393数据手册"></p><ul><li>切换最小间隔为0.05mm，用折线绘制符号。两个独立的部件分开绘制，然后保存。</li></ul><center class="half"><img src="/images/PCB设计入门笔记/p17.png" width="300/"><img src="/images/PCB设计入门笔记/p18.png" width="300/"></center><ul><li>新建封装：点击<code>文件-新建-封装</code>，命名为SOP-8（这个是LM393厂家采用的封装规格），同样新建<code>比较器</code>的封装类，进入封装设计界面。根据数据手册的封装尺寸要求，绘制封装。</li></ul><p> <img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p19.png" alt="LM393数据手册"></p><ul><li><p>在原点处放置一个焊盘，顶层，长圆形。一般绘制的时候，这种多引脚的器件，焊盘需要<code>比既定尺寸扩大1.4倍</code>。</p></li><li><p>可以使用<code>底部对齐</code>快速对齐焊盘。</p></li><li><p>切换到顶层丝印层，绘制矩形，根据数据手册调整长宽。注意不要让丝印层和焊盘有接触，稍微调整一下。</p></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p20.png" alt="LM393封装绘制"></p><ul><li><p>这样做如果嫌麻烦，也可以点击向导，提供了许多封装规格，可一键生成。</p></li><li><p>绑定封装和3D模型，注意3D模型中搜索sop-8需要对齐小圆孔，顺序一致。</p></li><li><p>多部件单独设计时，原理图是独立分开的，一定要全部放上去，不要遗漏。</p></li></ul><p><img src="/images/PCB%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/p21.png" alt="LM393放置元器件"></p><h1 id="入门的第一块板子"><a href="#入门的第一块板子" class="headerlink" title="入门的第一块板子"></a>入门的第一块板子</h1><h2 id="原理图设计"><a href="#原理图设计" class="headerlink" title="原理图设计"></a>原理图设计</h2><ul><li>第一步：文件-新建工程</li><li>第二步：原理图设计</li><li>第三步：设计完原理图之后Ctrl+S保存，再点击<code>设计-原理图转PCB-Ctrl+S</code>保存PCB文件在工程文件中<br>  -修改原理图之后，可以<code>设计-更新PCB</code>，再保存一次</li></ul><h3 id="关于原理图设计的一些小tips"><a href="#关于原理图设计的一些小tips" class="headerlink" title="关于原理图设计的一些小tips"></a>关于原理图设计的一些小tips</h3><h4 id="制作元件库和封装库"><a href="#制作元件库和封装库" class="headerlink" title="制作元件库和封装库"></a>制作元件库和封装库</h4><p>这是绘制原理图的前期准备。这一步的重点是，需初步确定会用到的元器件，并且去淘宝上搜索这些元器件对应的封装与尺寸。一定要按搜到的尺寸绘制封装库，否则就算画出板子来，也可能买不到合适大小的元器件。</p><p>当然，能找到现成可用的库是最好的，就不用自己画了。嘉立创的库元件挺全的。</p><h4 id="画电路原理图"><a href="#画电路原理图" class="headerlink" title="画电路原理图"></a>画电路原理图</h4><p>对于初学者而言，这一步的关键在于<code>善于借鉴</code>！！！</p><p>想要实现什么功能，可以先到淘宝上搜这个功能对应的模块，然后看看能不能下载到它的资料，或者搞清楚它用的芯片，然后参考芯片的技术文档。最后，把模块资料里或是技术文档里的应用电路图搬过来就OK了。</p><h3 id="一些元件的知识："><a href="#一些元件的知识：" class="headerlink" title="一些元件的知识："></a>一些元件的知识：</h3><ul><li><p><code>端子</code>：用于供电，可以解决使用排针供电时，使用杜邦线容易松动导致供电的供电问题。</p><ul><li>一般板子设计的时候，端子供电和排针供电都加上。</li></ul></li><li><p>二极管：</p><ul><li>SS56：用于防止反接的二极管<br>  -不同的封装画出来的PCB效果就不一样，相同的封装，即使前面的型号不同，效果也是一样的。</li><li>1N4148：普通的二极管</li></ul></li><li><p>GND：在PCB设计中，板子接地特别重要，需要在供电的端子或者排针中留一个端给GND</p><ul><li>一个PCB板可以画多个板子，但是不同板子的接地不一样，一定要区分开<br>*基础库和元件库</li></ul></li><li><p>连接器：其实就是<code>排针</code>，可以选1×n的，表示一排n个针脚。</p></li><li><p><code>滤波电容</code>(电容，电阻一般用的都是<code>C0805</code>的贴片封装)</p><ul><li>贴片电容没有正负，直插的电容是有正负的</li><li>常用大小:100nF</li></ul></li><li><p><code>BWSMA</code>：信号线的接头，可以防止一些信号的干扰,作为信号的输入&#x2F;输出</p><ul><li>1,2,3,4头都是接地GND，5号头是接入电路的</li><li>一般会加一个排针，作为输出的planB，但是使用排针输入信号的时候，要注意单独再拿一个排针接地(BWSMA的铜皮已经考虑过接地了)</li></ul></li><li><p>运放：可以根据自己的电路选择不同的运放</p><ul><li><code>双运放</code>:一个封装里面有两个独立的运放，在原理图里面是两个分开的5脚运放，但是有两个虚拟的供电引脚，因为在实际双运放供电中，两个运放的供电是同一对引脚</li></ul></li></ul><h3 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h3><ol><li>鼠标左键选中元件，空格可以旋转元件</li><li>电气工具栏可以放置一些常用的工具，例如连接走线，网络标签啥的</li><li>软件使用时<code>shift+滚轮</code>是界面左右滑；<code>ctrl+滚轮</code>是界面上下滑；<code>直接滚轮</code>是界面放大缩小；<code>shift+s</code>是只显示当前层，再次shift+s就回来了</li><li>PCB工具栏是在PCB排版和飞线的时候常用的一些工具，比如过孔，焊盘</li></ol><h2 id="PCB走线"><a href="#PCB走线" class="headerlink" title="PCB走线"></a>PCB走线</h2><ol><li>关于层数：</li></ol><ul><li>顶层(红色)和底层(蓝色)都可以飞线，顶层的线和底层的线尽量避免平行走线,最好垂直布线，这样两层之间的走线影响最小<ul><li>焊盘才能走底层的飞线，否则就是打孔</li><li><code>过孔孔径</code>一般可选12，24</li></ul></li><li>顶层丝印层：打印一些文字批注，整一些二次花活啥的<ul><li><code>丝印不要遮挡焊盘</code>，另外丝印的作用主要是方便后期焊接找准元器件位置，所以要尽可能保持丝印清晰可见</li></ul></li><li>边框层：绘制板子的边框</li></ul><ol start="2"><li>元件布局，让飞线尽量少交叉</li></ol><ul><li><code>定位孔</code>：放焊盘或者大的过孔即可。<ul><li>常用的过孔尺寸:直径157.48 过孔内径：137.786</li></ul></li></ul><ol start="3"><li><code>视图-3D预览</code></li><li>步骤：</li></ol><ul><li><p>第一步：元件布局</p><ul><li><code>同一功能模块布局要尽量紧凑</code>。有些特殊的元器件，布局前最好<code>参考</code>其技术手册，使用其推荐的PCB布局方式（比如某些电源芯片或传感器芯片，这样可以提高应用性能）</li><li>发热大、电流大的元件要远离单片机</li></ul></li><li><p>第二步：边框层</p></li><li><p>第三步：飞线</p><ul><li>少打孔，少转弯，少直角，不同网格的线离远一点</li><li>线宽： <br>  电源:<code>30~50mil</code>（单片机等电流很小的器件的电源线可以细一点，16mil的线能过0.9A电流，单片机需要的不会超过0.2A）, <code>过孔</code>也要相应变大，可选25，50<br>  信号线:信号线宽10~15mil。一般是<code>11mil</code>。</li><li>信号线不要形成环路，如果必须有环路，那么越小越好 </li><li>对于细引脚来说，使用的线径最好在不超过引脚宽度的情况下尽可能宽。</li><li>布地线,地线不一定要全部布通，可以最后通过覆铜来把所有地导通</li></ul></li><li><p>第四步：设置<code>泪滴</code>，防止走线直角</p></li><li><p>第五步： 接地——<code>铺铜</code>：在PCB工具栏中。</p><ul><li>底层和顶层都铺，将其网络设置为GND层</li><li>点中铺铜的两个虚框，分别把<code>焊盘连接</code>选择改为<code>直连</code></li></ul></li></ul><h3 id="STM32："><a href="#STM32：" class="headerlink" title="STM32："></a>STM32：</h3><ol><li><p>晶振要尽可能离单片机近，尽可能保持接晶振的线等长平行</p></li><li><p>晶振下面不要过信号线</p></li><li><p>要接滤波电容。有几个VCC和GND就要接几个滤波电容，滤波电容尽量离单片机近</p></li><li><p>芯片下方可以走信号线，不用太担心</p></li></ol><h2 id="打板子"><a href="#打板子" class="headerlink" title="打板子"></a>打板子</h2><p>在嘉立创官网下载“下单助手”</p><ol><li>PCB文件设计完成后，Ctrl+S保存。点击<code>文件-生成PCB制板文件</code>，选择生成Gerber文件，保存在自己选择的路径下。</li><li>在嘉立创的下单助手APP中点击 <code>在线下单/计价</code>上传Gerber文件(zip无需解压)</li><li>每个月嘉立创会送两次免费打样,板子尺寸要求为10×10以内</li><li>可以导出<code>BOM表</code>，里面记录了这个板子需要的元件名称和数量</li></ol><p>注意：嘉立创的打样只是单纯的板子，<code>没有焊接任何元件</code>!!需要上淘宝买回来所有元器件的原料，自己手工焊板子。</p>]]></content>
    
    
    <categories>
      
      <category>硬件方向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PCB设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美赛论文学习笔记</title>
    <link href="/2024/01/31/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/31/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>一些优秀美赛论文的读后感和学习记录~</p><span id="more"></span> <h1 id="摘要学习"><a href="#摘要学习" class="headerlink" title="摘要学习"></a>摘要学习</h1><h2 id="1-规范的书写结构"><a href="#1-规范的书写结构" class="headerlink" title="1.规范的书写结构"></a>1.规范的书写结构</h2><ul><li>背景：一两句话对时代背景进行概括。</li><li>问题的引入，交代整体做了什么</li><li>按照<code>首先-其次-第三-第四-……-最后</code>的顺序，分别介绍 What we have done。介绍每个模型的名字(标黑),该模型的过程概括，解决了什么问题，求出的结果是什么(具体的数值)。</li><li>一般最后会让写一封建议信balabla的，最后一段几句话概括一下即可。</li></ul><h2 id="2-一些背景引入的写法学习："><a href="#2-一些背景引入的写法学习：" class="headerlink" title="2. 一些背景引入的写法学习："></a>2. 一些背景引入的写法学习：</h2><ul><li>23年C题：<blockquote><p>In the digital era, language is often conveyed through abbreviations, emojis, and voice messages.However, the Wordle game, provided by the New Y ork Times, offers a chance to return to the basics of language. Thus, we conducted a data analysis of the results yielded by Wordle.</p></blockquote></li></ul><h1 id="论文整体书写结构"><a href="#论文整体书写结构" class="headerlink" title="论文整体书写结构"></a>论文整体书写结构</h1><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h3><blockquote><p>1.1 Problem Background<br>1.2 Restatement of the Problem<br>1.3 预先工作</p><blockquote><p>eg. Data Cleaning</p></blockquote></blockquote><blockquote><p>1.4 Our work </p><blockquote><p>放一张整体建模的<code>流程图</code></p></blockquote></blockquote><h3 id="2-Assumptions"><a href="#2-Assumptions" class="headerlink" title="2. Assumptions"></a>2. Assumptions</h3><blockquote><p>To simplify our modeling, we make the following assumptions: ………</p></blockquote><h3 id="3-Notations-符号说明（三线表）"><a href="#3-Notations-符号说明（三线表）" class="headerlink" title="3. Notations 符号说明（三线表）"></a>3. Notations 符号说明（三线表）</h3><h3 id="4-模型具体的论述"><a href="#4-模型具体的论述" class="headerlink" title="4. 模型具体的论述"></a>4. 模型具体的论述</h3><blockquote><p>4.1 模型的 Basic Description</p></blockquote><ul><li>概念解释<ul><li>An Overview of the Algorithm Flow of XXX ：<br>  模型的流程图或者思维导图啥的，直观清晰</li></ul></li><li>可以解释一下，为什么选择了这个模型，基于数据集的什么特点，问题的什么特性balabala……<blockquote><p>After browsing through the data set provided by the competition, we were pleasantly surprised to find that during the entire collection process, the data set showed a certain timing, and the number<br>of player experiences reflected by the number of reports within a certain range was in line with that proposed by Bohlen——the technology adopts the law of life cycle, which to a corresponding extent cn reflect the effect of the integration of wordle as an emerging thing in the eyes of the Internet public with opportunities and attractiveness, and provide help for us to predict the number of reports that wordle can collect in the future.</p></blockquote></li></ul><blockquote><p>翻译：在浏览了大赛提供的数据集后，我们惊喜地发现，在整个收集过程中，数据集呈现出一定的时点，在一定范围内报告次数所反映的玩家体验次数与Bohlen提出的一致——技术采用生命周期规律，这在一定程度上可以反映出world作为一个新兴事物在互联网公众眼中具有机会和吸引力的整合效果，并为我们预测未来world可以收集的报道数量提供帮助。</p></blockquote><blockquote><p>4.2 模型建立</p></blockquote><ul><li>公式推导</li></ul><blockquote><p>4.3 模型应用的结果</p></blockquote><ul><li>模型计算的数据结果阐述</li><li>结果的精确度评价<ul><li>eg.与原始参考数据的误差分析，计算<code>均方根误差</code>，评价模型的有效性<br>  具体问题具体分析，有自己的思考，结合实际。</li><li>23年C题：<br>  从图3可以看出，平均偏差在0.06左右，说明预测数据与原始数据的偏差仅为6%左右。同时，观察到一个有趣的现象:2022年12月25日圣诞节的偏差接近50%，这是由于原始数据在这一天报告的结果数量急剧下降。这很容易与它是一个重要节日的事实联系起来。这样的结果在时间序列分析中属于<code>离群值</code>，有足够的理由去掉这个值。<br>  计算剩余数据的均值和均方根误差(RMSE)。</li><li>官方给的数据可能有些需要清洗，即data clean。例如：数据本身的错误，受到社会某些人文环境因素影响，不适合参与模型评价等等，都应该去掉。</li></ul></li></ul><h3 id="5-模型敏感性分析"><a href="#5-模型敏感性分析" class="headerlink" title="5. 模型敏感性分析"></a>5. 模型敏感性分析</h3><p>雷达图，柱状图啥的都可以展示。</p><h3 id="6-模型评价及进一步讨论"><a href="#6-模型评价及进一步讨论" class="headerlink" title="6. 模型评价及进一步讨论"></a>6. 模型评价及进一步讨论</h3><blockquote><p>Strengths</p></blockquote><blockquote><p>Weaknesses And Further Discussion</p></blockquote><h3 id="7-参考文献引用"><a href="#7-参考文献引用" class="headerlink" title="7.参考文献引用"></a>7.参考文献引用</h3><h3 id="8-附件"><a href="#8-附件" class="headerlink" title="8.附件"></a>8.附件</h3><h1 id="模型和算法积累"><a href="#模型和算法积累" class="headerlink" title="模型和算法积累"></a>模型和算法积累</h1><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-箱型图"><a href="#1-箱型图" class="headerlink" title="1.箱型图"></a>1.箱型图</h3><p>箱型图（Box Plot）是一种统计图形，用于展示<code>数据的分布情况</code>和<code>离散程度</code>。它由五个关键统计量组成：最小值、下四分位数（Q1）、中位数（Q2）、上四分位数（Q3）和最大值。</p><p>箱型图提供了一种简洁的方式来观察数据的<code>集中趋势</code>、离散程度以及<code>异常值的存在</code>。</p><h3 id="2-回归算法——机器学习"><a href="#2-回归算法——机器学习" class="headerlink" title="2.回归算法——机器学习"></a>2.回归算法——机器学习</h3><p>大多数情况下，线性回归被用作基线模型来评估和比较研究中的新方法。常用的9种回归算法有：</p><table><thead><tr><th align="center">算法</th><th align="left">基本介绍</th></tr></thead><tbody><tr><td align="center">线性回归</td><td align="left">是一种线性模型，它假设输入变量 (X) 和单个输出变量 (y) 之间存在线性关系，分为<code>单变量线性回归</code>和<code>多变量线性回归</code></td></tr><tr><td align="center">多项式回归</td><td align="left">为非线性可分数据创建模型，图像为曲线</td></tr><tr><td align="center">支持向量机回归(SVM)</td><td align="left">找到一个最优的超平面，尽可能拟合训练数据，并且在超平面两侧具有最大的间隔，以确保预测的泛化能力</td></tr><tr><td align="center">决策树回归</td><td align="left">通过学习从数据特征推断出的简单决策规则来预测目标变量的值</td></tr><tr><td align="center">随机森林回归</td><td align="left">是一个元估计器，可以在数据集的各种子样本上拟合多个决策树，并使用平均来提高预测准确性和控制过拟合。</td></tr><tr><td align="center">LASSO 回归</td><td align="left">使用<code>收缩的线性回归</code>的变体，收缩是将数据值收缩到中心点作为平均值的过程。这种类型的回归非常适合显示<code>重度多重共线性</code>（特征相互之间高度相关）的模型。</td></tr><tr><td align="center">岭回归</td><td align="left">与 LASSO 回归非常相似，因为这两种技术都使用了收缩。Ridge 使用 L2 正则化，这意味着没有一个系数会像 LASSO 回归中那样变为零(而是接近零)</td></tr><tr><td align="center">ElasticNet 回归</td><td align="left">使用 L1 和 L2 正则化训练的线性回归模型,是<code> Lasso 和 Ridge 回归技术的混合体</code>，因此它也非常适合显示重度多重共线性（特征相互之间高度相关）的模型</td></tr><tr><td align="center">XGBoost 回归</td><td align="left"><code>梯度提升算法</code>的一种高效且有效的实现</td></tr></tbody></table><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><ol><li><p>实现过程：<br><a href="https://zhuanlan.zhihu.com/p/75412836">看这个教程</a></p></li><li><p>关于线性回归的几个关键点：</p></li></ol><ul><li>快速且易于建模</li><li>当要建模的关系不是非常复杂并且您没有大量数据时，它特别有用。</li><li>非常直观的理解和解释。</li><li>它对异常值非常敏感。</li></ul><h4 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h4><p>1.实现过程:<br><a href="https://blog.csdn.net/python_LC_nohtyp/article/details/103432454">教程看这里</a></p><p>2.关于多项式回归的几个关键点：</p><ul><li>能够对非线性可分数据进行建模；线性回归不能做到这一点。一般来说，它更加灵活，可以对一些相当复杂的关系进行建模。</li><li>完全控制特征变量的建模（要设置的指数）。</li><li>需要精心设计。 需要一些数据知识才能选择最佳指数。</li><li>如果指数选择不当，则容易过度拟合。</li></ul><p>3.补充：<code>过拟合</code>和<code>欠拟合</code></p><ul><li><p>过于简单的模型，无论对于训练数据还是测试数据都无法给出足够高的预测精度，这种现象叫做欠拟合。</p></li><li><p>过于复杂的模型，对于<code>训练数据</code>可以得到较高的预测精度，但对于<code>测试数据</code>通常精度较低，这种现象叫做过拟合。</p></li></ul><p>一个性能可以接受的学习模型应该对训练数据和测试数据都有接近的预测精度，而且精度不能太低。</p><h4 id="支持向量机回归-SVM"><a href="#支持向量机回归-SVM" class="headerlink" title="支持向量机回归(SVM)"></a>支持向量机回归(SVM)</h4><p>1.在拟合 SVR 模型之前，通常最好先<code>执行特征缩放</code>，以便每个特征具有相似的重要性。 </p><ul><li>使用 StandardScaler() 执行特征缩放</li></ul><p>2.关于支持向量回归的几个关键点:</p><p>优势：</p><ul><li>它对异常值具有鲁棒性，并且在高维空间中有效</li><li>它具有出色的泛化能力（能够正确适应新的、以前看不见的数据）</li><li>如果特征数量远大于样本数量，则容易过拟合</li></ul><p>劣势：</p><ul><li>对于大规模数据集和特征数量很多的情况，训练时间可能较长</li><li>对于噪声较多的数据或者数据集中有重叠的情况，表现可能不佳</li><li>SVM模型在处理多类别分类问题时需要进行额外的处理（例如一对多策略）</li></ul><ol start="3"><li>支持向量机的<code>分类算法</code>和<code>回归算法</code>的python教程<br><a href="https://blog.csdn.net/weixin_45678130/article/details/119850958">教程和代码看这里</a></li></ol><h4 id="决策树回归"><a href="#决策树回归" class="headerlink" title="决策树回归"></a>决策树回归</h4><p>1.可以在没有特征缩放的情况下创建 DecisionTreeRegressor 对象</p><p>2.关于决策树的几个关键点：</p><ul><li>易于理解和解释。树可以可视化。</li><li>适用于分类值和连续值</li><li>使用 DT（即预测数据）的成本与用于训练树的数据点数量成对数</li><li>决策树的预测既不平滑也不连续（为分段常数近似）</li></ul><p>3.python实现：<br><a href="https://blog.csdn.net/weixin_44904136/article/details/126201929">教程和代码看这里</a></p><h4 id="随机森林回归"><a href="#随机森林回归" class="headerlink" title="随机森林回归"></a>随机森林回归</h4><p>1.关于随机森林回归的几点：</p><ul><li>减少决策树中的过度拟合并提高准确性</li><li>它也适用于分类值和连续值</li><li>需要大量计算能力和资源，因为它适合许多决策树来组合它们的输出</li></ul><h4 id="XGBoost算法"><a href="#XGBoost算法" class="headerlink" title="XGBoost算法"></a>XGBoost算法</h4><p>1.关于 XGBoost 的几点：</p><ul><li>XGBoost 在稀疏和非结构化数据上表现不佳。</li><li>该算法被设计为计算效率和高效，但是对于大型数据集的训练时间仍然相当长</li><li>它对异常值很敏感</li></ul><p>2.安装 XGBoost 库（如果尚未安装）<br><code>pip install xgboost</code></p><h3 id="3-Python自然语言处理-NLTK-库"><a href="#3-Python自然语言处理-NLTK-库" class="headerlink" title="3.Python自然语言处理 NLTK 库"></a>3.Python自然语言处理 NLTK 库</h3><p>NLTK（Natural Language Toolkit）是一个Python库，用于实现自然语言处理（NLP）的许多任务。NLTK包括一些有用的工具和资源，如<code>文本语料库</code>、<code>词性标注器</code>、<code>语法分析器</code>等。</p><h4 id="文本分词-——-将文本分解成单独的词语或标记。"><a href="#文本分词-——-将文本分解成单独的词语或标记。" class="headerlink" title="文本分词 —— 将文本分解成单独的词语或标记。"></a>文本分词 —— 将文本分解成单独的词语或标记。</h4><h4 id="停用词移除-——-移除一些常见但对分析贡献不大的词"><a href="#停用词移除-——-移除一些常见但对分析贡献不大的词" class="headerlink" title="停用词移除 —— 移除一些常见但对分析贡献不大的词"></a>停用词移除 —— 移除一些常见但对分析贡献不大的词</h4><h4 id="词性标注-——-为每个单词标记相应的词性"><a href="#词性标注-——-为每个单词标记相应的词性" class="headerlink" title="词性标注 —— 为每个单词标记相应的词性"></a>词性标注 —— 为每个单词标记相应的词性</h4><h2 id="数据预测"><a href="#数据预测" class="headerlink" title="数据预测"></a>数据预测</h2><h3 id="1-网格搜索随机森林（Grid-Search-Random-Forest-GSRF）算法"><a href="#1-网格搜索随机森林（Grid-Search-Random-Forest-GSRF）算法" class="headerlink" title="1.网格搜索随机森林（Grid Search Random Forest, GSRF）算法"></a>1.网格搜索随机森林（Grid Search Random Forest, GSRF）算法</h3><p>结合了网格搜索和随机森林两种技术，用于超参数调优和模型选择。</p><p>GSRF算法的基本思想是<code>利用网格搜索来选择最优的随机森林超参数</code>，例如决策树的数量、每棵树的最大深度、节点最小样本数等。</p><ul><li><p>随机森林是一种集成学习算法，通过训练多个决策树，并将它们的预测结果进行平均或投票来提高预测性能。</p></li><li><p>网格搜索是一种常用的超参数调优技术，它通过遍历指定的参数组合来寻找最佳模型。</p></li></ul><h4 id="机器学习的模型评价指标"><a href="#机器学习的模型评价指标" class="headerlink" title="机器学习的模型评价指标"></a>机器学习的模型评价指标</h4><p>使用机器学习算法进行预测时，两种常用的评估指标是<code>均方误差(MSE)</code>和<code>平均绝对误差(MAE)</code>。</p><ul><li>MSE是预测数据与原始数据之差平方的平均值</li><li>MAE是预测数据与原始数据之差绝对值的平均值。</li></ul><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means++"></a>K-Means++</h3><p>K-Means++算法在聚类中心的初始化过程中的基本原则是使得初始的聚类中心之间的相互距离尽可能远</p><p>1.初始化过程如下所示：</p><ul><li>在数据集中随机选择一个样本点作为第一个初始化的聚类中心</li><li>选择出其余的聚类中心：</li><li>计算样本中的每一个样本点与已经初始化的聚类中心之间的距离，并选择其中最短的距离，记为d_i</li><li>以概率选择距离最大的样本作为新的聚类中心，重复上述过程，直到k个聚类中心都被确定</li><li>对k个初始化的聚类中心，利用K-Means算法计算最终的聚类中心。</li></ul><p>2.<a href="https://blog.csdn.net/google19890102/article/details/53284285">代码看这里</a></p>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python处理excel数据</title>
    <link href="/2024/01/31/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/"/>
    <url>/2024/01/31/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>使用python读取和处理excel数据，在<code>数学建模绘图笔记</code>中有绘图的整理，这里主要记录代码处理的一些要点。</p><span id="more"></span> <h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="补充：-xls和xlsx"><a href="#补充：-xls和xlsx" class="headerlink" title="补充： xls和xlsx"></a>补充： xls和xlsx</h2><p>简单来说：<br><code>xls</code>是excel2003及以前版本所生成的文件格式<br><code>xlsx</code>是excel2007及以后版本所生成的文件格式</p><p>（excel 2007之后版本可以打开上述两种格式，但是excel2013只能打开xls格式）</p><h2 id="需要导入的库"><a href="#需要导入的库" class="headerlink" title="需要导入的库"></a>需要导入的库</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br></code></pre></td></tr></table></figure><h2 id="打开Excel文档，查看所有sheet表"><a href="#打开Excel文档，查看所有sheet表" class="headerlink" title="打开Excel文档，查看所有sheet表"></a>打开Excel文档，查看所有sheet表</h2><p>使用<code>openpyxl</code>模块打开Excel文档，并查看所有sheet表：</p><h3 id="1-打开excel文档："><a href="#1-打开excel文档：" class="headerlink" title="1.打开excel文档："></a>1.打开excel文档：</h3><p><code>openpyxl.load_workbook()</code>接受文件名，返回一个<code>workbook</code>数据类型的值。</p><ul><li>这个workbook对象代表这个Excel文件，类似File对象代表一个打开的文本文件。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br><span class="hljs-comment"># 返回一个workbook数据类型的值</span><br><br><span class="hljs-built_in">print</span>(workbook.sheetnames)<br><span class="hljs-comment"># 打印Excel表中的所有表</span><br><br><br><span class="hljs-comment"># 结果：</span><br><span class="hljs-comment"># [&#x27;Sheet1&#x27;, &#x27;Sheet2&#x27;]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-查看所有sheet表"><a href="#2-查看所有sheet表" class="headerlink" title="2.查看所有sheet表"></a>2.查看所有sheet表</h3><h4 id="2-1-通过sheet名称获取表格"><a href="#2-1-通过sheet名称获取表格" class="headerlink" title="2.1 通过sheet名称获取表格"></a>2.1 通过sheet名称获取表格</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp">sheet = workbook[<span class="hljs-string">&#x27;Sheet1&#x27;</span>]  <span class="hljs-meta"># 获取指定sheet表</span><br><span class="hljs-keyword">print</span>(sheet)<br><br><span class="hljs-meta"># 结果：</span><br><span class="hljs-meta"># &lt;Worksheet <span class="hljs-string">&quot;Sheet1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-使用-workbook-active-获取活动表"><a href="#2-2-使用-workbook-active-获取活动表" class="headerlink" title="2.2 使用 workbook.active 获取活动表"></a>2.2 使用 <code>workbook.active</code> 获取活动表</h4><p>(1)活动表：<code>当前正在操作</code>的工作表。<br>(2) <code>sheet = workbook.active  </code> </p><ul><li>获取活动表</li></ul><h3 id="3-获取表格尺寸"><a href="#3-获取表格尺寸" class="headerlink" title="3.获取表格尺寸"></a>3.获取表格尺寸</h3><p>(1)表格的尺寸：excel表格中的数据有几行几列，针对的是不同的sheet而言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  <span class="hljs-comment"># 返回一个workbook数据类型的值</span><br>sheet = workbook[<span class="hljs-string">&#x27;Sheet1&#x27;</span>]  <span class="hljs-comment"># 获取指定sheet表</span><br><span class="hljs-built_in">print</span>(sheet.dimensions)     <span class="hljs-comment"># 获取表格的尺寸大小</span><br><br><span class="hljs-comment"># 结果：</span><br><span class="hljs-comment"># A1:B7  (从A1沿对角线到B7的矩形区域)</span><br></code></pre></td></tr></table></figure><h3 id="4-获取单元格中的数据"><a href="#4-获取单元格中的数据" class="headerlink" title="4. 获取单元格中的数据"></a>4. 获取单元格中的数据</h3><h4 id="方法一：指定坐标的方式"><a href="#方法一：指定坐标的方式" class="headerlink" title="方法一：指定坐标的方式"></a>方法一：指定坐标的方式</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">cell1 = sheet[<span class="hljs-string">&#x27;A1&#x27;</span>]         # 获取A1单元格的数据<br>cell2 = sheet[<span class="hljs-string">&#x27;B7&#x27;</span>]         # 获取B7单元格的数据<br># cell2 = sheet[<span class="hljs-string">&#x27;B7&#x27;</span>].value# 另一种写法<br><br># cell1.value获取单元格A1中的值<br># cell2.value获取单元格B7中的值<br>print(cell1.value,cell2.value)<br></code></pre></td></tr></table></figure><h4 id="方法二：指定行列的方式"><a href="#方法二：指定行列的方式" class="headerlink" title="方法二：指定行列的方式"></a>方法二：指定行列的方式</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cell1</span> = sheet.cell(row=<span class="hljs-number">1</span>,column=<span class="hljs-number">1</span>)         # 获取第<span class="hljs-number">1</span>行第<span class="hljs-number">1</span>列的数据<br><span class="hljs-attribute">cell2</span> = sheet.cell(row=<span class="hljs-number">3</span>,column=<span class="hljs-number">2</span>)         # 获取第<span class="hljs-number">3</span>行第<span class="hljs-number">4</span>的数据<br><span class="hljs-comment"># cell1.value获取单元格A1中的值</span><br><span class="hljs-comment"># cell2.value获取单元格B7中的值</span><br><span class="hljs-attribute">print</span>(cell1.value,cell2.value)<br></code></pre></td></tr></table></figure><h4 id="获取单元格的行、列、坐标"><a href="#获取单元格的行、列、坐标" class="headerlink" title="获取单元格的行、列、坐标"></a>获取单元格的行、列、坐标</h4><ul><li><code>.row</code> 获取某个格子的行数；</li><li><code>.columns</code> 获取某个格子的列数；</li><li><code>.coordinate</code> 获取某个格子的坐标；</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cell = sheet.cell(<span class="hljs-attribute">row</span>=3, <span class="hljs-attribute">column</span>=2)  # 获取第3行第4列的数据<br><br><span class="hljs-built_in">print</span>(cell.value, cell.row, cell.column, cell.coordinate)<br></code></pre></td></tr></table></figure><h3 id="获取区间内的数据"><a href="#获取区间内的数据" class="headerlink" title="获取区间内的数据"></a>获取区间内的数据</h3><blockquote><p>获取单行单列数据的时候，使用一层for循环；</p></blockquote><blockquote><p>获取多行多列、指定区间的数据时，使用两层for循环</p></blockquote><h4 id="获取指定区间的数据"><a href="#获取指定区间的数据" class="headerlink" title="获取指定区间的数据"></a>获取指定区间的数据</h4><ul><li>step 1 : 使用<code>sheet[&#39;A1:A5&#39;]</code>拿到指定区间</li><li>step 2 : 使用<code>两个for循环</code>拿到数据<ul><li>为什么要使用两层循环：<br>  外层循环迭代了从A1到A5的行（实际上只有一行）；<br>  而内层循环则迭代了这一行中的单个单元格，这样即可访问并打印每个单元格的值了</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  <span class="hljs-comment"># 返回一个workbook数据类型的值</span><br>sheet = workbook.active  <span class="hljs-comment"># 获取活动表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前活动表是：&#x27;</span>)<br><span class="hljs-built_in">print</span>(sheet)<br><br>cell = sheet[<span class="hljs-string">&#x27;A1:A5&#x27;</span>]  <span class="hljs-comment"># 获取A1到A5的数据</span><br><br><span class="hljs-built_in">print</span>(cell)<br><br><span class="hljs-comment">#打印A1到A5的数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cell:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>        <span class="hljs-built_in">print</span>(j.value)<br></code></pre></td></tr></table></figure><h4 id="获取指定行列的数据"><a href="#获取指定行列的数据" class="headerlink" title="获取指定行列的数据"></a>获取指定行列的数据</h4><ul><li>sheet[“A”] — 获取A列的数据</li><li>sheet[“A:C”] — 获取A,B,C三列的数据</li><li>sheet[5] — 只获取第5行的数据</li></ul><p>例如:<br>(1)获取一列数据:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">cell = sheet[<span class="hljs-string">&#x27;2&#x27;</span>]  <span class="hljs-meta"># 获取第2行的数据</span><br><br><span class="hljs-meta">#打印A1到A5的数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cell:<br>    <span class="hljs-keyword">print</span>(i.value)<br></code></pre></td></tr></table></figure><p>(2)获取两列数据:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta">cell = sheet[<span class="hljs-string">&#x27;A:B&#x27;</span>]  <span class="hljs-meta"># 获取AB列的数据</span><br><br><span class="hljs-meta">#打印AB列数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cell:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>        <span class="hljs-keyword">print</span>(j.value)<br></code></pre></td></tr></table></figure><h4 id="按行、列获取值"><a href="#按行、列获取值" class="headerlink" title="按行、列获取值"></a>按行、列获取值</h4><ul><li><code>iter_rows()</code>：按行读取</li><li><code>iter_cols()</code>：按列读取</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 按行获取值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按行获取值&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sheet.iter_rows(<span class="hljs-attribute">min_row</span>=2, <span class="hljs-attribute">max_row</span>=5, <span class="hljs-attribute">min_col</span>=1, <span class="hljs-attribute">max_col</span>=2):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>        <span class="hljs-built_in">print</span>(j.value)<br><br><span class="hljs-comment"># 按列获取值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按列获取值&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sheet.iter_cols(<span class="hljs-attribute">min_row</span>=2, <span class="hljs-attribute">max_row</span>=5, <span class="hljs-attribute">min_col</span>=1, <span class="hljs-attribute">max_col</span>=2):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>        <span class="hljs-built_in">print</span>(j.value)<br></code></pre></td></tr></table></figure><h4 id="获取活动表的行列数"><a href="#获取活动表的行列数" class="headerlink" title="获取活动表的行列数"></a>获取活动表的行列数</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-built_in">rows</span> = sheet.max_row        <span class="hljs-comment"># 获取行数</span><br>column = sheet.max_column   <span class="hljs-comment"># 获取列数</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">rows</span>)<br><span class="hljs-built_in">print</span>(column)<br></code></pre></td></tr></table></figure><h2 id="表格内容编辑"><a href="#表格内容编辑" class="headerlink" title="表格内容编辑"></a>表格内容编辑</h2><h3 id="1-创建新的excel"><a href="#1-创建新的excel" class="headerlink" title="1.创建新的excel"></a>1.创建新的excel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.Workbook()<br>sheet = workbook.active<br>sheet.title = <span class="hljs-string">&#x27;1号sheet&#x27;</span>  <span class="hljs-comment"># 指定创建的excel的活动表的名字</span><br>workbook.save(<span class="hljs-string">&#x27;1.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-修改单元格、excel另存为"><a href="#2-修改单元格、excel另存为" class="headerlink" title="2.修改单元格、excel另存为"></a>2.修改单元格、excel另存为</h3><ul><li><code>workbook.save(&#39;test.xlsx&#39;)</code><br>保存时如果使用原来的（第7行）名字，就直接保存；如果使用了别的名字，就会另存为一个新文件</li><li>修改单元格内容的两种写法：<ul><li><code>sheet[&#39;B1&#39;].value = &#39;age&#39;</code></li><li><code>sheet[&#39;A1&#39;] = &#39;name&#39;</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  <span class="hljs-comment"># 返回一个workbook数据类型的值</span><br>sheet = workbook.active  <span class="hljs-comment"># 获取活动表</span><br><br>sheet[<span class="hljs-string">&#x27;A1&#x27;</span>] = <span class="hljs-string">&#x27;name&#x27;</span><br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h3><h4 id="3-1-添加有效数据"><a href="#3-1-添加有效数据" class="headerlink" title="3.1 添加有效数据"></a>3.1 添加有效数据</h4><p>使用<code>append()</code>方法，在原来数据的后面，按行插入数据</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">data = [<br>    [<span class="hljs-string">&#x27;素子&#x27;</span>,<span class="hljs-number">23</span>],<br>    [<span class="hljs-string">&#x27;巴特&#x27;</span>,<span class="hljs-number">24</span>],<br>    [<span class="hljs-string">&#x27;塔奇克马&#x27;</span>,<span class="hljs-number">2</span>]<br>]<br>for row in data:<br>    sheet.append(row)   # 使用append插入数据<br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p2.png" alt="示意图"></p><h4 id="3-2-插入空行空列"><a href="#3-2-插入空行空列" class="headerlink" title="3.2 插入空行空列"></a>3.2 插入空行空列</h4><ul><li><code>insert_rows(idx=数字编号, amount=要插入的行数)</code>，插入的行数是在idx行数的<code>下方</code>插入</li><li><code>insert_cols(idx=数字编号, amount=要插入的列数)</code>，插入的列数是在idx列数的<code>左侧</code>插入</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sheet.insert_rows(<span class="hljs-attribute">idx</span>=3, <span class="hljs-attribute">amount</span>=2)<br>sheet.insert_cols(<span class="hljs-attribute">idx</span>=2, <span class="hljs-attribute">amount</span>=1)<br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p1.png" alt="示意图"></p><h3 id="4-删除行、列"><a href="#4-删除行、列" class="headerlink" title="4.删除行、列"></a>4.删除行、列</h3><ul><li><code>delete_rows(idx=数字编号, amount=要删除的行数)</code></li><li><code>delete_cols(idx=数字编号, amount=要删除的列数)</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sheet.delete_rows(<span class="hljs-attribute">idx</span>=10)           # 删除第10行<br>sheet.delete_cols(<span class="hljs-attribute">idx</span>=1, <span class="hljs-attribute">amount</span>=2)  # 删除第1列，及往右共2列<br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p3.png" alt="示意图"></p><h3 id="5-移动指定区间的单元格-move-range"><a href="#5-移动指定区间的单元格-move-range" class="headerlink" title="5.移动指定区间的单元格(move_range)"></a>5.移动指定区间的单元格(move_range)</h3><ul><li><code>move_range(“数据区域”,rows=,cols=)</code><br>正整数为向下或向右、负整数为向左或向上</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sheet.move_range(<span class="hljs-string">&#x27;D11:F12&#x27;</span>,<span class="hljs-attribute">rows</span>=0,cols=-3)  # 移动D11到F12构成的矩形格子<br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p4.png" alt="示意图"></p><h2 id="格式查看和修改"><a href="#格式查看和修改" class="headerlink" title="格式查看和修改"></a>格式查看和修改</h2><h3 id="字母列号与数字列号之间的转换"><a href="#字母列号与数字列号之间的转换" class="headerlink" title="字母列号与数字列号之间的转换"></a>字母列号与数字列号之间的转换</h3><p>核心代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> get_column_letter, column_index_from_string<br><br><span class="hljs-comment"># 根据列的数字返回字母</span><br><span class="hljs-built_in">print</span>(get_column_letter(<span class="hljs-number">2</span>))  <span class="hljs-comment"># B</span><br><span class="hljs-comment"># 根据字母返回列的数字</span><br><span class="hljs-built_in">print</span>(column_index_from_string(<span class="hljs-string">&#x27;D&#x27;</span>))  <span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><h4 id="查看字体样式"><a href="#查看字体样式" class="headerlink" title="查看字体样式"></a>查看字体样式</h4><ul><li>font &#x3D; cell.font</li><li><code>font.name</code> , <code>font.size</code> , <code>font.bold</code> , <code>font.italic</code> , <code>font.color</code></li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">cell = sheet[<span class="hljs-emphasis">&#x27;A1&#x27;</span>]<br>font = cell.font<br>print(<span class="hljs-emphasis">&#x27;当前单元格的字体样式是&#x27;</span>)<br>print(font.name, font.size, font.bold, font.italic, font.color)<br><br>&#x27;&#x27;&#x27;<br>当前活动表是：&lt;Worksheet &quot;1号sheet&quot;&gt;<br>当前单元格的字体样式是<br>等线 11.0 False False &lt;openpyxl.styles.colors.Color object&gt;<br>Parameters:<br>rgb=None, indexed=None, auto=None, theme=1, tint=0.0, type=<span class="hljs-emphasis">&#x27;theme&#x27;</span><br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><h4 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h4><ul><li><code>openpyxl.styles.Font(name=字体名称,size=字体大小,bold=是否加粗,italic=是否斜体,color=字体颜色)</code><ul><li>其中，字体颜色中的color是RGB的16进制表示</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><span class="hljs-keyword">import</span> openpyxl.styles<br><br>path = <span class="hljs-string">r&quot;C:\Users\asuka\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  <span class="hljs-comment"># 返回一个workbook数据类型的值</span><br>sheet = workbook.active  <span class="hljs-comment"># 获取活动表</span><br><span class="hljs-built_in">print</span>(sheet)<br><br>cell = sheet[<span class="hljs-string">&#x27;A1&#x27;</span>]<br>cell.font = openpyxl.styles.Font(name=<span class="hljs-string">&quot;微软雅黑&quot;</span>, size=<span class="hljs-number">20</span>, bold=<span class="hljs-literal">True</span>, italic=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&quot;FF0000&quot;</span>)<br><br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p5.png" alt="示意图"></p><h4 id="使用for循环，修改多行多列的数据"><a href="#使用for循环，修改多行多列的数据" class="headerlink" title="使用for循环，修改多行多列的数据"></a>使用for循环，修改多行多列的数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> openpyxl<br><span class="hljs-keyword">import</span> openpyxl.styles<br><br>path = <span class="hljs-string">r&quot;C:\Users\asuka\Desktop&quot;</span><br>os.chdir(path)  <span class="hljs-comment"># 修改工作路径</span><br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  <span class="hljs-comment"># 返回一个workbook数据类型的值</span><br>sheet = workbook.active  <span class="hljs-comment"># 获取活动表</span><br><span class="hljs-built_in">print</span>(sheet)<br><br>cell = sheet[<span class="hljs-string">&#x27;A&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cell:<br>    i.font = openpyxl.styles.Font(name=<span class="hljs-string">&quot;微软雅黑&quot;</span>, size=<span class="hljs-number">20</span>, bold=<span class="hljs-literal">True</span>, italic=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&quot;FF0000&quot;</span>)<br><br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="设置对齐格式"><a href="#设置对齐格式" class="headerlink" title="设置对齐格式"></a>设置对齐格式</h3><ul><li><code>Alignment(horizontal=水平对齐模式,vertical=垂直对齐模式,text_rotation=旋转角度,wrap_text=是否自动换行)</code></li><li>水平对齐：‘distributed’，‘justify’，‘center’，‘left’， ‘centerContinuous’，’right，‘general’</li><li>垂直对齐：‘bottom’，‘distributed’，‘justify’，‘center’，‘top’<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>cell = sheet[<span class="hljs-string">&#x27;A1&#x27;</span>]<br>alignment = openpyxl.styles.Alignment(<span class="hljs-attribute">horizontal</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">vertical</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">text_rotation</span>=0, <span class="hljs-attribute">wrap_text</span>=<span class="hljs-literal">True</span>)<br>cell.alignment = alignment<br></code></pre></td></tr></table></figure></li></ul><h4 id="调用for循环实现多行多列操作"><a href="#调用for循环实现多行多列操作" class="headerlink" title="调用for循环实现多行多列操作"></a>调用for循环实现多行多列操作</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cell = sheet[<span class="hljs-string">&#x27;A&#x27;</span>]<br>alignment = openpyxl.styles.Alignment(<span class="hljs-attribute">horizontal</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">vertical</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">text_rotation</span>=0, <span class="hljs-attribute">wrap_text</span>=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cell:<br>    i.alignment = alignment<br>    <br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="设置行高列宽"><a href="#设置行高列宽" class="headerlink" title="设置行高列宽"></a>设置行高列宽</h3><p><a href="https://blog.csdn.net/weixin_44288604/article/details/120731317">教程看这里</a></p><h4 id="设置所有单元格"><a href="#设置所有单元格" class="headerlink" title="设置所有单元格"></a>设置所有单元格</h4><p>（显示的结果是设置所有，有数据的单元格的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook<br><span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> get_column_letter<br><span class="hljs-keyword">import</span> os<br><br>os.chdir(<span class="hljs-string">r&#x27;C:\Users\asuka\Desktop&#x27;</span>)<br><br>workbook = load_workbook(<span class="hljs-string">&#x27;1.xlsx&#x27;</span>)<br><span class="hljs-built_in">print</span>(workbook.sheetnames)  <span class="hljs-comment"># 打印所有的sheet表</span><br>ws = workbook[workbook.sheetnames[<span class="hljs-number">0</span>]]  <span class="hljs-comment"># 选中最左侧的sheet表</span><br><br>width = <span class="hljs-number">2.0</span>  <span class="hljs-comment"># 设置宽度</span><br>height = width * (<span class="hljs-number">2.2862</span> / <span class="hljs-number">0.3612</span>)  <span class="hljs-comment"># 设置高度</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;row:&quot;</span>, ws.max_row, <span class="hljs-string">&quot;column:&quot;</span>, ws.max_column)  <span class="hljs-comment"># 打印行数，列数</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ws.max_row + <span class="hljs-number">1</span>):<br>    ws.row_dimensions[i].height = height<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ws.max_column + <span class="hljs-number">1</span>):<br>    ws.column_dimensions[get_column_letter(i)].width = width<br><br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="合并、拆分单元格"><a href="#合并、拆分单元格" class="headerlink" title="合并、拆分单元格"></a>合并、拆分单元格</h3><p>如果要合并的格子中有数据，即便python没有报错，Excel打开的时候也会报错。</p><ul><li>方法一：<code>merge_cells(待合并的格子编号)</code></li><li>方法二：<code>merge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import os<br>import openpyxl<br>import openpyxl.styles<br><br>path = r<span class="hljs-string">&quot;C:\Users\asuka\Desktop&quot;</span><br>os.chdir(path)  # 修改工作路径<br><br>workbook = openpyxl.load_workbook(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)  # 返回一个workbook数据类型的值<br>sheet = workbook.active  # 获取活动表<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前活动表是：&#x27;</span> + str(sheet))<br><br><span class="hljs-comment"># 方法1：</span><br>sheet.merge_cells(<span class="hljs-string">&#x27;A12:B13&#x27;</span>)<br><span class="hljs-comment"># 方法2：</span><br>sheet.merge_cells(<span class="hljs-attribute">start_row</span>=12, <span class="hljs-attribute">start_column</span>=3, <span class="hljs-attribute">end_row</span>=13, <span class="hljs-attribute">end_column</span>=4)<br><br><span class="hljs-comment"># 加一个居中对齐</span><br>cell = sheet[<span class="hljs-string">&#x27;A12&#x27;</span>]<br>alignment = openpyxl.styles.Alignment(<span class="hljs-attribute">horizontal</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">vertical</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">text_rotation</span>=0, <span class="hljs-attribute">wrap_text</span>=<span class="hljs-literal">True</span>)<br>cell.alignment = alignment<br><br>cell = sheet[<span class="hljs-string">&#x27;C12&#x27;</span>]<br>alignment = openpyxl.styles.Alignment(<span class="hljs-attribute">horizontal</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">vertical</span>=<span class="hljs-string">&quot;center&quot;</span>, <span class="hljs-attribute">text_rotation</span>=0, <span class="hljs-attribute">wrap_text</span>=<span class="hljs-literal">True</span>)<br>cell.alignment = alignment<br><br>workbook.save(<span class="hljs-string">&#x27;test.xlsx&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="拆分单元格的方法同上"><a href="#拆分单元格的方法同上" class="headerlink" title="拆分单元格的方法同上"></a>拆分单元格的方法同上</h4><ul><li>方法一：<code>unmerge_cells(待合并的格子编号)</code></li><li>方法二：<code>unmerge_cells(start_row=起始行号，start_column=起始列号，end_row=结束行号，end_column=结束列号)</code></li></ul><h2 id="xlsxwriter模块"><a href="#xlsxwriter模块" class="headerlink" title="xlsxwriter模块"></a>xlsxwriter模块</h2><ul><li><p>xlsxwriter模块一般是和xlrd模块搭配使用的，</p><ul><li><code>xlsxwriter</code>：负责写入数据，</li><li><code>xlrd</code>：负责读取数据。</li></ul></li><li><p><code>worksheet.write_row(&#39;A1&#39;, headings)</code> 添加表头</p></li><li><p><code>worksheet.write(行,列,数据)</code> 写入数据</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">data = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;苹果&quot;</span>, 500, 8.9]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(headings)):<br>    worksheet<span class="hljs-selector-class">.write</span>(<span class="hljs-number">1</span>, <span class="hljs-selector-tag">i</span>, data<span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure><p>完整的代码：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlsxwriter<br><span class="hljs-keyword">import</span> os<br><br>path = <span class="hljs-string">r&quot;C:\Users\cyr\Desktop&quot;</span><br>os.chdir(path)<br><br><span class="hljs-comment"># 创建一个名为【demo.xlsx】工作簿；</span><br>workbook = xlsxwriter.Workbook(<span class="hljs-string">&quot;demo.xlsx&quot;</span>)<br><br><span class="hljs-comment"># 创建一个名为【2018年销售量】工作表；</span><br>worksheet = workbook.add_worksheet(<span class="hljs-string">&quot;2018年销售量&quot;</span>)<br><br><span class="hljs-comment"># 使用write_row方法，为【2018年销售量】工作表，添加一个表头；</span><br>headings = [<span class="hljs-string">&#x27;产品&#x27;</span>, <span class="hljs-string">&#x27;销量&#x27;</span>, <span class="hljs-string">&quot;单价&quot;</span>]<br>worksheet.write_row(<span class="hljs-string">&#x27;A1&#x27;</span>, headings)<br><span class="hljs-comment"># 使用write方法，在【2018年销售量】工作表中插入一条数据；</span><br><span class="hljs-comment"># write语法格式：worksheet.write(行,列,数据)</span><br><br>data = [<span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-number">500</span>, <span class="hljs-number">8.9</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(headings)):<br>    worksheet.write(<span class="hljs-number">1</span>, i, data[i])<br><br>workbook.close()<br></code></pre></td></tr></table></figure><p><img src="/images/%E4%BD%BF%E7%94%A8python%E5%A4%84%E7%90%86excel%E6%95%B0%E6%8D%AE/p6.png" alt="示意图"></p>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析和处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.1.29会议记录</title>
    <link href="/2024/01/29/%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/01/29/%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>nature论文分析学习——会议记录</p><span id="more"></span> <h4 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h4><p>1、子刊的重要性 </p><p>2、新创刊的子刊录用率较高</p><p>3、英语要求较高</p><p>4、课题组的积累，平台的重要性，Co-author 加大佬</p><h4 id="范文分析"><a href="#范文分析" class="headerlink" title="范文分析"></a>范文分析</h4><p>详细批注保存在赵老师的word文档中</p><h5 id="优秀论文好在哪里："><a href="#优秀论文好在哪里：" class="headerlink" title="优秀论文好在哪里："></a>优秀论文好在哪里：</h5><ul><li>覆盖全面</li><li>有自己的思考，每个技术的大类&#x2F;小类（分类科学合理）；<ul><li>具有故事性（很多however）和逻辑性，层层递进。</li></ul></li><li>简单易懂，不是技术和paper的堆叠<ul><li>适合public,具有可读性</li></ul></li><li>格式不机械化</li><li>有大量举例（for example）<ul><li>国外的知名examples</li><li>eg. VPP for Aussie </li><li>Other Nature portfolio journals : 碳溢出、死亡螺旋、关联经济学</li></ul></li><li>工程性，PJM，实用性<ul><li>不要写太多公式，数学不太重要</li><li>新闻、热点、政策</li></ul></li><li>选题方面：<ul><li>selecting research topics 重要，不能随意</li></ul></li></ul><h5 id="基金论文"><a href="#基金论文" class="headerlink" title="基金论文"></a>基金论文</h5><ul><li>第一部分最重要，生动故事性</li></ul>]]></content>
    
    
    <categories>
      
      <category>科研课题组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>会议记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇到的一些坑</title>
    <link href="/2024/01/27/%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91-1/"/>
    <url>/2024/01/27/%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91-1/</url>
    
    <content type="html"><![CDATA[<p>记录日常遇到的一些小bugs</p><span id="more"></span> <h3 id="安装方面"><a href="#安装方面" class="headerlink" title="安装方面"></a>安装方面</h3><h4 id="1-npm使用淘宝镜像安装时报错"><a href="#1-npm使用淘宝镜像安装时报错" class="headerlink" title="1.npm使用淘宝镜像安装时报错"></a>1.npm使用淘宝镜像安装时报错</h4><ul><li>错误内容:<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">npm ERR! request <span class="hljs-keyword">to</span> https:<span class="hljs-comment">//registry.npm.taobao.org/cnpm failed, reason: certificate has expired</span><br></code></pre></td></tr></table></figure></li><li>解决方案：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"> <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 清空缓存<br>npm cache clean --force<br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 切换新源<br>npm config set registry https:<span class="hljs-regexp">//</span>registry.npmmirror.com<br> <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 查看源是否设置成功<br>npm config get registry<br> <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 安装<br>到这里就可以正常使用npm命令安装需要的工具了。如(   npm install -g cnpm   )<br></code></pre></td></tr></table></figure></li><li>错误原因：</li></ul><ul><li>2024年1 月 22 日，淘宝原镜像域名（registry.npm.taobao.org）的 HTTPS 证书正式到期。这就导致旧的 npm 淘宝镜像在使用时出错了。</li><li>所以，遇到上述问题，或者还在使用旧的 npm 淘宝镜像，直接将 npm 源切换到新的源即可。</li></ul><ul><li>过程中可能会遇到的其他问题：<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">npm cache clean <span class="hljs-attr">--force</span> 后报npm WARN using <span class="hljs-attr">--force</span> Recommended protections disabled<br></code></pre></td></tr></table></figure></li></ul><ul><li>解决方案：<code>npm cache verify</code>使用这个命令即可。</li></ul><h3 id="连接方面"><a href="#连接方面" class="headerlink" title="连接方面"></a>连接方面</h3><h4 id="1-解决-Github-SSH-连接超时"><a href="#1-解决-Github-SSH-连接超时" class="headerlink" title="1. 解决 Github SSH 连接超时"></a>1. 解决 Github SSH 连接超时</h4><p> 众所周知 Github 的网页端访问极其不稳定, 用 http 协议 clone 仓库的时候非常难受, 但是用公钥走 ssh 协议进行连接会稳定很多。</p><p>但是放寒假回家发现ssh也寄了 , 稳定连接超时, 本地一堆仓库都没办法进行推送。</p><ul><li>解决方案：<br>添加下面的配置:<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># # Override SSH settings</span><br><span class="hljs-comment"># vim ~/.ssh/config</span><br><span class="hljs-comment"># Add section below to it</span><br><span class="hljs-attribute">Host</span> github.com<br>  Hostname ssh.github.com<br></code></pre></td></tr></table></figure></li><li>错误原因：最近解析的主域名 github.com 的 IP 被彻底墙了, 但是供 ssh 连接的子域名 ssh.github.com IP 还活着。在<code>指定 Hostname 的情况下, Host 的作用是别名</code>。<br>也就是说这个配置项的作用其实是将所有连接到 github.com 的换到了 ssh.github.com.</li></ul><p>即，将现有的 github.com 主机名换一个可以用的 IP。</p><h3 id="python编程"><a href="#python编程" class="headerlink" title="python编程"></a>python编程</h3><h4 id="1-中文字体显示"><a href="#1-中文字体显示" class="headerlink" title="1.中文字体显示"></a>1.中文字体显示</h4><p>warning：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">findfont: Generic <span class="hljs-keyword">family</span> <span class="hljs-string">&#x27;sans-serif&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span> because <span class="hljs-keyword">none</span> <span class="hljs-keyword">of</span> the <span class="hljs-keyword">following</span> families were <span class="hljs-built_in">found</span>: Arial Unicode MS<br></code></pre></td></tr></table></figure><p>这个警告表明当前字体不包含一些需要在图表中显示的特定字符。这通常发生在使用 Matplotlib 绘制图形时，其中包含了需要显示的特定字符，但当前使用的字体不包含这些字符。这些警告并不会影响代码的执行。</p><ul><li>解决方案：<br>针对中文字符显示，可以使用一些常见的中文字体，如微软雅黑、宋体等。可通过以下方式来配置 Matplotlib 使用这些字体：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br># 指定使用的中文字体，如微软雅黑或宋体<br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>]  # 如果系统中有微软雅黑字体<br># plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimSun&#x27;</span>]  # 如果系统中有宋体字体<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路仿真Multisim使用指南</title>
    <link href="/2023/12/26/%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9FMultisim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/12/26/%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9FMultisim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>使用Multisim进行电路仿真。</p><span id="more"></span> <h2 id="安装Multisim"><a href="#安装Multisim" class="headerlink" title="安装Multisim"></a>安装Multisim</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p><a href="https://pan.baidu.com/s/1mmY5c3bc635i-Ybo36_TCA">百度网盘</a><br>提取码：3drh</p><h3 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h3><p><a href="https://blog.csdn.net/weixin_42773514/article/details/105255303">教程看这个，写的很详细了</a></p><h3 id="汉化-可选"><a href="#汉化-可选" class="headerlink" title="汉化 (可选)"></a>汉化 (可选)</h3><ul><li>在最开始解压的【Multisim14.0】文件夹中，右击【Chinese-simplified】文件夹，然后选择【复制】。</li><li>右击桌面上的【NI Multisim 14.0】，选择【打开文件所在的位置】。</li><li>双击打开【stringfiles】文件夹。</li><li>右击空白处，选择【粘贴】。确保将【Chinese-simplified】文件夹粘贴到【stringfiles】文件夹中。</li></ul><p>汉化过程结束，打开软件就是中文版的啦！</p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>Ctrl + W</code> ：打开元器件菜单</li><li><code>Ctrl + R</code> ：顺时针旋转元器件</li></ul><h2 id="示例：我的电路仿真实验报告-运算放大器应用-一-——负阻抗变换器和回转器的设计"><a href="#示例：我的电路仿真实验报告-运算放大器应用-一-——负阻抗变换器和回转器的设计" class="headerlink" title="示例：我的电路仿真实验报告  运算放大器应用(一)——负阻抗变换器和回转器的设计"></a>示例：我的电路仿真实验报告  运算放大器应用(一)——负阻抗变换器和回转器的设计</h2><h3 id="实验课程成绩：-优秀"><a href="#实验课程成绩：-优秀" class="headerlink" title="实验课程成绩： 优秀"></a>实验课程成绩： 优秀</h3><div class="row">    <embed src="/pdf/105_陈韵如_负阻抗变换器和回转器的设计.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于香橙派的程序自启动功能实现</title>
    <link href="/2023/10/24/%E9%A6%99%E6%A9%99%E6%B4%BE%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <url>/2023/10/24/%E9%A6%99%E6%A9%99%E6%B4%BE%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>使目标程序在Ubuntu开机时自动运行。</p><span id="more"></span> <h2 id="方案一：启动配置文件"><a href="#方案一：启动配置文件" class="headerlink" title="方案一：启动配置文件"></a>方案一：启动配置文件</h2><h3 id="启动配置文件"><a href="#启动配置文件" class="headerlink" title="启动配置文件"></a>启动配置文件</h3><p>打开终端，切换到root账户，然后在&#x2F;usr&#x2F;share&#x2F;applications目录下创建一个名为test.desktop的启动配置文件。</p><ul><li><code>cd /usr/share/applications</code></li><li><code>sudo vim test.desktop</code><br>内容如下：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Version</span>=<span class="hljs-number">1.0</span><br><span class="hljs-attr">Name</span>=test<br><span class="hljs-attr">Exec</span>=/home/zoe04/.vs/UV/out/build/linux-release/UV   <span class="hljs-comment">###可执行文件的路径</span><br><span class="hljs-attr">StartupNotify</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">Categories</span>=System<span class="hljs-comment">;Utility;Archiving;</span><br></code></pre></td></tr></table></figure> PS.如果你的ubuntu禁用了root账户，只是登录用户，那么你需要手动更改该启动配置文件的权限：</li><li>查看文件权限：<code>ls -l /etc/xdg/autostart/test.desktop</code><ul><li>如果显示：-rw-r–r–，那么表示只有读取权限。<br>  (毕竟只有root用户具有写入权限，而其他用户只有读取权限。)</li></ul></li><li>更改权限：<code>sudo chown &lt;你的用户名&gt; /etc/xdg/autostart/test.desktop</code></li><li>确保文件具有可执行文件：<code>sudo chmod +x /etc/xdg/autostart/test.desktop </code></li></ul><h3 id="移动文件到指定目录下"><a href="#移动文件到指定目录下" class="headerlink" title="移动文件到指定目录下"></a>移动文件到指定目录下</h3><p>将test.desktop文件拷贝到&#x2F;etc&#x2F;xdg&#x2F;autostart目录下：</p><ul><li><code>sudo cp /usr/share/applications/test.desktop /etc/xdg/autostart/test.desktop</code></li></ul><h3 id="重启你的Ubuntu即可"><a href="#重启你的Ubuntu即可" class="headerlink" title="重启你的Ubuntu即可"></a>重启你的Ubuntu即可</h3><p>注意：通常情况下，sudo reboot 会在不要求重新登录的情况下重启计算机。因此，不要用这个指令重启。<br>这个.desktop文件是使程序在<code>用户登录后自动启动</code>。</p><h2 id="方案二：写一个脚本"><a href="#方案二：写一个脚本" class="headerlink" title="方案二：写一个脚本"></a>方案二：写一个脚本</h2><h3 id="编写-sh脚本"><a href="#编写-sh脚本" class="headerlink" title="编写.sh脚本"></a>编写.sh脚本</h3><ul><li><code>nano my_cpp_startup_script.sh</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash </span><br>/path/to/your_executable<br></code></pre></td></tr></table></figure></li><li>授予脚本可执行权限:<br><code>chmod +x my_cpp_startup_script.sh</code></li><li>将脚本移动到<code>/etc/init.d/</code>目录<br> <code>sudo mv my_cpp_startup_script.sh /etc/init.d/</code></li><li>使用适用于你的Linux发行版的方法启用开机自启动。<br>对于Systemd-based系统，可以使用systemctl：<br><code>sudo systemctl enable my_cpp_startup_script.sh</code></li></ul><h4 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h4><ul><li>sudo systemctl enable test.sh<br>终端输出：<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span>.service is not a native service, redirecting to systemd-sysv-install.<br>Executing: /lib/systemd/systemd-sysv-install enable <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span><br><span class="hljs-keyword">update</span>-rc.<span class="hljs-keyword">d</span>: <span class="hljs-keyword">error</span>: <span class="hljs-keyword">test</span>.<span class="hljs-keyword">sh</span> Default-Start contains <span class="hljs-keyword">no</span> runlevels, aborting.<br></code></pre></td></tr></table></figure>原因：test.sh没有定义适当的Default-Start和Default-Stop runlevels。<br><code>解决方案：创建一个systemd服务单元文件，并在其中定义test.sh的启动和停止行为</code></li><li>创建一个systemd服务单元文件，比如test.service：<br><code>sudo nano /etc/systemd/system/test.service</code></li><li>编辑文件内容（确保替换&#x2F;path&#x2F;to&#x2F;your&#x2F;test.sh为test.sh脚本的绝对路径）<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Your Test Script<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">ExecStart</span>=/bin/bash /path/to/your/test.sh<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure></li><li>保存并关闭文件。<ul><li><code>ctrl^O</code>：保存文件</li><li>按下<code>Enter</code>键确认保存</li><li><code>ctrl^X</code>：退出</li></ul></li><li>启用并启动这个新的systemd服务：<ul><li><code>sudo systemctl enable test.service</code></li><li><code>sudo systemctl start test.service</code></li></ul></li></ul><p>现在，test.sh脚本<code>应该</code>被设置为在系统启动时自动执行。</p><ul><li>检查服务状态：<br><code>sudo systemctl status test.service</code></li><li>问题解决，成功运行~<br><img src="/images/%E9%A6%99%E6%A9%99%E6%B4%BE%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/img1.png" alt="运行成功截图"></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS2022编码问题</title>
    <link href="/2023/10/23/VS2022%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/23/VS2022%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Visual Studio默认的文件编码方式为GB2312,如何设置为更加通用的UTF-8呢?</p><p>本篇提供了一劳永逸更改编码方式为<code>UTF-8 with BOM</code>的解决方案。</p><span id="more"></span><h2 id="如何查看文件的编码方式"><a href="#如何查看文件的编码方式" class="headerlink" title="如何查看文件的编码方式"></a>如何查看文件的编码方式</h2><p>Visual Studio 设置默认编码格式在“高级保存选项”窗口中，可通过“文件”菜单打开；但有时“文件”菜单没有显示“高级保存选项”，需要把它显示出来。</p><p>单击“工具”，在弹出的菜单选择“自定义”，打开“自定义”窗口；选择“命令”选项卡，点击“菜单栏”右边的下拉列表框，要弹出的选项中选择“文件”；单击“添加命令”，在打开的窗口中，把左边列表框的滚动条拖到最下面，选择“文件”，再把右边列表框的滚动条往下拖一拖到看到“高级保存选项”，选择它，则它被添加到“文件”菜单。操作过程步骤如图1所示：</p><p><img src="/images/VS2022%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/img4.gif" alt="图示"></p><h2 id="一种可行方案（但不够一劳永逸）"><a href="#一种可行方案（但不够一劳永逸）" class="headerlink" title="一种可行方案（但不够一劳永逸）"></a>一种可行方案（但不够一劳永逸）</h2><ul><li>单击“文件”，在弹出的菜单选择“高级保存选项”</li><li>打开“高级保存选项”窗口，查看当前设置的编码为“简体中文（GB2312-80）</li><li>点击“编码”下拉列表框，把滚动条拖到最上面，选择“Unicode(UTF-8 带签名)”</li></ul><center class="half"><img src="/images/VS2022编码问题/img1.png" width="365/"><img src="/images/VS2022编码问题/img2.png" width="300/"></center><ul><li>单击“确定”，则 Visual Studio 设置默认编码格式为 UTF-8<br>如果工程庞大得一个一个设置，很麻烦,因此，介绍另一种解决方案：<code>使用editorconfig文件</code>，统一代码规范，从而统一编码问题。</li></ul><h2 id="使用editorconfig文件统一代码规范"><a href="#使用editorconfig文件统一代码规范" class="headerlink" title="使用editorconfig文件统一代码规范"></a>使用editorconfig文件统一代码规范</h2><p>自Visual Studio 2019 起，可以通过<code>“工具” &gt; “选项”&gt;&quot;文本编辑器&quot;基于代码样式设置</code>生成 EditorConfig 文件。<br>基于目标的开发语言，比如我这里选择的语言是C++,在代码样式里，可以找到基于代码样式设置生成 EditorConfig 文件。<br><img src="/images/VS2022%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/img3.png" alt="图示"><br>生成后，在该文件中加入:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">#编码方式,有以下几种类型：latin1, utf<span class="hljs-string">-8</span>, utf<span class="hljs-string">-8</span>-bom, utf<span class="hljs-string">-16</span>be, utf<span class="hljs-string">-16</span>le<br>charset = utf<span class="hljs-string">-8</span>-bom<br></code></pre></td></tr></table></figure><p>保存即可。<br>当新建项目时，将这个文件是放到项目路径下即可。</p><hr><p>参考资料连接：</p><ul><li><a href="https://blog.csdn.net/qq_41868108/article/details/105750175">https://blog.csdn.net/qq_41868108/article/details/105750175</a></li><li><a href="https://blog.csdn.net/no_say_you_know/article/details/121146469">https://blog.csdn.net/no_say_you_know/article/details/121146469</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摄像头选型</title>
    <link href="/2023/10/19/%E7%9B%B8%E6%9C%BA%E9%80%89%E5%9E%8B/"/>
    <url>/2023/10/19/%E7%9B%B8%E6%9C%BA%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>怎么挑选合适的摄像头呢？</p><p>参考：曾佬的《了解CV和RoboMaster视觉组》</p><span id="more"></span> <p>不同焦距的镜头其视距和视野范围不同，一般来说，<code>视距大（看的远）的镜头，其视野范围小 （可视角小）；而视距短（看的近些）的镜头，视野范围大</code>。</p><p>现在的手机的摄影系统都是由多个镜头组成的，每个镜头的焦距一般不同，从而适应不同焦段和视野的摄影需求。高级的镜头通常可以调节光圈大小，从而改变镜头的进光量。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>比赛中的任务需求催生了对摄像头成像效果的要求。拿RM的各兵种需要的摄像头举例：</p><ul><li>普通步兵：广角镜头（适用近战，可视角广）或是6mm的镜头（中庸选择，兼顾长短）</li><li>打符的步兵：8mm、12mm的长焦镜头，获得更好的远距离成像效果</li><li>哨兵：可能配置两个相机，分别搭载广角镜头和中短焦镜头，广角用于“广撒网”，对敌方目标进行大致定位，之后交由另外一个相机进行精确定位。</li></ul><h3 id="镜头选型工具"><a href="#镜头选型工具" class="headerlink" title="镜头选型工具"></a>镜头选型工具</h3><p><a href="https://www.hikrobotics.com/cn/machinevision/visionproduct?typeId=40&id=247">海康机器人-镜头选型工具</a>:<br>输入参数可以自动计算需要的视场角和靶面尺寸、焦距等，不过它推荐的肯定是自家产品，只需拿着参数自行联系经销商或去tb上找平替款即可。</p><h4 id="像素尺寸"><a href="#像素尺寸" class="headerlink" title="像素尺寸"></a>像素尺寸</h4><p>像素是组成图象的最基本单元要素：点。分辨率是指在长和宽的两个方向上各拥有的像素个数。</p><h3 id="相机畸变"><a href="#相机畸变" class="headerlink" title="相机畸变"></a>相机畸变</h3><p>由于凸透镜本身的性质和镜头制造的工艺问题，光线在通过镜头时无法保持物体在空间中原本的位置关系，成像会发生畸变。通过相机标定来去除这种畸变以便还原图像中物体的真实位置。(之前的博客有更新这个！)</p><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>光圈就是镜头前面可以开闭的小扇叶。（M12镜头一般不可以调节光圈，但板级工业相机一般有一个“auto aperture”的选项，可以根据环境亮度调节“虚拟光圈”，毕竟上面没有机械光圈）。</p><ul><li>不同光圈大小代表不同的镜头开度，影响镜头的进光量。一般用f值刻画光圈的开合程度，<code>f越小说明通光孔的直径越大</code>。</li><li>光圈还和成像的景深有关系，越大的光圈得到的景深越小，即成清晰像的范围越小。</li><li>不可追求景深而将光圈缩得太小。一方面是进光量大大下降（平方反比级），另一方面是光在通过小孔的时候会有强烈的衍射现象，导致像的边缘模糊，边界不够锐利。</li></ul><p>因此，在调大光圈提高进光量的同时，能够成清晰像的距离范围就缩小了。二者需要权衡。也可以通过调节其他参数来提高画面的亮度和可视性：<code>曝光时间、增益、gamma</code>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雷达的一丢丢科普</title>
    <link href="/2023/09/13/%E9%9B%B7%E8%BE%BE%E7%9A%84%E4%B8%80%E4%B8%A2%E4%B8%A2%E7%A7%91%E6%99%AE/"/>
    <url>/2023/09/13/%E9%9B%B7%E8%BE%BE%E7%9A%84%E4%B8%80%E4%B8%A2%E4%B8%A2%E7%A7%91%E6%99%AE/</url>
    
    <content type="html"><![CDATA[<p>雷达是一种使用无线电波来检测物体并测量其距离、速度和方向的系统，被广泛用于航空航天，导航，天气预报和军事领域。</p><span id="more"></span><h2 id="雷达的概念"><a href="#雷达的概念" class="headerlink" title="雷达的概念"></a>雷达的概念</h2><p>雷达是英文”Radar”的音译，意思为无线电探测和测距。即用无线电的方法发现目标，并测定他们的空间位置。因此，雷达也被称为“无线电定位”。</p><center class="half"><img src="/images/雷达/p4.png" width="200/"><img src="/images/雷达/p7.png" width="330/"></center><p>雷达的基本任务是测定有关目标的距离，高度，方向，速度等距离参数。各种雷达的用途和结构不尽相同，但基本原理是一致的；主要由天线，发射机，接收机，信号处理机，显示器等组成。</p><img align="right" src="/images/雷达/p10.png">雷达发射机产生足够的电磁能量，经过收发转换开关传送给天线。天线将这些电磁能量辐射出去，集中在某一个很窄的方向上，形成波束，向前传播。当电磁波遇到波束内的目标后，将沿着各个方向产生发射，其中的一部分电磁能量反射回雷达的方向，被雷达天线获取。天线获取的发射信号经过收发转换开关送到接收机，形成雷达的回波信号。由于雷达的回波信号非常微弱，有时甚至会被噪音所淹没，因此，需要接收机放大微弱的回波信号，经过信号处理机处理，提取出包含在回波中的信息，再送到显示器中。显示器就能显示出目标的距离，方向，速度等各项参数。<h2 id="Radar和Lidar的辨析"><a href="#Radar和Lidar的辨析" class="headerlink" title="Radar和Lidar的辨析"></a>Radar和Lidar的辨析</h2><p>当下智能驾驶和无人机领域十分火热，大家常常听说到的激光雷达（Lidar），其实跟我们今天介绍的雷达不太一样。相较于雷达，全称是<code>radio detection and ranging </code>中文翻译为电磁波的探测和测量；激光雷达的全称是 <code>light detection and ranging</code>，中文翻译为光的探测和测量。</p><p>两者的本质区别在于发射的信号不同。雷达在二战期间开始发展，而激光雷达技术则是在1960年激光器被发明后不久才开始被大规模运用起来。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/p2.png" alt="激光雷达原理图"></p><p>激光雷达的基本原理和雷达相同，但是由于激光光源与无限电波相比具有更高的相干性和准直度，因此在空间中传播时不易发生干涉和衍射等现象，它可以检测物体的形状和位置，构建精确度极高的图像。</p><iframe src="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Uriah%E6%9B%B4%E6%96%B0%E8%A7%86%E9%A2%91/%E5%AE%A4%E5%86%85%E5%90%88%E6%88%90_%E4%BD%8E%E6%AF%94%E7%89%B9%E7%8E%87_for%20webpage_an.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Uriah%E6%9B%B4%E6%96%B0%E8%A7%86%E9%A2%91/%E8%A1%8C%E4%BA%BA%E6%A3%80%E6%B5%8B_%E5%AE%A4%E5%A4%96small%20size_composer_an.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>radar和lidar相比有着更长的发展时间和技术成熟度，且更适应恶劣环境；而lidar成本更高，虽然有着更高的精度，但更适用于常规的场景。两者在军事和民用领域都有着各自的优势。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/%E5%AF%B9%E6%AF%94%E9%9B%B7%E8%BE%BE%E5%92%8C%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE.png" alt="对比雷达和激光雷达"></p><h2 id="雷达的发展"><a href="#雷达的发展" class="headerlink" title="雷达的发展"></a>雷达的发展</h2><h3 id="最初的老式雷达"><a href="#最初的老式雷达" class="headerlink" title="最初的老式雷达"></a>最初的老式雷达</h3><p>老式的雷达一般都长这样， 有点像卫星电视的接收器，通过刚才我介绍的雷达基本原理，可以将雷达比作一个手电筒，在未知的周围环境中，通过发送电磁能量，探测目标，就像手电筒一样，指哪哪里就亮。</p><center class="half"><img src="/images/雷达/pp.png" width="365/"><img src="/images/雷达/pop.png" width="300/"></center>老式的雷达有一个可以旋转的脖子，将雷达天线转来转去，以探测不同的方向，至于天线没转到的方向，就是雷达的视野盲区了。<p><img src="/images/%E9%9B%B7%E8%BE%BE/ppp.jfif" alt="雷达的显示屏"><br>传统雷达的显示屏长这样，屏幕上旋转的亮条，就是雷达正探测到的地方，被照到的目标物体会在显示屏中标记出来其对于雷达参考系原点的相对坐标。<br>不过，这个坐标只是目标物体在被探测到的时刻的位置，要想知道目标下一时刻的位置，就得等雷达下一次转过来再次探测到它。这显得非常不灵活，对于目标信息的获取也是滞后的。</p><h3 id="相控阵雷达"><a href="#相控阵雷达" class="headerlink" title="相控阵雷达"></a>相控阵雷达</h3><p>为了解决这个问题，后面就出现了相控阵雷达，顾名思义，就是相位控制电子扫描阵列雷达。它不再像之前的雷达那样将天线转来转去，而是利用雷达面板上的每一个最小探测单元发出电信号的相位差来控制探测方向。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p9.png" alt="相控阵雷达"><br>相控阵雷达可以利用电信号的控制，一秒钟对目标空域扫描成百上千次，还可以一边扫描空域，一边连续跟踪若干个目标。相控阵雷达的显示屏上不再有一根旋转的扫描线，而是整个屏幕都常亮。当今国内外研制的舰载雷达，机载雷达，弹道导航防御雷达以及星载雷达均采用有源相控阵雷达天线。</p><h3 id="现代雷达的技术发展"><a href="#现代雷达的技术发展" class="headerlink" title="现代雷达的技术发展"></a>现代雷达的技术发展</h3><p>雷达起源于二战期间，在二战之后进入高速发展阶段。而现代的雷达，具有五大看家绝活,三大智能技术。<br>其中，五大看家绝活分别是：</p><ul><li>脉冲压缩技术：让雷达看得更远；</li><li>动目标显示：让雷达发现运动的目标；</li><li>恒虚警检测：让雷达更精确的发现目标；</li><li>相控阵点扫：让雷达不需要旋转，看得更快；</li><li>脉冲多普雷技术：解决了机载雷达只能向前看不能向下看的问题，让雷达看得更全面。</li></ul><p>三大智能技术分别是：</p><ul><li>雷达微波成像（SAR）</li><li>目标识别技术（ATR）</li><li>反干扰技术(ECCM)。</li></ul><p>通过字面意思可以看出，它们的作用分别是给目标进行画像、准确识别目标是什么物体以及反干扰技术。大家熟知的“萨德”就是将目标识别技术运用到弹道导弹识别中比较成功的装备。</p><h3 id="中国雷达的发展史"><a href="#中国雷达的发展史" class="headerlink" title="中国雷达的发展史"></a>中国雷达的发展史</h3><p>介绍完雷达，再来介绍一下我们中国的雷达。说到中国雷达，就不得不说到南京的小红楼。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/p1.png" alt="小红楼"><br>1946年，国民党国防部第六厅在南京征地80亩，建立了“特种电讯器材修理所”，也就是后来被誉为中国雷达工业发源地的“小红楼”。49年建国之后，雷达研究所逐渐发展成为目前的中国电科14所。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p3.png" alt="中国电科"></p><p>从小红楼开始，中国的雷达工业从无到有，从落后到先进，到了今天，中国的雷达已经形成了<code>陆海空天四维一体</code>的装备体系：</p><ul><li><p>陆：陆基雷达作为国土防空的主力装备，守护着我们国土的每一个角落；<br><img src="/images/%E9%9B%B7%E8%BE%BE/p11.png" alt="陆载雷达"></p></li><li><p>海：中国海军拥有全球顶尖的有源相控阵雷达，近年来下水的“辽宁舰”、“山东舰”等举世瞩目的海上“大国重器”，均有舰载有源相控阵雷达的保驾护航。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p12.png" alt="舰载雷达"></p></li><li><p>空：机载火控雷达作为战斗机实施火力攻击的眼睛和向导，决定着战斗机的战斗水平，对取得战斗的胜利至关重要。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p13.png" alt="机载雷达"></p></li><li><p>天：从航天发射场到国内其他测量站点，从陆地到深航远海的测量船；我们的精密测量雷达组成了一个巨大的陆海基航天测控网，在茫茫宇宙中对飞船的发射，运行，回收，实施空中的跟踪接力。使飞船始终置于被探测，追踪和控制之中。<br><img src="/images/%E9%9B%B7%E8%BE%BE/%E6%9C%80%E5%90%8E%E4%B8%80%E5%BC%A0.png" alt="陆海基航天测控网"></p></li></ul><p>简单介绍完中国雷达的发展史，接下来，让我的另外两位朋友具体介绍一下中国雷达在军事上的三种具体的应用类别：陆载雷达、机载雷达、舰载雷达。</p>]]></content>
    
    
    <categories>
      
      <category>长见识了</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科普小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV配置教程</title>
    <link href="/2023/09/11/OpenCV%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <url>/2023/09/11/OpenCV%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>尊嘟很好用！！</p><span id="more"></span> <h1 id="Windows系统下的配置方式"><a href="#Windows系统下的配置方式" class="headerlink" title="Windows系统下的配置方式"></a>Windows系统下的配置方式</h1><p><strong>Step1 下载并安装OpenCV</strong></p><p>访问 <a href="https://opencv.org/releases/">Releases - OpenCV</a> 找到最新版的OpenCV（在最上方且标有*号），点击“Windows”按钮下载。</p><p>下载完成后，将得到的zip文件就地解压，双击里面的distrib.7z.exe，会出现界面Extract to（解压至），如图将下面的文本框中的内容修改为“D:\”，指明OpenCV的安装路径为D盘根目录。</p><p><img src="/images/image/136cf546-0a1f-4c4d-8365-359a4699e60f.png"></p><p><strong>Step2 配置环境变量</strong></p><p>打开 D:\opencv\build\x64 文件夹，内装有命名风格类似“vc**”的文件夹</p><p>按下Windows键，输入env，点击“编辑系统环境变量”</p><p><img src="/images/image/158523ee-7503-4f71-a918-dab6a2062171.png"></p><p>在弹出的对话框中，点击“环境变量(N)”，会弹出一个新对话框，选择“Path”，点击“编辑”</p><p><img src="/images/image/7f6caa9d-3fcd-49a6-b3e7-6c9b1cc72cf4.png"></p><p>如图所示，点击“新建”，把刚才的文件夹按照 D:\opencv\build\x64\vc**\bin 的格式添加进去。</p><p>注意：如果有一个文件夹就添加一项，如果有两个文件夹就添加数字大的那一项，不要遗漏后面的 “\bin”。</p><p><img src="/images/image/be22d535-60a8-4eb1-862d-d0b2c61f5c7b.png"></p><p><strong>Step3 配置openCV.props</strong></p><p>这里要分两种情况讨论，请先打开本文件同目录下的openCV.props文件，在第五行有注释：文件适用于OpenCV *.*.*。</p><p>情况1：该文件与你安装的OpenCV版本一致，那么非常简单，你只需要将文件拷贝到 D:\openCV\openCV.props 处，即可完成配置。</p><p>情况2：该文件与你安装的OpenCV版本不一致（版本过旧），那么你需要对此文件做如下修改。</p><ol><li>将&lt;LibraryPath&gt;中 vc** 的数字改为你刚才添加进环境变量中的那个数字<br><img src="/images/image/ac1d4a74-0807-44d1-a123-3e593f709e06.png"></li><li>打开刚才LibraryPath中的文件夹 D:\opencv\build\x64\vc**\lib，找到里面命名风格类似opencv_world***.lib的文件，把&lt;AdditionalDependencies&gt;中opencv_world***.lib的数字改为这个文件的数字（注意不要有d）。<br><img src="/images/image/5ca41cc8-22f5-4580-9063-abc30d9dce88.png"></li><li>保存修改，把文件拷贝到 D:\openCV\openCV.props 处，完成配置。</li></ol><p>完成后的opencv目录如图所示。</p><p><img src="/images/image/83d0fbf8-9431-4c3d-a1e8-b34dfea2af35.png"></p><p><strong>Step4 重启电脑</strong></p><p>修改环境变量后，一般要重启才能生效，请重启你的电脑。</p><p><strong>Step5 在vs项目中引用openCV.props属性文件</strong></p><p>每次新建项目之后，只需要将属性表放到项目路径下，并添加到项目中就可以使用了。</p><p><code>添加属性表</code>：先把属性表复制、粘贴到当前项目的项目文件夹中，然后打开“属性管理器”，找到对应的“模式”和“位数”，例如“Debug|x64”，然后点击鼠标右键选择“添加现有属性表”，把复制、粘贴好的属性表文件添加进来即可。</p><h1 id="Linux-系统下的配置方式"><a href="#Linux-系统下的配置方式" class="headerlink" title="Linux 系统下的配置方式"></a>Linux 系统下的配置方式</h1><p>OpenCV 官方支持 clang 编译器与 ninja 编译系统。</p><p>clang 编译器有着不俗的编译速度，ninja 构建系统编译较为智能快速。</p><p>本篇博客使用 ninja 作为编译系统，使用 clang 作为编译器</p><h3 id="1-配置编译C-程序的环境"><a href="#1-配置编译C-程序的环境" class="headerlink" title="1.配置编译C++程序的环境"></a>1.配置编译C++程序的环境</h3><p>先检查一下linux系统是否安装了gcc：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">gcc <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><ul><li><code>sudo apt-get update</code></li><li>安装<blockquote><p>刚装好的新系统中是已经安装了GCC的，但是这个GCC什么文件都不能编译，因为没有一些必须的头文件，所以要安装build-essential这个软件包，安装了这个包会自动安装上g++,libc6-dev,linux-libc-dev,libstdc++6-4.1-dev等一些必须的软件和头文件的库。</p></blockquote>  <code>sudo apt-get install build-essential</code></li></ul><h3 id="2-在opencv官网下载opencv（linux版本）"><a href="#2-在opencv官网下载opencv（linux版本）" class="headerlink" title="2.在opencv官网下载opencv（linux版本）"></a>2.在opencv官网下载opencv（linux版本）</h3><p>网址：<a href="https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html">https://docs.opencv.org/4.x/d7/d9f/tutorial_linux_install.html</a><br><img src="/images/image/p1.png" alt="将opencv包放到/home目录下"></p><h3 id="3-安装编译依赖"><a href="#3-安装编译依赖" class="headerlink" title="3.安装编译依赖"></a>3.安装编译依赖</h3><ul><li><code>sudo apt install -y g++</code></li><li><code>sudo apt install -y cmake</code></li><li><code>sudo apt install -y make</code></li><li><code>sudo apt install -y ninja-build</code></li><li><code>sudo apt install -y wget unzip</code></li><li><code>sudo apt-get install build-essential libgtk2.0-dev libgtk-3-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev</code></li></ul><h3 id="4-配置和构建"><a href="#4-配置和构建" class="headerlink" title="4.配置和构建"></a>4.配置和构建</h3><p>解压OpenCV-4.7.0，进入opencv源码文件夹，打开终端。</p><ul><li><code>mkdir -p build &amp;&amp; cd build</code></li></ul><p>使用ninja来配置会比较快：</p><ul><li><code>cmake -GNinja ../opencv</code></li><li><code>ninja</code><br><img src="/images/image/p2.png" alt="构建成功"></li></ul><h3 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h3><ul><li><code>sudo ninja install</code><br></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模绘图学习笔记</title>
    <link href="/2023/09/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%98%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%98%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>常用的数学建模绘图的方法整理</p><span id="more"></span> <h2 id="Python使用Matplotlib进行绘图"><a href="#Python使用Matplotlib进行绘图" class="headerlink" title="Python使用Matplotlib进行绘图"></a>Python使用Matplotlib进行绘图</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>画板figure，画纸Sublpot画质，可多图绘画</li><li>画纸上最上方是标题title，用来给图形起名字</li><li>坐标轴Axis,横轴叫x坐标轴label，纵轴叫y坐标轴ylabel</li><li>图例Legend 代表图形里的内容</li><li>网格Grid，图形中的虚线，True显示网格</li><li>点 Markers：表示点的形状。</li></ul><center class="half"><img src="/images/MathematicsModeling/p10.png" width="300/"><img src="/images/MathematicsModeling/p11.png" width="300/"></center><h3 id="基础绘图步骤"><a href="#基础绘图步骤" class="headerlink" title="基础绘图步骤"></a>基础绘图步骤</h3><ul><li>导入matplotlib的pyplot模块<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure></li><li>用列表定义X、Y坐标轴上的值</li><li>绘制图形<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">plt.plot<span class="hljs-comment">(x,y)</span><br></code></pre></td></tr></table></figure></li><li>显示图形<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">plt.<span class="hljs-keyword">show</span>()<br></code></pre></td></tr></table></figure></li></ul><h4 id="一些语法注释："><a href="#一些语法注释：" class="headerlink" title="一些语法注释："></a>一些语法注释：</h4><ul><li>plt.figure(num&#x3D;1, figsize&#x3D;(8, 5))<ul><li><code>num=1</code>: 这个参数指定了新创建的图形窗口的编号,后面可通过 <code>plt.figure(1)</code>来指定或者切换到该图形窗口。</li></ul></li><li>ax &#x3D; plt.gca()<ul><li><code>plt.gca()</code>用于获取当前图形的坐标轴对象（Axes），返回当前图形中的当前坐标轴对象。可使用返回的坐标轴对象来修改坐标轴的属性、添加标签、设置刻度等。</li><li>eg:<br>  ax.set_xlabel(‘X轴标签’)<br>ax.set_ylabel(‘Y轴标签’)<br>ax.set_title(‘图形标题’)</li></ul></li><li>ax.spines[‘right’].set_color(‘none’) <br>ax.spines[‘top’].set_color(‘none’)<br>隐藏图形中右侧和顶部的坐标轴线条。<ul><li><code>ax.spines[&#39;right&#39;] </code>表示获取坐标轴对象 ax 中右侧边框（spine）的属性。<br><code>.set_color(&#39;none&#39;) </code>表示将右侧边框的颜色设为 ‘none’，即不显示右侧边框线条。</li></ul></li></ul><h3 id="图片属性设置"><a href="#图片属性设置" class="headerlink" title="图片属性设置"></a>图片属性设置</h3><ul><li>添加文本<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;X轴文本&#x27;</span>)<br>plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;Y轴文本&#x27;</span>)<br>plt<span class="hljs-selector-class">.title</span>(<span class="hljs-string">&#x27;标题文本&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>添加注释<ul><li>xy&#x3D;(5,2)：需要注释的点的位置</li><li>xytext&#x3D;(2,10)：注释文本所在位置</li><li>arroprops：在xy和xytext之间绘制箭头，shrink表示箭头粗细<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.annotate(<span class="hljs-string">&#x27;注释文本&#x27;</span>，xy=(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>),xytext=(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>),arroprops=<span class="hljs-built_in">dict</span>(facecolor=<span class="hljs-string">&#x27;black&#x27;</span>，shrink=<span class="hljs-number">0.01</span>))<br><br><span class="hljs-comment">##复杂一点的注释方式</span><br>plt.annotate(<span class="hljs-string">r&#x27;$2x+1 = %s$&#x27;</span> % y0, xy=(x0, y0), xycoords=<span class="hljs-string">&#x27;data&#x27;</span>,<br>             xytext=(+<span class="hljs-number">30</span>, -<span class="hljs-number">30</span>), textcoords=<span class="hljs-string">&#x27;offset points&#x27;</span>, fontsize=<span class="hljs-number">16</span><br>             , arrowprops=<span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&#x27;-&gt;&#x27;</span>,<br>                               connectionstyle=<span class="hljs-string">&quot;arc3,rad=.2&quot;</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li>绘图属性<ul><li>color：线条颜色，值r表示红色（red）</li><li>marker：点的形状，值o表示点为圆圈标记（circle marker）</li><li>linestyle：线条的形状，值dashed表示用虚线连接各点</li><li>axis：坐标轴范围,语法为<code>axis[xmin, xmax, ymin, ymax]</code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">plt<span class="hljs-selector-class">.plot</span>(x, y, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;r&#x27;</span>,marker=<span class="hljs-string">&#x27;o&#x27;</span>,linestyle=<span class="hljs-string">&#x27;dashed&#x27;</span>)<br><span class="hljs-selector-id">#plt</span><span class="hljs-selector-class">.plot</span>(x, y, <span class="hljs-string">&#x27;ro&#x27;</span>)<br><br>plt<span class="hljs-selector-class">.axis</span>(<span class="hljs-selector-attr">[0, 6, 0, 20]</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>把坐标轴换成不同的单位：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">new_ticks = np.linspace(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>plt.xticks(new_ticks)<br><br><span class="hljs-comment">#在对应坐标处更换名称</span><br>plt.yticks([-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">&#x27;really bad&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;good&#x27;</span>])<br><span class="hljs-comment">#把坐标轴上的字体更改成数学符号字体形式</span><br>plt.yticks([-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">r&#x27;$really\ bad$&#x27;</span>,<span class="hljs-string">r&#x27;$b$&#x27;</span>,<span class="hljs-string">r&#x27;$c\ \alpha$&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;good&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/MathematicsModeling/p12.png" alt="绘图属性设置"></p><ul><li>使用<code>legend</code>去区分一个figure中的多条线<ul><li>如果没有在legend方法的参数中设置<code>label</code>，则必须在画线的plot方法中指定的label参数所指定的名称。都没有的话就会抛出异常；</li><li>其实我们<code>plt.plot()</code>的时候返回的是一个线的对象，如果我们想在handle中使用这个对象，就必须在返回的名字的后面加一个<code>,</code>号；</li></ul></li><li><code>偏移坐标系（offset coordinates）</code>是 Matplotlib 中用于指定文本或注释位置的一种坐标系。在偏移坐标系中，位置相对于指定的点进行偏移。偏移坐标系允许以点（points）为单位指定文本或注释相对于目标点的偏移量。可相对于目标点在水平和垂直方向上进行任意的偏移。<br>在 Matplotlib 中，偏移坐标系通过 textcoords&#x3D;’offset points’ 参数进行指定。然后，使用 xytext 参数来指定相对于目标点的偏移量。<br>例如，在 plt.annotate() 函数中，如果您将 textcoords 设置为 ‘offset points’，并且指定了 xytext 参数来指定偏移量，Matplotlib 将使用偏移坐标系来确定注释文本的位置。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#简单的使用图例</span><br>l1, = plt.plot(x, y1, <span class="hljs-attribute">label</span>=<span class="hljs-string">&#x27;linear line&#x27;</span>)<br>l2, = plt.plot(x, y2, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-attribute">linewidth</span>=1.0, <span class="hljs-attribute">linestyle</span>=<span class="hljs-string">&#x27;--&#x27;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&#x27;square line&#x27;</span>)<br> <br><span class="hljs-comment">#简单的设置legend(设置位置)</span><br><span class="hljs-comment">#图例位置显示在右上角</span><br>plt.legend(loc = <span class="hljs-string">&#x27;upper right&#x27;</span>)<br><span class="hljs-comment"># 自动显示图例位置</span><br>plt.legend(handles = [l1,l2],labels = [<span class="hljs-string">&#x27;up&#x27;</span>,<span class="hljs-string">&#x27;down&#x27;</span>],loc = <span class="hljs-string">&#x27;best&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="多图绘制"><a href="#多图绘制" class="headerlink" title="多图绘制"></a>多图绘制</h3><ul><li>使用figure()方法创建画板1</li><li>使用subplot()方法创建画纸，并选择当前画纸并绘图<ul><li>subplot是子图，<code>subplot(a,b,c)</code>，传入三个参数，前两个表示生成几行几列的子图矩阵，最后一个参数表示选择子图1还是2 </li><li>eg. <code>subplot(2,1,1)</code></li></ul></li><li>同样用subplot()方法选择画纸并绘图：<code>subplot(2,1,2)</code></li><li>显示图形<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#创建画板1</span><br><span class="hljs-attribute">fig</span> = plt.figure(<span class="hljs-number">1</span>) #如果不传入参数默认画板<span class="hljs-number">1</span><br><span class="hljs-comment">#第2步创建画纸，并选择画纸1</span><br><span class="hljs-attribute">ax1</span>=plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)   <br><span class="hljs-comment">#在画纸1上绘图</span><br><span class="hljs-attribute">plt</span>.plot([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">#选择画纸2</span><br><span class="hljs-attribute">ax2</span>=plt.subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-comment">#在画纸2上绘图</span><br><span class="hljs-attribute">plt</span>.plot([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-comment">#显示图像</span><br><span class="hljs-attribute">plt</span>.show()<br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/MathematicsModeling/p15.png" alt="简单的多图绘制"></p><h3 id="数组绘图"><a href="#数组绘图" class="headerlink" title="数组绘图"></a>数组绘图</h3><p>上面部分绘图时传入的数据是列表类型的，但是如果绘制图形只允许传入列表的话，绘制图形会变得很麻烦，因此：</p><p><code>一般传入numpy的数组</code>，实质上所有传入数据的类型在matplotlib内部处理时都会转化为numpy数组类型。</p><ul><li>第一步，导入numpy包，再用numpy的一维数组生成一个等差数组，用arange()方法。本例数组中的最小值为0，最大值为5，后一个数据比前一个大0.2。</li><li>第二步，定义三个折线图的坐标值，分别用x1,x2,x3表示三个坐标轴上x轴的数值，用y1,y2,y3表示y轴上的数值，这些坐标值都是一维数组。</li><li>第三步，绘制图形<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#导入包numpy</span><br>import numpy as np<br><span class="hljs-comment">#定义一维数组</span><br>t = np.arange(0, 5, 0.2)<br><br><span class="hljs-comment">#使用数组同时绘制多个线性</span><br><br><span class="hljs-comment">#线条1</span><br><span class="hljs-attribute">x1</span>=y1=t<br><span class="hljs-comment">#线条2</span><br><span class="hljs-attribute">x2</span>=x1<br><span class="hljs-attribute">y2</span>=t**2<br><span class="hljs-comment">#线条3</span><br><span class="hljs-attribute">x3</span>=x1<br><span class="hljs-attribute">y3</span>=t**3<br><span class="hljs-comment">#使用plot绘制线条</span><br><span class="hljs-attribute">linesList</span>=plt.plot(x1, y1,  <br>         x2, y2,  <br>         x3, y3 )<br><span class="hljs-comment">#用setp方法可以同时设置多个线条的属性</span><br>plt.setp(linesList, r)<br>plt.show()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;返回的数据类型&#x27;</span>,type(linesList))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据大小：&#x27;</span>,len(linesList))<br></code></pre></td></tr></table></figure></li></ul><h3 id="Line-style-线状图"><a href="#Line-style-线状图" class="headerlink" title="Line-style 线状图"></a>Line-style 线状图</h3><p>可用来绘制函数图像，示例代码见文件夹中例程。</p><center class="half"><img src="/images/MathematicsModeling/p13.png" width="400/"><img src="/images/MathematicsModeling/p14.png" width="400/"></center><h3 id="Scatter-style-散点图"><a href="#Scatter-style-散点图" class="headerlink" title="Scatter-style 散点图"></a>Scatter-style 散点图</h3><p><code>plt.scatter(X, Y, s=75, c=T, alpha=.5)</code></p><ul><li>使用 Matplotlib 的 <code>scatter()</code> 函数绘制散点图</li><li>X 和 Y 分别表示散点的 x 和 y 坐标</li><li>s 表示散点的大小，c 表示散点的颜色，alpha 表示散点的透明度。</li><li>设置了 x 轴和 y 轴的显示范围：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">plt</span>.xlim((-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>,<span class="hljs-number">1</span>.<span class="hljs-number">5</span>)) <br><span class="hljs-attribute">plt</span>.ylim((-<span class="hljs-number">1</span>.<span class="hljs-number">5</span>,<span class="hljs-number">1</span>.<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure></li><li>设置 x 轴和 y 轴的刻度:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"># 这里使用空列表表示不显示刻度<br>plt<span class="hljs-selector-class">.xticks</span>(<span class="hljs-selector-attr">[]</span>)<br>plt<span class="hljs-selector-class">.yticks</span>(<span class="hljs-selector-attr">[]</span>)<br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/MathematicsModeling/p16.png" alt="最简单的散点图"></p><ul><li>生成一个大小为 (n_points, 2) 的二维数组，数组中的值在范围 (-1, 9) 内随机分布，代表散点的坐标<ul><li>使用 NumPy 的 <code>random.random()</code> 函数生成一个大小为 (n_points, 2) 的二维数组，数组中的值是在返回的值范围在 [0, 1)的随机数</li><li>表示将生成的随机数组乘以 (10-1) 的范围，即将原始随机数范围缩放到 [0, 9)。</li><li>-1：将生成的随机数组中的所有元素都减去 1，使得最终的随机数范围从 [-1, 8)。</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pts</span> = (<span class="hljs-number">10</span>-<span class="hljs-number">1</span>)*np.random.random(size=(n_points ,<span class="hljs-number">2</span>))-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><p><code>创建标签字典</code>，将每个标签与其相应的标签名称进行关联</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">labels_dict</span> = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;pts_1&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;pts_2&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;pts_3&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;pots_4&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;pts_5&#x27;</span>&#125;：<br></code></pre></td></tr></table></figure></li><li><p><code>颜色映射规范化对象</code>:将数据范围映射到颜色映射的范围内</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">color_norm = colors.Normalize(<span class="hljs-attribute">vmin</span>=0, <span class="hljs-attribute">vmax</span>=4)<br></code></pre></td></tr></table></figure></li><li><p><code>np.unique()</code>:获取数组中唯一的值，并返回排序后的结果</p><ul><li>np.unique(labels) 将返回一个包含 labels 中唯一值的<code>一维数组</code>，并按照<code>从小到大的顺序排列</code>这些值。这个数组中的值将用于确定要显示的类别数量，并在后续的处理中用作索引。</li></ul></li><li><p><code>size=pts.shape[0] </code>表示生成的随机数数组的大小与 pts 数组的第一个维度相同，也就是 n_points</p></li><li><p><code>cmap=cm.Set1</code>: 这是指定的颜色映射。</p><ul><li>使用 cm.Set1 颜色映射，它是 Matplotlib 库中提供的一种颜色映射，包含了一组离散的颜色，适合用于区分不同的分类标签。</li></ul></li><li><p><code>enumerate(unique_labels) </code>是 Python 中的一个内置函数，它接受一个可迭代对象（例如列表、元组、字符串等）作为参数，并返回一个由索引和值组成的枚举对象，索引从 0 开始。</p><ul><li>unique_labels 是一个包含数据集中唯一标签的数组。因此在循环中能够同时访问标签的索引和值，方便对数据进行处理。</li><li>例如，如果 unique_labels 是 [0, 1, 2, 3, 4]，则 enumerate(unique_labels) 返回的枚举对象将是 [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]。</li></ul></li></ul><p><img src="/images/MathematicsModeling/p17.png" alt="有筛选规则的散点图"></p><ul><li><code>mask = np.where(labels == label)[0]</code>:<br>用于找到数组 labels 中与特定标签值 label 相匹配的索引<ul><li><code>np.where()</code> 函数接受布尔数组作为参数，返回一个元组，其中包含满足条件的元素的索引。</li><li>[0] 表示从返回的元组中取出索引数组，因为 np.where() 返回的是一个元组，包含所有满足条件的索引数组。通常情况下，我们只需要第一个满足条件的索引数组，因此使用 [0] 来取出。</li></ul></li><li>选取二维数组 pts 中的所有行，但只选取第一列(X)&#x2F;第二列(Y)的数据<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">pts<span class="hljs-selector-attr">[:, 0]</span><span class="hljs-selector-attr">[mask]</span><br>pts<span class="hljs-selector-attr">[:, 1]</span><span class="hljs-selector-attr">[mask]</span><br></code></pre></td></tr></table></figure></li><li><code>[mask] 使用布尔掩码 mask 来过滤选取的数据</code>。<ul><li>布尔掩码 mask 是一个布尔数组，其长度与数组 pts 的行数相同。对于数组 pts[:, 0] 和 pts[:, 1] 中的每个元素，如果<code>对应位置的 mask 元素为 True，则相应的元素会被选中，否则会被忽略</code>。</li></ul></li></ul><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><h3 id="python制作的柱状图"><a href="#python制作的柱状图" class="headerlink" title="python制作的柱状图"></a>python制作的柱状图</h3><p>代码解释：</p><ul><li><code>X = np.arange(n)</code><ul><li>创建一个包含0到n-1的数组，用作柱子的位置</li></ul></li><li>分别定义两组与X对应的柱子高度：Y1，Y2</li><li><code>plt.bar(X, +Y1, facecolor=&#39;#9999ff&#39;, edgecolor=&#39;white&#39;)</code><ul><li>创建一组柱状图，位于X位置，高度为Y1，面颜色为蓝色，边框颜色为白色</li><li>同理，<code>plt.bar(X, -Y2, facecolor=&#39;#ff9999&#39;, edgecolor=&#39;white&#39;)</code><br>   创建另一组柱状图，位于X位置，高度为-Y2，面颜色为红色，边框颜色为白色</li></ul></li><li>添加文字标签:<ul><li>通过循环遍历每个柱子的位置和高度，并在相应位置添加文字标签。  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> zip(X, Y1):<br><span class="hljs-comment"># 在柱子的顶部添加高度值,水平对齐方式为&#x27;center&#x27;，垂直对齐方式为&#x27;bottom&#x27;</span><br>plt.text(x + 0.01, y + 0.05, <span class="hljs-string">&#x27;%.2f&#x27;</span> % y, <span class="hljs-attribute">ha</span>=<span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-attribute">va</span>=<span class="hljs-string">&#x27;bottom&#x27;</span>)<br><br><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> zip(X, Y2):<br><span class="hljs-comment"># 在柱子的底部添加高度值，水平对齐方式为&#x27;center&#x27;，垂直对齐方式为&#x27;top&#x27;。</span><br>plt.text(x + 0.01, -y - 0.05, <span class="hljs-string">&#x27;%.2f&#x27;</span> % (-y), <span class="hljs-attribute">ha</span>=<span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-attribute">va</span>=<span class="hljs-string">&#x27;top&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>设置x轴和y轴的范围<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 设置x轴的范围为从-0.5到n</span><br><span class="hljs-attribute">plt</span>.xlim(-.<span class="hljs-number">5</span>, n)<br><span class="hljs-comment"># 设置y轴的范围为从-1.25到1.25</span><br><span class="hljs-attribute">plt</span>.ylim(-<span class="hljs-number">1</span>.<span class="hljs-number">25</span>, <span class="hljs-number">1</span>.<span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure></li><li>隐藏y轴刻度: <code>plt.yticks([])</code></li></ul><p><img src="/images/MathematicsModeling/p19.png" alt="双侧柱状图"></p><h3 id="excel制作的柱状图"><a href="#excel制作的柱状图" class="headerlink" title="excel制作的柱状图"></a>excel制作的柱状图</h3><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/78646791">https://zhuanlan.zhihu.com/p/78646791</a></p><h3 id="python绘制正态分布的直方图和概率密度函数曲线"><a href="#python绘制正态分布的直方图和概率密度函数曲线" class="headerlink" title="python绘制正态分布的直方图和概率密度函数曲线"></a>python绘制正态分布的直方图和概率密度函数曲线</h3><ul><li><code>np.random.normal()</code>:生成指定均值和标准差的正态分布随机数。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gaussian_numbers_1</span> = np.random.normal(size=<span class="hljs-number">100000</span>)<br><span class="hljs-attribute">gaussian_numbers_2</span> = np.random.normal(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, size=<span class="hljs-number">100000</span>)<br></code></pre></td></tr></table></figure></li><li>绘制正态分布的直方图和概率密度函数曲线<ul><li>绘制 gaussian_numbers_1 的直方图，并使用 <code>mlab.normpdf()</code>函数计算了该分布的<code>概率密度函数曲线</code>。</li><li>直方图的参数设置包括：<code>直方条的数目 (bins)</code>、<code>直方图的类型 (histtype)</code>、<code>直方条的宽度 (rwidth)</code>、<code>是否进行归一化 (normed)</code>、<code>颜色和透明度 (color 和 alpha)</code>。</li><li>在 plt.hist() 函数中，<code>n</code>、<code>bins</code> 和 <code>patches</code> 是返回的三个值。<ul><li>n: 是一个长度为 len(bins) - 1 的数组，其中每个元素代表了在对应区间内的<code>数据点数量</code>。</li><li>bins: 是一个包含<code>直方图柱子边界值</code>的数组。直方图通常是基于数据的范围和分布，被分割成若干个区间，这些区间就是通过 bins 参数指定的。</li><li>patches: 是一个包含所有直方图柱子的列表，每个柱子是一个图形对象，你可以通过修改它们的<code>属性</code>来自定义柱子的外观。</li></ul></li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">n, bins, patches = plt.hist(gaussian_numbers_1, <span class="hljs-attribute">bins</span>=30, <span class="hljs-attribute">histtype</span>=<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attribute">rwidth</span>=0.8, <span class="hljs-attribute">normed</span>=1, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-attribute">alpha</span>=0.5, <span class="hljs-attribute">label</span>=<span class="hljs-string">&#x27;Gaussian_1&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/MathematicsModeling/p21.png" alt="正态分布的直方图和概率密度函数曲线"></p><h2 id="权重图、热力图、三维地图"><a href="#权重图、热力图、三维地图" class="headerlink" title="权重图、热力图、三维地图"></a>权重图、热力图、三维地图</h2><p>表示相关位置的重要程度。</p><h3 id="权重图"><a href="#权重图" class="headerlink" title="权重图"></a>权重图</h3><p>一般用excel的色阶工具，加上PPT的修饰。</p><ul><li>excel列出表格数据，色阶着色</li><li>复制到PPT，选择原格式粘贴</li><li>使用PPT的布局调整宽度和长度，以及数据的对齐方式</li><li>使用PPT的表设计，可以加边框（设置颜色和粗细，选定数据加边框）<ul><li>表设计里面的底纹，可以选<code>渐变</code>等样式</li></ul></li></ul><p><img src="/images/MathematicsModeling/p1.png" alt="色阶图"></p><h3 id="热力图和三维地图"><a href="#热力图和三维地图" class="headerlink" title="热力图和三维地图"></a>热力图和三维地图</h3><ol><li>使用python：</li></ol><ul><li><p>普通热力图和平滑彩虹热力图：<a href="https://zhuanlan.zhihu.com/p/567780409">https://zhuanlan.zhihu.com/p/567780409</a></p></li><li><p>地图类：使用python包folium：<a href="https://www.zhihu.com/question/33783546">https://www.zhihu.com/question/33783546</a></p><ul><li>使用 jupyterlab 进行演示，安装和配置教程见：<a href="https://blog.csdn.net/weixin_37641832/article/details/94437445">https://blog.csdn.net/weixin_37641832/article/details/94437445</a></li></ul><p>  补充说明：<br>  (1) 打开jupyter：<br>  在cmd里输入<br>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">jupyter</span> lab --<span class="hljs-literal">no</span>-browser<br></code></pre></td></tr></table></figure><br>  会得到一个URL，在浏览器中打开即可。<br>  (2) 关闭：先关闭网页，再在cmd中输入Ctrl+C退出。</p></li></ul><p>更新：使用<code>PyCharm</code>一样可以直接得到地图，但是需要保存为本地heml文件。详细教程参考：<a href="https://cloud.tencent.com/developer/article/2165996/">https://cloud.tencent.com/developer/article/2165996\</a><br>（我更喜欢PyCharm这个IDE，所以使用的是这个教程，不过大概操作都差不多;里面还有一个实战案例）</p><ul><li>python读取数据的方法:<a href="https://zhuanlan.zhihu.com/p/138965952">https://zhuanlan.zhihu.com/p/138965952</a></li></ul><ol start="2"><li>使用excel制作：</li></ol><p><img src="/images/MathematicsModeling/p2.png" alt="热力图"></p><ul><li><p>选中excel表格数据，选择“三维地图”，默认场景为地球，可“<code>选择新场景--新建自定义地图--浏览背景图片</code>”。在图层1中选择位置x,y对应x,y坐标，数据会自动调整最值和缩放比例。选择<code>热力图</code>形式，在<code>图层选项</code>里面调整色阶和影响半径。最后点击<code>捕获屏幕</code>就可以导出最后的图像。</p></li><li><p>选中excel表格数据，选择“三维地图”，默认场景为地球，可以选择<code>平面地图</code>把它展平。</p></li></ul><p><img src="/images/MathematicsModeling/p3.png" alt="三维地图"></p><h3 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h3><p>一些代码解释：</p><ul><li>使用NumPy的linspace函数在区间[-3, 3]上生成n个等间距的点，作为x轴、y轴上的坐标点<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">n</span> = <span class="hljs-number">256</span><br><span class="hljs-attr">x</span> = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n)<br><span class="hljs-attr">y</span> = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n)<br></code></pre></td></tr></table></figure></li><li>使用<code>meshgrid函数将x和y上的点在二维平面上画网格</code><ul><li>X和Y是生成的网格点的二维数组<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span> = np.meshgrid(x, y)<br></code></pre></td></tr></table></figure></li></ul></li><li>使用<code>contourf函数填充等高线图颜色</code><ul><li>X和Y是网格点的坐标，f(X, Y)是对应的高度值，8表示等高线分成8个部分，alpha&#x3D;.75表示填充颜色的透明度为0.75，cmap&#x3D;plt.cm.hot表示使用热度图颜色。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">plt.contourf(X, Y, f(X, Y), 8, <span class="hljs-attribute">alpha</span>=.75, <span class="hljs-attribute">cmap</span>=plt.cm.hot)<br></code></pre></td></tr></table></figure></li></ul></li><li>使用<code>contour函数添加等高线</code><ul><li>指定线的颜色为黑色，线宽为0.5<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"># 形参分别为：<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>,<span class="hljs-keyword">Z</span>(高度),等高线的级别数量，等高线颜色，线宽<br>C = plt.contour(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>, f(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>), <span class="hljs-number">8</span>, colors=<span class="hljs-string">&#x27;black&#x27;</span>, linewidth=<span class="hljs-number">.5</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>添加等高线的标签<ul><li>inline&#x3D;True表示将标签嵌入等高线之中，fontsize&#x3D;10表示标签的字体大小为10<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">plt.clabel(C, <span class="hljs-attribute">inline</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">fontsize</span>=10)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/images/MathematicsModeling/p18.png" alt="等高线图"></p><h3 id="复杂一点的多图合一"><a href="#复杂一点的多图合一" class="headerlink" title="复杂一点的多图合一"></a>复杂一点的多图合一</h3><h4 id="使用python实现色阶"><a href="#使用python实现色阶" class="headerlink" title="使用python实现色阶"></a>使用python实现色阶</h4><ul><li><code>plt.imshow(a,interpolation = &#39;nearest&#39;,cmap = cm.jet ,origin = &#39;upper&#39;)</code>:<ul><li><code>origin</code> 参数用于确定数组数据的原点位置，通常是在图像的左上角或左下角。Matplotlib 中支持的值是 <code>upper</code> 和 <code>lower</code></li><li>a: 是要显示的图像数据，通常是一个二维的数组，每个元素代表一个像素的值</li><li><code>interpolation=&#39;nearest&#39;</code> 这个参数指定了图像数据的插值方式。  <code>&#39;nearest&#39; 表示使用最近邻插值</code>，即使用最近的像素值来填充图像的空白部分。这意味着图像的显示会更加锐利，但可能会失去一些平滑性。</li><li><code>cmap=&#39;bone&#39;</code> 这个参数指定了颜色映射，即将数据值映射到颜色的方式。<br>  在这里，<code>&#39;bone&#39;</code> 是 Matplotlib 中提供的一种颜色映射方案，它会将数据值映射为灰度色调，其中较小的值会显示为较暗的颜色，较大的值会显示为较亮的颜色。<br>  也可使用<code>cmap = cm.jet</code>,将数据值映射为彩虹色的颜色&gt;(需要先<code>import matplotlib.cm as cm</code>)</li><li>cm是matplotlib.cm模块的别名，它包含了许多预定义的颜色映射。</li></ul></li><li>plt.colorbar(shrink &#x3D; .92)<ul><li>显示色条，可设置宽度shrink。</li></ul></li></ul><p><img src="/images/MathematicsModeling/p20.png" alt="复杂一点的图"></p><h2 id="office制作散点图"><a href="#office制作散点图" class="headerlink" title="office制作散点图"></a>office制作散点图</h2><p>matlab,python,office都可以制作散点图。</p><p><img src="/images/MathematicsModeling/p4.png" alt="散点图"></p><ol><li>office制作散点图：难度低，但是需要做的生动形象，就需要一些技巧了。</li></ol><ul><li>更换散点为小球啥的，看起来新颖一点:<br>选择散点图里面的散点-设置数据系列格式-选择标记-标记选项-把大小调成合适的小球的大小-在网上找到小球的图片，复制到剪贴板-在填充选择图片或纹理填充-剪贴板-在边框可以设置<code>无线条</code></li><li>更换背景使之更符合问题背景:<br>在<code>设置绘图区格式</code>里面-选择填充-图片或纹理填充-插入图片</li><li>补充的一些office制作图表技巧:<ul><li>切换x,y轴: 自己百度去。</li><li>调整坐标轴的范围使数据点分布均匀一点：<br>  在<code>设置图标区格式</code>里的图表选项-选择垂直轴选项-坐标轴选项-设置边界</li><li>坐标轴可以设置刻度线啥的，好看一点的话就是<code>主刻度线交叉</code>，<code>次刻度线内部</code></li><li>PPT里面不同形状可以组合图形，互补互切啥的。</li></ul></li></ul><h2 id="着色图表"><a href="#着色图表" class="headerlink" title="着色图表"></a>着色图表</h2><p><img src="/images/MathematicsModeling/p5.png" alt="着色图表"></p><p>使用方法：Matlab or Excel +PPT</p><h3 id="普通折线图、线性拟合图——点实线透明，色彩对比鲜明"><a href="#普通折线图、线性拟合图——点实线透明，色彩对比鲜明" class="headerlink" title="普通折线图、线性拟合图——点实线透明，色彩对比鲜明"></a>普通折线图、线性拟合图——点实线透明，色彩对比鲜明</h3><p>推荐把点的颜色设置得比较深，把线的颜色设的稍浅，显得更有层次感。<br>不同线之间颜色选择：</p><ul><li>对比色</li><li>同色系的不同色调（一大段有多张相似图表，每张图选择一个色系）</li><li>matlab&#x2F;excel就可以实现。</li></ul><h3 id="面积图——实际上就是在一块面积内填渐变色"><a href="#面积图——实际上就是在一块面积内填渐变色" class="headerlink" title="面积图——实际上就是在一块面积内填渐变色"></a>面积图——实际上就是在一块面积内填渐变色</h3><ol><li>利用office自带的面积图叠一层：</li></ol><ul><li>优点：简单方便，只要把数据复制一遍选择<code>面积图</code>即可。</li><li>缺点：office的曲线图带有平滑拟合，而面积图无平滑拟合，所以会有留白。</li></ul><ol start="2"><li>使用PS处理 (自己百度去)</li></ol><p>注意：不要滥用渐变色、透明度、阴影、虚线、发光，色彩搭配要注意不能显得太廉价。</p><h2 id="突出对比的智能图表（雷达图，漏斗图，条形图）"><a href="#突出对比的智能图表（雷达图，漏斗图，条形图）" class="headerlink" title="突出对比的智能图表（雷达图，漏斗图，条形图）"></a>突出对比的智能图表（雷达图，漏斗图，条形图）</h2><p>office自带了丰富的图表类型！！！</p><h3 id="利用插件制作图表"><a href="#利用插件制作图表" class="headerlink" title="利用插件制作图表"></a>利用插件制作图表</h3><p>常用的插件：</p><ul><li><code>iSlide插件</code><br>设计排版中的<code>矩阵布局</code>，<code>环形布局</code>很好用；有丰富的案例库，主题库，图示库，智能图表，图标库……</li><li>口袋动画PA插件：主要是做动画的，其中的<code>矢量工具</code>很好用</li></ul><h2 id="流程图-层次图"><a href="#流程图-层次图" class="headerlink" title="流程图&amp;层次图"></a>流程图&amp;层次图</h2><p><img src="/images/MathematicsModeling/p7.png" alt="流程图"></p><p><img src="/images/MathematicsModeling/p6.png" alt="流程图"></p><h2 id="数据3D可视化-python"><a href="#数据3D可视化-python" class="headerlink" title="数据3D可视化(python)"></a>数据3D可视化(python)</h2><p>需要导入的库：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-title">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br></code></pre></td></tr></table></figure><h3 id="流程解释："><a href="#流程解释：" class="headerlink" title="流程解释："></a>流程解释：</h3><ul><li>创建图形和三维坐标轴，设置图片尺寸和分辨率<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fig</span> = plt.figure(figsize=plt.figaspect(<span class="hljs-number">0</span>.<span class="hljs-number">6</span>))<br><span class="hljs-attribute">ax3</span> = fig.add_subplot(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, projection=&#x27;<span class="hljs-number">3</span>d&#x27;)<br></code></pre></td></tr></table></figure></li><li>生成数据<ul><li>生成一个二维的网格 X 和 Y，然后计算了对应于网格点的 R（距离原点的距离），最后通过正弦函数生成了 Z 值<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">X</span> = np.arange(<span class="hljs-number">-4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span><span class="hljs-number">.25</span>)<br><span class="hljs-keyword">Y</span> = np.arange(<span class="hljs-number">-4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span><span class="hljs-number">.25</span>)<br><span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span> = np.meshgrid(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>)<br><span class="hljs-keyword">R</span> = np.sqrt(<span class="hljs-keyword">X</span>**<span class="hljs-number">2</span> + <span class="hljs-keyword">Y</span>**<span class="hljs-number">2</span>)<br><span class="hljs-keyword">Z</span> = np.sin(<span class="hljs-keyword">R</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>绘制三维曲面图<ul><li><code>plot_surface()</code> 用于绘制三维曲面图，参数中的 X、Y、Z 分别表示数据的坐标，<code>rstride</code> 和 <code>cstride</code> 控制行和列的<code>采样间隔</code>，<code>cmap</code> 指定了颜色映射。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ax.plot<span class="hljs-constructor">_surface(X, Y, Z, <span class="hljs-params">rstride</span>=1, <span class="hljs-params">cstride</span>=1, <span class="hljs-params">cmap</span>=<span class="hljs-params">plt</span>.<span class="hljs-params">get_cmap</span>(&#x27;<span class="hljs-params">rainbow</span>&#x27;)</span>)<br></code></pre></td></tr></table></figure></li></ul><ul><li>绘制等高线图<ul><li><code>contourf() </code>用于绘制等高线图，参数中的 X、Y、Z 表示数据的坐标，<code>zdir </code>指定了<code>等高线图的方向</code>（这里是垂直于 Z 轴的方向），<code>offset</code> 指定了等高线图的<code>位置偏移</code>，<code>cmap</code> 指定了颜色映射</li></ul></li></ul><pre><code class="hljs">ax.contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-2, cmap=plt.get_cmap(&#39;rainbow&#39;))</code></pre></li><li>设置 Z 轴的范围:<code>ax.set_zlim(-2, 2)</code></li></ul><p><img src="/images/MathematicsModeling/p22.png" alt="3D海域深度图"></p><h2 id="三维立体图-PPT就可以制作"><a href="#三维立体图-PPT就可以制作" class="headerlink" title="三维立体图(PPT就可以制作)"></a>三维立体图(PPT就可以制作)</h2><ol><li>图标素材的来源：</li></ol><ul><li>阿里巴巴</li><li>Office自带图标</li><li>iSlide插件的图标库</li></ul><ol start="2"><li>三维绘图的关键点：形状效果的棱台和三维旋转</li></ol><ul><li>棱台注意调节深度、光线、材质等。（调节凭感觉）</li><li>各种材质的小球可以使用棱台效果调节宽度得到</li><li>图标库里面的二维小人，可以添加棱台效果使之变得立体一点</li><li>三维旋转XYZ轴的调节是玄学……</li></ul><p><img src="/images/MathematicsModeling/p8.png" alt="三维立体图1"></p><p><img src="/images/MathematicsModeling/p9.png" alt="三维立体图2"></p><h2 id="铅笔画、素描画"><a href="#铅笔画、素描画" class="headerlink" title="铅笔画、素描画"></a>铅笔画、素描画</h2><p>使用工具：PPT里面的艺术效果：<br>选中图片——菜单栏的图片格式——调整工具栏的艺术效果——艺术效果选项——微调一下：透明度、压力、铅笔大小</p>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 学习指南</title>
    <link href="/2023/08/03/MySQL-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/03/MySQL-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>MySQL是一种关系型数据库管理系统，被广泛用于存储和管理结构化数据。它是开源的，免费使用，并且支持多种操作系统。</p><p>以下是一些MySQL的基本概念：</p><ul><li><p>数据库和表格</p><ul><li>数据库：MySQL可以管理多个数据库，每个数据库是一个独立的数据存储单元。</li><li>表格：数据库由多个表格组成，每个表格是一个二维数据结构，用于存储数据。</li></ul></li><li><p>基本数据类型<br>MySQL支持多种数据类型,<br>常用的数据类型有：</p><ul><li>INT：整数类型</li><li>VARCHAR：可变长度字符串类型</li><li>DATE：日期类型</li><li>FLOAT：浮点数类型</li></ul></li><li><p>SQL语句<br>SQL（Structured Query Language）是用于与数据库进行交互的语言。通过SQL语句可以完成各种操作:</p><ul><li>查询数据：使用SELECT语句来检索数据。</li><li>插入数据：使用INSERT INTO语句将数据插入表格。</li><li>更新数据：使用UPDATE语句更新表格中的数据。</li><li>删除数据：使用DELETE FROM语句删除表格中的数据。</li></ul></li><li><p>数据库连接<br>连接数据库是在Python或其他编程语言中与MySQL进行交互的第一步。连接器库（如mysql-connector-python或pymysql）提供了与数据库建立连接的功能。</p></li></ul><p>一旦建立了数据库连接，你可以通过执行SQL语句来读取、写入和修改数据库中的数据。</p><h2 id="安装MySQL教程"><a href="#安装MySQL教程" class="headerlink" title="安装MySQL教程"></a>安装MySQL教程</h2><p><a href="https://blog.csdn.net/m0_52559040/article/details/121843945">https://blog.csdn.net/m0_52559040/article/details/121843945</a></p><h2 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h2><ul><li><code>mysql -uroot -p</code>  : 启动数据库<ul><li>最初，都是使用 root 用户登录，工作中如果一直用 root 用户登录，因为权限太大，风险是很大的，所以等创建好权限适合的用户后，就不要经常登录 root 用户了。</li></ul></li><li><code>\h</code> ：查看命令行说明</li><li><code>\c</code> ：clear the current input statement</li><li><code>\G</code> : send commend to mysql server, display result vertically</li><li><code>\p</code> : print current command</li><li><code>\q</code> : Quit Mysql</li><li><code>\s</code> : get status information from the server<br>更多命令输入<code>\h</code>查看</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查看当前的数据库"><a href="#查看当前的数据库" class="headerlink" title="查看当前的数据库"></a>查看当前的数据库</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_one;<br></code></pre></td></tr></table></figure><ul><li>创建数据库时设置字符编码:<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_three charset utf8;<br></code></pre></td></tr></table></figure>通常我们会在数据库中存放中文数据，所以最好把数据库的编码方式设置成 utf-8 ，这样中文才能正常显示。</li><li>查看和显示数据库的编码方式<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_one;<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_two;<br></code></pre></td></tr></table></figure></li><li>修改数据库编码<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> MyDB_one <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br></code></pre></td></tr></table></figure></li></ul><h3 id="进入或切换数据库"><a href="#进入或切换数据库" class="headerlink" title="进入或切换数据库"></a>进入或切换数据库</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> MyDB_one<br><span class="hljs-keyword">use</span> MyDB_two;<br></code></pre></td></tr></table></figure><p>刚连接上 MySQL 时，没有处于任何一个数据库中，如果要使用某一个数据库，就需要进入到这个数据库中。</p><p><code>use 数据库名</code> 这个命令后面的分号可以省略，这是 SQL 语句中唯一可以省略分号的语句。</p><ul><li>显示当前数据库：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">database</span>()</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><h4 id="查看当前数据库中的表"><a href="#查看当前数据库中的表" class="headerlink" title="查看当前数据库中的表"></a>查看当前数据库中的表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Phone_table(pid <span class="hljs-type">INT</span>, <span class="hljs-type">name</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>), price <span class="hljs-type">INT</span>);<br></code></pre></td></tr></table></figure><h4 id="显示表信息"><a href="#显示表信息" class="headerlink" title="显示表信息"></a>显示表信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Phone_table;<br></code></pre></td></tr></table></figure><h4 id="给表增加字段"><a href="#给表增加字段" class="headerlink" title="给表增加字段"></a>给表增加字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> Phone_table <span class="hljs-keyword">add</span> color <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><h4 id="删除表的字段"><a href="#删除表的字段" class="headerlink" title="删除表的字段"></a>删除表的字段</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> Phone_table <span class="hljs-keyword">drop</span> price;<br></code></pre></td></tr></table></figure><p>更多操作参考：<a href="https://zhuanlan.zhihu.com/p/370510336">https://zhuanlan.zhihu.com/p/370510336</a></p><h1 id="import-pymysql-操作MySQL数据库"><a href="#import-pymysql-操作MySQL数据库" class="headerlink" title="import pymysql 操作MySQL数据库"></a>import pymysql 操作MySQL数据库</h1><ul><li><code>pip install pymysql</code> 安装pymysql库</li><li>在python脚本中导入库：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pymysql<br></code></pre></td></tr></table></figure></li><li>建立数据库连接<br>使用<code>pymysql.connect( )</code>函数来建立与MySQL数据库的连接。提供MySQL服务器的主机名、用户名、密码和数据库名称等信息。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 建立数据库连接</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">connection </span>= pymysql.connect(<br>    <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attribute">user</span>=<span class="hljs-string">&#x27;your_username&#x27;</span>,<br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;your_password&#x27;</span>,<br>    <span class="hljs-attribute">database</span>=<span class="hljs-string">&#x27;your_database_name&#x27;</span><br>)<br></code></pre></td></tr></table></figure></li><li>创建游标对象<br>在连接上创建游标对象，用于执行SQL查询和获取结果。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cursor</span> = <span class="hljs-keyword">connection</span>.<span class="hljs-keyword">cursor</span>()<br></code></pre></td></tr></table></figure></li><li>执行SQL查询<ul><li>查询数据  <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment"># 查询数据</span><br>query = <span class="hljs-string">&quot;SELECT * FROM your_table_name;&quot;</span><br>cursor.execute(query)<br><br><span class="hljs-comment"># 获取所有结果</span><br>results = cursor.fetchall()<br><br><span class="hljs-comment"># 遍历结果并打印</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">row</span> <span class="hljs-keyword">in</span> results:<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">row</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>插入数据  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 插入数据</span><br>query = <span class="hljs-string">&quot;INSERT INTO your_table_name (column1, column2, column3) VALUES (%s, %s, %s);&quot;</span><br>data = (<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>)<br>cursor.execute(query, data)<br><br><span class="hljs-comment"># 提交更改</span><br>connection.commit()<br></code></pre></td></tr></table></figure>使用游标对象cur执行了一个INSERT语句，向名为<code>your_table_name</code>的表格中插入一条数据。</li></ul><p>INSERT语句中的参数使用占位符%s表示。这样做可以防止SQL注入攻击。<code>cur.execute()</code>方法将会将后面提供的参数值安全地插入到SQL语句中。</p><p>调用了<code>conn.commit()</code>来提交更改，将数据插入到数据库中。如果没有调用commit()方法，数据库将不会保存插入的数据。</p><ul><li>关闭连接<br>在完成所有数据库操作后，关闭游标和连接。  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><span class="hljs-keyword">connection</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure></li></ul><h2 id="样例源码：更新库中用户数据"><a href="#样例源码：更新库中用户数据" class="headerlink" title="样例源码：更新库中用户数据"></a>样例源码：更新库中用户数据</h2><p>假设你有一个名为users的表格，包含id、name和age三列。现在，你想根据id来更新某个用户的信息。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> pymysql<br><br>def update_user_by_id(user_id, <span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>):<span class="hljs-type"></span><br>    <span class="hljs-meta"># 建立数据库连接</span><br>    connection = pymysql.connect(<br>        host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        user=<span class="hljs-string">&#x27;your_username&#x27;</span>,<br>        password=<span class="hljs-string">&#x27;your_password&#x27;</span>,<br>        database=<span class="hljs-string">&#x27;your_database_name&#x27;</span><br>    )<br><br>    <span class="hljs-keyword">try</span>:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 创建游标对象</span><br>        cursor = connection.cursor()<br><br>        <span class="hljs-meta"># 执行UPDATE操作</span><br>        query = <span class="hljs-string">&quot;UPDATE users SET name=%s, age=%s WHERE id=%s;&quot;</span><br>        data = (<span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>, user_id)<br>        cursor.execute(query, data)<br><br>        <span class="hljs-meta"># 提交更改</span><br>        connection.commit()<br><br>        print(<span class="hljs-string">&quot;User information updated successfully!&quot;</span>)<br>    except Exception as e:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 如果出现错误，回滚更改</span><br>        connection.rollback()<br>        print(f<span class="hljs-string">&quot;Error: &#123;str(e)&#125;&quot;</span>)<br>    finally:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 关闭游标和连接</span><br>        cursor.close()<br>        connection.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<span class="hljs-type"></span><br>    <span class="hljs-meta"># 要更新的用户信息</span><br>    user_id = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">new</span><span class="hljs-type">_name</span> = <span class="hljs-string">&quot;Alice Smith&quot;</span><br>    <span class="hljs-keyword">new</span><span class="hljs-type">_age</span> = <span class="hljs-number">32</span><br><br>    update_user_by_id(user_id, <span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS学习指南</title>
    <link href="/2023/07/31/CSS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/31/CSS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS-（层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述"><a href="#CSS-（层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述" class="headerlink" title="CSS （层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述"></a>CSS （层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。<br><span id="more"></span><br>概述</h2><p>CSS 与 HTML 和 JavaScript 并称 Web 三大核心技术。一般用它来定义 HTML 元素 的样式，但它也能用于其他标记语言，如 SVG 和 XML。</p><p>浏览器会根据 CSS 的样式定义将其选定的元素显示为恰当的形式。一条 CSS 的样式定义包括属性和属性值，它们共同决定网页的外观。</p><p>一条 CSS 规则包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_Selector">选择符</a> 和一组 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Property/CSS">属性 （en-US）</a> 定义。下面这个例子用来将页面中的所有标签显示为黑色背景和黄色文本：<code>&lt;p&gt;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* p 选择符用来选择页面中的所有 &lt;p&gt; 标签 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* color 属性用来定义文本颜色，这里为黄色 */</span><br>  <span class="hljs-attribute">color</span>: yellow;<br><br>  <span class="hljs-comment">/* background-color 属性用来定义元素的背景色，这里为黑色 */</span><br>  <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 中的“C”表示“层叠的”，意为<code>多个选择符之间具有特定的优先级</code>。这一点非常重要，因为复杂网站可能会有非常多的 CSS 规则，因此必须规定好这些规则的优先级，以免乱套。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python项目1_爬虫学习指南</title>
    <link href="/2023/07/31/python%E9%A1%B9%E7%9B%AE1-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/31/python%E9%A1%B9%E7%9B%AE1-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>记录python项目1–爬虫的学习过程</p><span id="more"></span><h1 id="基础步骤"><a href="#基础步骤" class="headerlink" title="基础步骤"></a>基础步骤</h1><h2 id="step1-安装requests库和BeautifulSoup库"><a href="#step1-安装requests库和BeautifulSoup库" class="headerlink" title="step1 :安装requests库和BeautifulSoup库"></a>step1 :安装requests库和BeautifulSoup库</h2><p>在pycharm的设置上找到项目解释器，查询插件安装。</p><p>可能出现报错：安装版本与python版本不一致，安装最新的即可。</p><p>在书写爬虫程序的开头引入两个模块：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> requests<br><span class="hljs-title">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br></code></pre></td></tr></table></figure><h2 id="step-2：获取爬虫所需的header和cookie"><a href="#step-2：获取爬虫所需的header和cookie" class="headerlink" title="step 2：获取爬虫所需的header和cookie"></a>step 2：获取爬虫所需的header和cookie</h2><p>获取header和cookie是一个爬虫程序必须的，它直接决定了爬虫程序能不能准确的找到网页位置进行爬取。</p><p>首先进入想要爬取的网页页面，按下F12，就会出现网页的js语言设计部分。</p><p>找到网页上的Network部分。然后按下ctrl+R刷新页面。如果，进行就有文件信息，就不用刷新了，当然刷新了也没啥问题。</p><p>然后，浏览Name部分，找到我们想要爬取的文件，鼠标右键，选择copy，复制下网页的URL。</p><h2 id="step-3-获取网页"><a href="#step-3-获取网页" class="headerlink" title="step 3: 获取网页"></a>step 3: 获取网页</h2><p>使用request请求</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://tophub.today/n/KqndgxeLl9&#x27;</span>, <span class="hljs-attribute">cookies</span>=cookies, <span class="hljs-attribute">headers</span>=headers)<br></code></pre></td></tr></table></figure><h3 id="requests-get-url-函数"><a href="#requests-get-url-函数" class="headerlink" title="requests.get(url)函数"></a>requests.get(url)函数</h3><p>获取一个网页，最简单的代码就是<code>r=requests.get(url) </code>url：输入目标网址</p><p>requests.get(url)方法就是构造一个向服务器请求资源的Request对象，这个对象是Request库内部生成的。</p><p>Request库有两个重要对象，分别是<code>Request</code>和<code>Response</code>。Request对象对应的是请求，向目标网址发送一个请求访问服务。而Response对象，是包含了爬虫返回的内容。</p><p>实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-comment">#get()获取网页</span><br>r = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>)<br><span class="hljs-comment"># 检查连接状态</span><br><span class="hljs-built_in">print</span>(r.status_code)<br><span class="hljs-comment"># 检测r的类型</span><br><span class="hljs-built_in">print</span>(type(r))<br><span class="hljs-comment"># 获取页面的头部信息</span><br><span class="hljs-built_in">print</span>(r.headers)<br></code></pre></td></tr></table></figure><p>返回内容为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">200</span><br>&lt;class &#x27;requests.models.Response&#x27;&gt;<br>&#123;&#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;, &#x27;Content-Length&#x27;: &#x27;<span class="hljs-number">1145</span>&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Server&#x27;: &#x27;bfe&#x27;, &#x27;Date&#x27;: &#x27;Tue, 24 Mar <span class="hljs-number">2020</span> 07:31:58 GMT&#x27;&#125;<br></code></pre></td></tr></table></figure><p>Response对象的属性，有以下几种 :</p><ul><li><p>r.status_code： HTTP请求的返回状态，200表示连接成功，404表示失败</p></li><li><p>r.text： HTTP响应内容的字符串形式，即，ur对应的页面内容</p></li><li><p>r.encoding：从HTTP header中<code>猜测</code>的响应内容编码方式,是自己定义的，实际内容编码在<code>r.apparent_encoding</code>里。如果两者不同会出现分析内容为乱码的情况，需要替换编码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 查看编码</span><br><span class="hljs-built_in">print</span>(r.encoding)<br><span class="hljs-built_in">print</span>(r.apparent_encoding)<br><span class="hljs-comment"># 替换编码,假设实际响应内容编码为utf-8</span><br>r.<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</p></li><li><p>r.content： HTTP响应内容的二进制形式</p></li></ul><p>这几个属性，都是访问网页时必要的属性。如果状态码是200，就可以用Response属性来获取网页信息。</p><h2 id="step-4-解析网页-分析简化地址"><a href="#step-4-解析网页-分析简化地址" class="headerlink" title="step 4:解析网页,分析简化地址"></a>step 4:解析网页,分析简化地址</h2><p>回到网页，按F12，找到网页的Elements部分；用左上角的小框带箭头的标志，点击网页内容，网页会自动在右边显示出对应的代码。在找到想要爬取的页面部分的网页代码后，将鼠标放置于代码上，右键，copy到selector部分。</p><p>此时复制的selector相当于网页上对应部分存放的地址。由于爬虫需要的是网页上的一类信息，所以需要对获取的地址进行分析，提取，制造<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors">CSS选择器</a><br>。那个地址本身只能获取到你选择的网页上的那一小部分内容。</p><h2 id="step-5-爬取内容，清洗数据"><a href="#step-5-爬取内容，清洗数据" class="headerlink" title="step 5:爬取内容，清洗数据"></a>step 5:爬取内容，清洗数据</h2><p>用一个标签存储上面提炼出的像地址一样的东西，标签会拉取到爬虫想获得的网页内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#爬取内容</span><br><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr # &gt; td.al &gt; a&quot;</span><br></code></pre></td></tr></table></figure><p>之后我们就要soup和text过滤掉不必要的信息，比如js类语言，排除这类语言对于信息受众阅读的干扰。</p><h3 id="soup-select-函数"><a href="#soup-select-函数" class="headerlink" title="soup.select()函数"></a>soup.select()函数</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span>(<span class="hljs-built_in">self</span>, selector, namespaces=<span class="hljs-literal">None</span>, limit=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>功能：查找html中所需要的内容<br>主要使用的参数是<code>selector</code>，其定义为”包含CSS选择器的字符串“。</p><p>soup.select( )可通过以下方法进行查找：</p><ul><li>通过（HTML）标签名查找</li><li>通过CCS类选择器查找</li><li>通过CCS id 选择器查找</li><li>组合查找</li><li>子标签查找</li><li>通过属性查找</li></ul><p>参考：<a href="https://blog.csdn.net/wei_lin/article/details/102334956">https://blog.csdn.net/wei_lin/article/details/102334956</a></p><h2 id="实例源码1：爬取实时微博热搜"><a href="#实例源码1：爬取实时微博热搜" class="headerlink" title="实例源码1：爬取实时微博热搜"></a>实例源码1：爬取实时微博热搜</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-keyword">from</span> bs4 import BeautifulSoup<br><br><span class="hljs-comment"># 爬虫头数据</span><br>cookies = &#123;<br>    <span class="hljs-string">&#x27;Hm_lvt_3b1e939f6e789219d8629de8a519eab9&#x27;</span>: <span class="hljs-string">&#x27;1690790195&#x27;</span>,<br>    <span class="hljs-string">&#x27;Hm_lpvt_3b1e939f6e789219d8629de8a519eab9&#x27;</span>: <span class="hljs-string">&#x27;1690790469&#x27;</span>,<br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;authority&#x27;</span>: <span class="hljs-string">&#x27;tophub.today&#x27;</span>,<br>    <span class="hljs-string">&#x27;accept&#x27;</span>: <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,<br>    <span class="hljs-string">&#x27;accept-language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>,<br>    <span class="hljs-string">&#x27;cache-control&#x27;</span>: <span class="hljs-string">&#x27;max-age=0&#x27;</span>,<br>    # <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;Hm_lvt_3b1e939f6e789219d8629de8a519eab9=1690790195; Hm_lpvt_3b1e939f6e789219d8629de8a519eab9=1690790469&#x27;</span>,<br>    <span class="hljs-string">&#x27;referer&#x27;</span>: <span class="hljs-string">&#x27;https://www.bing.com/&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua&#x27;</span>: <span class="hljs-string">&#x27;&quot;Not/A)Brand&quot;;v=&quot;99&quot;, &quot;Microsoft Edge&quot;;v=&quot;115&quot;, &quot;Chromium&quot;;v=&quot;115&quot;&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="hljs-string">&#x27;?0&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua-platform&#x27;</span>: <span class="hljs-string">&#x27;&quot;Windows&quot;&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-dest&#x27;</span>: <span class="hljs-string">&#x27;document&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-mode&#x27;</span>: <span class="hljs-string">&#x27;navigate&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-site&#x27;</span>: <span class="hljs-string">&#x27;cross-site&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-user&#x27;</span>: <span class="hljs-string">&#x27;?1&#x27;</span>,<br>    <span class="hljs-string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188&#x27;</span>,<br>&#125;<br><br><br><span class="hljs-comment">#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr:nth-child(1) &gt; td.al &gt; a</span><br><span class="hljs-comment">#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; td.al &gt; a</span><br><br><span class="hljs-comment">#数据存储</span><br>fo = open(<span class="hljs-string">&quot;./微博热搜.txt&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment">#获取网页</span><br>response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://tophub.today/n/KqndgxeLl9&#x27;</span>, <span class="hljs-attribute">cookies</span>=cookies, <span class="hljs-attribute">headers</span>=headers)<br><span class="hljs-comment">#解析网页</span><br>response.<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#爬取内容</span><br><span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr &gt; td.al &gt; a&quot;</span><br><span class="hljs-comment">#数据清洗</span><br><span class="hljs-attribute">a</span>=soup.select(content)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(0,len(a)):<br>    a[i] = a[i].text<br>    fo.write(a[i]+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>fo.close()<br></code></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h2 id="1-绕过反爬机制"><a href="#1-绕过反爬机制" class="headerlink" title="1. 绕过反爬机制"></a>1. 绕过反爬机制</h2><h3 id="请求频率限制"><a href="#请求频率限制" class="headerlink" title="请求频率限制"></a>请求频率限制</h3><p>使用sleep等待随机时间，或者使用代理ip去访问。</p><h4 id="随机延迟"><a href="#随机延迟" class="headerlink" title="随机延迟"></a>随机延迟</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.sleep</span>(random<span class="hljs-selector-class">.randint</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h4 id="建立代理ip池"><a href="#建立代理ip池" class="headerlink" title="建立代理ip池"></a>建立代理ip池</h4><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立属于自己的开放代理IP池</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> fake_useragent <span class="hljs-keyword">import</span> UserAgent<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IpPool</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 测试ip是否可用url</span><br>        self.test_url = <span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span><br>        <span class="hljs-comment"># 获取IP的 目标url</span><br>        self.url = <span class="hljs-string">&#x27;https://www.89ip.cn/index_&#123;&#125;.html&#x27;</span><br><br>        self.headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: UserAgent().random&#125;<br>        <span class="hljs-comment"># 存储可用ip</span><br>        self.file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ip_pool.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_html</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;获取页面&#x27;&#x27;&#x27;</span><br>        html = requests.get(url=url, headers=self.headers).text<br><br>        <span class="hljs-keyword">return</span> html<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>(<span class="hljs-params">self, url</span>):<br>     <span class="hljs-string">&#x27;&#x27;&#x27;数据处理  获取ip 和端口&#x27;&#x27;&#x27;</span> <br>        html = self.get_html(url=url)<br>        <span class="hljs-comment"># print(html)</span><br>       <br>        elemt = etree.HTML(html)<br>        <br>        ips_list = elemt.xpath(<span class="hljs-string">&#x27;//table/tbody/tr/td[1]/text()&#x27;</span>)<br>        ports_list = elemt.xpath(<span class="hljs-string">&#x27;//table/tbody/tr/td[2]/text()&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> ip, port <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(ips_list, ports_list):<br>            <span class="hljs-comment"># 拼接ip与port</span><br>            proxy = ip.strip() + <span class="hljs-string">&quot;:&quot;</span> + port.strip()<br>            <span class="hljs-comment"># print(proxy)</span><br>            <br>            <span class="hljs-comment"># 175.44.109.195:9999</span><br>            self.test_proxy(proxy)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_proxy</span>(<span class="hljs-params">self, proxy</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;测试代理IP是否可用&#x27;&#x27;&#x27;</span><br>        proxies = &#123;<br>            <span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">&#x27;http://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(proxy),<br>            <span class="hljs-string">&#x27;https&#x27;</span>: <span class="hljs-string">&#x27;https://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(proxy),<br>        &#125;<br>        <span class="hljs-comment"># 参数类型</span><br>        <span class="hljs-comment"># proxies</span><br>        <span class="hljs-comment"># proxies = &#123;&#x27;协议&#x27;: &#x27;协议://IP:端口号&#x27;&#125;</span><br>        <span class="hljs-comment"># timeout 超时设置 网页响应时间3秒 超过时间会抛出异常</span><br>        <span class="hljs-keyword">try</span>:<br>            resp = requests.get(url=self.test_url, proxies=proxies, headers=self.headers, timeout=<span class="hljs-number">3</span>)<br>           <span class="hljs-comment"># 获取 状态码为200 </span><br>            <span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;\033[31m可用\033[0m&#x27;</span>)<br>                <span class="hljs-comment"># 可以的IP 写入文本以便后续使用</span><br>                self.file.write(proxy)<br>                <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;不可用&#x27;</span>)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;不可用&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;执行函数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 快代理每页url 的区别</span><br>        <span class="hljs-comment"># https://www.kuaidaili.com/free/inha/1/</span><br>        <span class="hljs-comment"># https://www.kuaidaili.com/free/inha/2/</span><br>        <span class="hljs-comment"># .......</span><br><span class="hljs-comment"># 提供的免费ip太多</span><br>        <span class="hljs-comment"># 这里只获取前100页提供的免费代理IP测试</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):<br>            <span class="hljs-comment"># 拼接完整的url</span><br>            page_url = self.url.<span class="hljs-built_in">format</span>(i)<br>            <span class="hljs-comment"># 注意抓取控制频率</span><br>            time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<br>            self.get_proxy(url=page_url)<br><br>        <span class="hljs-comment"># 执行完毕关闭文本</span><br>        self.file.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ip = IpPool()<br>    ip.crawl()<br><br></code></pre></td></tr></table></figure><h4 id="使用开源项目proxcyPool-不好用，ip拿不出来"><a href="#使用开源项目proxcyPool-不好用，ip拿不出来" class="headerlink" title="使用开源项目proxcyPool(不好用，ip拿不出来)"></a>使用开源项目proxcyPool(不好用，ip拿不出来)</h4><p>项目仓库：<a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></p><ol><li>redis常用命令：</li></ol><ul><li>启动server<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redis-server<span class="hljs-selector-class">.exe</span> redis<span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span> <br></code></pre></td></tr></table></figure>先输入上面的命令手动开启server，再重新开个终端，输入<code>redis-cli.exe</code>开始运行。</li><li>关闭redis<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">shutdown<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>在 Windows 上，Redis 默认情况下并不会自动生成日志文件，也不会将日志输出到文件中。Redis 会将日志输出到控制台（Console），除非在配置文件中显式地指定了日志文件路径。</p></li><li><p>开启爬取代理 IP </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> proxyPool.<span class="hljs-keyword">py</span> schedule<br></code></pre></td></tr></table></figure></li><li><p>使用代理 IP，需要启动 webApi 服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> proxyPool.<span class="hljs-keyword">py</span> server<br></code></pre></td></tr></table></figure><p>启动web服务后, 默认配置下会开启 <code>127.0.0.1:5010</code> 的api接口服务。</p></li></ol><table><thead><tr><th>api</th><th>method</th><th>Description</th><th>params</th></tr></thead><tbody><tr><td>&#x2F;</td><td>GET</td><td>api介绍</td><td>None</td></tr><tr><td>&#x2F;get</td><td>GET</td><td>随机获取一个代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;pop</td><td>GET</td><td>获取并删除一个代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;all</td><td>GET</td><td>获取所有代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;count</td><td>GET</td><td>查看代理数量</td><td>None</td></tr><tr><td>&#x2F;delete</td><td>GET</td><td>删除代理</td><td>?proxy&#x3D;host:ip</td></tr></tbody></table><p>如果要在爬虫代码中使用的话， 可以将此api封装成函数直接使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>():<br>    <span class="hljs-keyword">return</span> requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/get/&quot;</span>).json()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_proxy</span>(<span class="hljs-params">proxy</span>):<br>    requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/delete/?proxy=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(proxy))<br><br><span class="hljs-comment"># your spider code</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHtml</span>():<br>    <span class="hljs-comment"># ....</span><br>    retry_count = <span class="hljs-number">5</span><br>    proxy = get_proxy().get(<span class="hljs-string">&quot;proxy&quot;</span>)<br>    <span class="hljs-keyword">while</span> retry_count &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">try</span>:<br>            html = requests.get(<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, proxies=&#123;<span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(proxy)&#125;)<br>            <span class="hljs-comment"># 使用代理访问</span><br>            <span class="hljs-keyword">return</span> html<br>        <span class="hljs-keyword">except</span> Exception:<br>            retry_count -= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 删除代理池中代理</span><br>    delete_proxy(proxy)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h4 id="重新找了一个开源的代理ip池"><a href="#重新找了一个开源的代理ip池" class="headerlink" title="重新找了一个开源的代理ip池"></a>重新找了一个开源的代理ip池</h4><p><a href="https://github.com/Python3WebSpider/ProxyPool.git">https://github.com/Python3WebSpider/ProxyPool.git</a></p><h3 id="伪装浏览器进行访问-User-Agent"><a href="#伪装浏览器进行访问-User-Agent" class="headerlink" title="伪装浏览器进行访问(User-Agent)"></a>伪装浏览器进行访问(User-Agent)</h3><p>User-Agent中文名为用户代理，简称 UA，是Http协议中的一部分，属于头域的组成部分。它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p><h4 id="如何查看UA"><a href="#如何查看UA" class="headerlink" title="如何查看UA"></a>如何查看UA</h4><p>打开一个网页，按下F12，选择network，再点击headers就可以看到User-Agent</p><p>如果同一个网站被相同浏览器频繁访问，很容易被网站识别为爬虫程序，所以一般通过使用多个User-Agent随机调用的方式，可以有效避免同一个请求头访问网站。</p><h4 id="调用python中的useragent模块"><a href="#调用python中的useragent模块" class="headerlink" title="调用python中的useragent模块"></a>调用python中的useragent模块</h4><p>Python 中的第三方模块 fake_useragent 可以返回一个随机封装好的UA，直接使用即可。</p><p>先安装库：<code>pip install fake-useragent</code></p><p>简单的使用一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> fake_useragent<br><br><span class="hljs-comment"># 实例化 user-agent 对象</span><br>ua = fake_useragent.UserAgent()<br><span class="hljs-built_in">print</span>(ua.chrome)<br></code></pre></td></tr></table></figure><p>要频繁抓取一个网页，每次都设置一样的UA，这也会被网站怀疑，因此需要在抓取网页的过程中随机更换UA：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> fake_useragent<br><br><span class="hljs-comment"># 实例化 user-agent 对象</span><br>ua = fake_useragent.UserAgent()<br><span class="hljs-built_in">print</span>(ua.random)<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">import</span> fake_useragent<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> random<br><br>url = <span class="hljs-string">r&#x27;http://www.baidu.com/&#x27;</span><br>ua = fake_useragent.UserAgent()<br>list2 = []<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>:ua.random&#125;<span class="hljs-comment">#headers = &#123;&quot;User-Agent&quot;: ua.random&#125;</span><br>    list2.append(headers)<br>i= random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>req = request.Request(url,headers= list2[i])<br>pat = <span class="hljs-string">r&#x27;&lt;title&gt;(.*?)&lt;/title&gt;&#x27;</span><br>response = request.urlopen(req)<br><span class="hljs-built_in">print</span>(response.status)<br>reponse = request.urlopen(req).read().decode()<br>data = re.findall(pat,reponse)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#百度一下，你就知道</span><br></code></pre></td></tr></table></figure><h1 id="爬虫项目"><a href="#爬虫项目" class="headerlink" title="爬虫项目"></a>爬虫项目</h1><h2 id="DouBanSpider-–-豆瓣读书爬虫"><a href="#DouBanSpider-–-豆瓣读书爬虫" class="headerlink" title="DouBanSpider – 豆瓣读书爬虫"></a>DouBanSpider – 豆瓣读书爬虫</h2><p>可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。</p><h3 id="记录报错："><a href="#记录报错：" class="headerlink" title="记录报错："></a>记录报错：</h3><h4 id="AttributeError-module-‘urllib’-has-no-attribute-‘quote’"><a href="#AttributeError-module-‘urllib’-has-no-attribute-‘quote’" class="headerlink" title="AttributeError: module ‘urllib’ has no attribute ‘quote’"></a>AttributeError: module ‘urllib’ has no attribute ‘quote’</h4><p>报错的意思是在urllib模块中找不到名为quote的属性或函数。在Python中，urllib是一个用于处理URL的标准库模块，其中包含了许多有用的函数，包括quote和unquote函数，用于URL编码和解码。</p><p>在Python 3中，quote函数已经移动到了urllib.parse模块中，所以正确的调用方式应该是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.parse</span><br><br>url = <span class="hljs-string">&quot;https://example.com/?query=hello world&quot;</span><br>encoded_url = urllib<span class="hljs-selector-class">.parse</span><span class="hljs-selector-class">.quote</span>(url)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(encoded_url)</span></span><br></code></pre></td></tr></table></figure><h4 id="soup-BeautifulSoup-plain-text"><a href="#soup-BeautifulSoup-plain-text" class="headerlink" title="soup &#x3D; BeautifulSoup(plain_text)"></a>soup &#x3D; BeautifulSoup(plain_text)</h4><p>这个警告是来自BeautifulSoup库，它是一个用于解析HTML和XML文档的Python库。该警告表明您在创建BeautifulSoup对象时没有显式地指定解析器.可以将解析器设置为”lxml”，因为它是一个快速且功能强大的解析器。代码示例如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br># 显式指定解析器为<span class="hljs-string">&quot;lxml&quot;</span><br>soup = BeautifulSoup(plain_text, features=<span class="hljs-string">&quot;lxml&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果在代码中<code>已经显式指定了解析器为&quot;lxml&quot;，但仍然收到相同的警告</code>，那么代码中可能有多个地方创建了BeautifulSoup对象，并且其中某些地方没有传递features&#x3D;”lxml”参数。请检查代码中的其他地方，确认所有的BeautifulSoup对象创建都传递了正确的解析器参数。</p><h3 id="关于直接输出的解码问题"><a href="#关于直接输出的解码问题" class="headerlink" title="关于直接输出的解码问题"></a>关于直接输出的解码问题</h3><p>使用codecs库里面的escape_decode函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">book_list<span class="hljs-selector-class">.append</span>(<span class="hljs-selector-attr">[title,rating,people_num,author_info,pub_info]</span>)<br><br>           title_output = codecs<span class="hljs-selector-class">.escape_decode</span>(title)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           rating_output = codecs<span class="hljs-selector-class">.escape_decode</span>(rating)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           people_num_output = codecs<span class="hljs-selector-class">.escape_decode</span>(people_num)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           author_info_output = codecs<span class="hljs-selector-class">.escape_decode</span>(author_info)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           pub_info_output = codecs<span class="hljs-selector-class">.escape_decode</span>(pub_info)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           <span class="hljs-built_in">print</span>(title_output,rating_output,people_num_output,author_info_output,pub_info_output)<br></code></pre></td></tr></table></figure><h3 id="写入excel的技术积累"><a href="#写入excel的技术积累" class="headerlink" title="写入excel的技术积累"></a>写入excel的技术积累</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">def print_book_lists_excel(book_lists,book_tag_lists):<br>    wb=Workbook(optimized_write=True)<br>    <span class="hljs-keyword">ws</span>=[]<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)):<br>        <span class="hljs-keyword">ws</span>.<span class="hljs-keyword">append</span>(wb.create_sheet(title=book_tag_lists[i].decode())) #utf8-&gt;unicode<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)): <br>        <span class="hljs-keyword">ws</span>[i].<span class="hljs-keyword">append</span>([<span class="hljs-string">&#x27;序号&#x27;</span>,<span class="hljs-string">&#x27;书名&#x27;</span>,<span class="hljs-string">&#x27;评分&#x27;</span>,<span class="hljs-string">&#x27;评价人数&#x27;</span>,<span class="hljs-string">&#x27;作者&#x27;</span>,<span class="hljs-string">&#x27;出版社&#x27;</span>])<br>        <span class="hljs-built_in">count</span>=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">bl</span> in book_lists[i]:<br>            <span class="hljs-keyword">ws</span>[i].<span class="hljs-keyword">append</span>([<span class="hljs-built_in">count</span>,<span class="hljs-keyword">bl</span>[<span class="hljs-number">0</span>],float(<span class="hljs-keyword">bl</span>[<span class="hljs-number">1</span>]),<span class="hljs-keyword">int</span>(<span class="hljs-keyword">bl</span>[<span class="hljs-number">2</span>]),<span class="hljs-keyword">bl</span>[<span class="hljs-number">3</span>],<span class="hljs-keyword">bl</span>[<span class="hljs-number">4</span>]])<br>            <span class="hljs-built_in">count</span>+=<span class="hljs-number">1</span><br>    save_path=<span class="hljs-string">&#x27;book_list&#x27;</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)):<br>        save_path+=(<span class="hljs-string">&#x27;-&#x27;</span>+book_tag_lists[i].decode())<br>    save_path+=<span class="hljs-string">&#x27;.xlsx&#x27;</span><br>    wb.save(save_path)<br></code></pre></td></tr></table></figure><p>这段代码也提供了utf-8转unicode的方式：.decode( )函数</p><h2 id="bilibili用户数据爬虫"><a href="#bilibili用户数据爬虫" class="headerlink" title="bilibili用户数据爬虫"></a>bilibili用户数据爬虫</h2><p>p</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2023/07/28/python%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/28/python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>记录python的学习过程~</p><span id="more"></span> <h2 id="pycharm配置python开发环境"><a href="#pycharm配置python开发环境" class="headerlink" title="pycharm配置python开发环境"></a>pycharm配置python开发环境</h2><p>参考：<br><a href="https://blog.csdn.net/yuhui_2000/article/details/109185168">https://blog.csdn.net/yuhui_2000/article/details/109185168</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><ul><li>单行注释以 ＃ 号开头</li><li>多行注释用两个三引号&#96;&#96;&#96;包含起来<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>  <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">2.  第一行注释</span><br><span class="hljs-string">3.  第二行注释</span><br><span class="hljs-string">4.  &#x27;&#x27;&#x27;</span><br><span class="hljs-number">5.</span>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello,World!&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Python的行与缩进"><a href="#2-Python的行与缩进" class="headerlink" title="2. Python的行与缩进"></a>2. Python的行与缩进</h3><ul><li>使用缩进来表示代码块，不需要像C或者C++一样使用大括号。</li><li>缩进的空格数可变，但是同一个代码块的语句必须包含相同的缩进空格数</li><li>使用四个空格来表示一个缩进层级<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> x &gt; 0:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is positive&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;positive number&quot;</span>) <br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is zero or negative&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-多行语句"><a href="#3-多行语句" class="headerlink" title="3. 多行语句"></a>3. 多行语句</h3><p>Python 通常是一行写完一条语句；长语句可通过反斜杠（\）来实现多行语句。</p><p>python的print()函数中参数end&#x3D;’ ‘默认为\n，所以会自动换行。</p><ul><li>end&#x3D;’ ‘  表示不换行</li><li>end&#x3D;’\t’——表示缩进，就是按一下Tab键</li><li>end&#x3D;’\n’——相当于换行</li><li>end&#x3D;’\r’ 返回行首，最后一个字符的输入会将之前的字符全部覆盖掉</li></ul><h3 id="4-等待用户输入：input-函数"><a href="#4-等待用户输入：input-函数" class="headerlink" title="4. 等待用户输入：input() 函数"></a>4. 等待用户输入：input() 函数</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Who are you?&quot;</span>)<br>2.  you = input()<br>3.  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>4.  <span class="hljs-built_in">print</span>(you)<br></code></pre></td></tr></table></figure><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><ul><li>变量命名和赋值：Python 的变量无须提前声明，赋值的同时也就声明了变量。<br>  eg:<code>a = 42</code></li><li>查询关键字：keyword模块中的kwlist是一个列表，存放了Python中所有的关键字(str格式)。<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">#列出所有关键字<br><span class="hljs-keyword">import</span> keyword<br>keyword.kwlist <br><br>#判断是否为关键字，为真,返回<span class="hljs-literal">True</span>，为假,返回<span class="hljs-literal">False</span><br>keyword.iskeyword(<span class="hljs-string">&quot;break&quot;</span>)<br>keyword.iskeyword(<span class="hljs-string">&quot;breaka&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h3><p>Python 中拥有 6 大数据类型：number、string、list（列表）、tuple（元组）、sets （集合）、dictionary（字典）。</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>类型：int、float、bool、complex (复数)</p><p>使用 type() 函数来查看数字类型</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=1 <span class="hljs-attribute">b</span>=3.14 <span class="hljs-attribute">c</span>=<span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(type(a)) <span class="hljs-built_in">print</span>(type(b)) <span class="hljs-built_in">print</span>(type(c))<br></code></pre></td></tr></table></figure><p>运算类型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.  print((<span class="hljs-number">3</span>+<span class="hljs-number">1</span>))        #加法运算，输出结果是 <span class="hljs-number">4</span><br><span class="hljs-attribute">2</span>.  print((<span class="hljs-number">8</span>.<span class="hljs-number">4</span>-<span class="hljs-number">3</span>))      #减法运算，输出结果是<span class="hljs-number">5</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">3</span>.  print(<span class="hljs-number">15</span>/<span class="hljs-number">4</span>)         #除法运算，输出结果是 <span class="hljs-number">3</span>.<span class="hljs-number">75</span><br><span class="hljs-attribute">4</span>.  print(<span class="hljs-number">15</span>//<span class="hljs-number">4</span>)        #整除运算，输出结果是 <span class="hljs-number">3</span><br><span class="hljs-attribute">5</span>.  print(<span class="hljs-number">15</span>%<span class="hljs-number">4</span>)         #取余运算，输出结果是 <span class="hljs-number">3</span><br><span class="hljs-attribute">6</span>.  print(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)          #乘法运算，输出结果是 <span class="hljs-number">6</span><br><span class="hljs-attribute">7</span>.  print(<span class="hljs-number">2</span>**<span class="hljs-number">3</span>)         #乘方运算，输出结果是 <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>math 模块、cmath 模块:<br>数学运算常用的函数基本都在 math 模块、cmath 模块中。<br>要使用 math 或 cmath 函数必须先导入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> math<br></code></pre></td></tr></table></figure><p>更多数学函数、三角函数、<code>pi</code>,<code>e</code>、随机数函数等，详细参考：<br><a href="https://www.runoob.com/python/python-numbers.html">https://www.runoob.com/python/python-numbers.html</a></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>单引号与双引号的作用一样，但是当引号里包含单引号时，则该引号需使用双引号；三引号可以指示一个多行的字符串，也可以在三引号中自由使用单引号和双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#单引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;welcome to hangzhou&#x27;</span>)<br><span class="hljs-comment">#双引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;what’s your name?&quot;</span>)<br><span class="hljs-comment">#三引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;Mike:Hi,How are you?</span><br><span class="hljs-string">LiMing:Fine,Thank you!and you?</span><br><span class="hljs-string">Mike:I’m fine,too!&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>tips：</p><ol><li><p>使用双反斜杠（<code>\\</code>）来表示反斜杠本身，而 \n 表示换行</p></li><li><p>想要指示某些不需要使用转义符进行特别处理的字符串，那么需要指定一个原始字符串。原始字符串通过给字符串加上前缀 r 或 R：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">r&quot;换行符是\n。&quot;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(s)</span><br>换行符是\n。<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&#x27;it\&#x27;s me&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s</span><br>&quot;it&#x27;s me&quot;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&quot;换行符是\\n。&quot;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(s)</span><br>换行符是\n。<br></code></pre></td></tr></table></figure><p>详细可参考：<a href="https://blog.csdn.net/yawei_liu1688/article/details/108364192">https://blog.csdn.net/yawei_liu1688/article/details/108364192</a></p></li><li><p>字符串的截取（切片） ：<code>字符串常量[start_index:end_index+1]</code>(左闭右开)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-number">1.</span>  <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Lingyi&#x27;</span><br><span class="hljs-number">2.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>]) <span class="hljs-meta">#输出结果为L</span><br><span class="hljs-number">3.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]) <span class="hljs-meta">#输出结果为ing</span><br><span class="hljs-number">4.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">-1</span>]) <span class="hljs-meta">#输出结果为i</span><br></code></pre></td></tr></table></figure></li></ol><ul><li>[:] 这种形式 就是 从哪截取到哪里 如果是负数 就从后往前找</li><li>[::] 这种形式 第一个 ：代表处理后的字符串，第二个 ： 代表间隔截取，正数正向输出，负数代表逆向输出<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">str</span> = &#x27;<span class="hljs-number">0123456789</span>&#x27;<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[0:3]：&quot;</span>+str[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])     # 正向截取字符串 <span class="hljs-number">0</span>~<span class="hljs-number">3</span>（不包含<span class="hljs-number">3</span>）,即 <span class="hljs-number">012</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:]:&quot;</span>+str[:])          # 正向输出所有字符串,即<span class="hljs-number">0123456789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[6:]：&quot;</span>+str[<span class="hljs-number">6</span>:])       # 正向输出字符,从 <span class="hljs-number">6</span> ~ 结束  即 <span class="hljs-number">6789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-3]：&quot;</span>+str[:-<span class="hljs-number">3</span>])     # 正向输出,从开始 ~ 倒数第第<span class="hljs-number">3</span>个字符（不含第<span class="hljs-number">3</span>个）即 <span class="hljs-number">0123456</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[2]：&quot;</span>+str[<span class="hljs-number">2</span>])         #输出第<span class="hljs-number">3</span>个字符 即 <span class="hljs-number">2</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-1]：&quot;</span>+str[:-<span class="hljs-number">1</span>])     # 正向输出,从开始 ~ 倒数第第<span class="hljs-number">1</span>个字符（不含第<span class="hljs-number">1</span>个）即 <span class="hljs-number">012345678</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-1]：&quot;</span>+str[-<span class="hljs-number">1</span>])       # 输出最后一个字符 即 <span class="hljs-number">9</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-3:-1]:&quot;</span>+str[-<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>])  #逆序输出,从倒数第 <span class="hljs-number">3</span> ~ 倒数第 <span class="hljs-number">1</span> （不含） 即 <span class="hljs-number">78</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-3:]:&quot;</span>+str[-<span class="hljs-number">3</span>:])      # 逆序输出,从倒数第 <span class="hljs-number">3</span> ~ 最后 即 <span class="hljs-number">789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::-1]：&quot;</span>+str[::-<span class="hljs-number">1</span>])   # 逆序输出,连续输出所有字符串,即  <span class="hljs-number">9876543210</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::-2]：&quot;</span>+str[::-<span class="hljs-number">2</span>])   # 逆序输出,从最后一个开始，每隔<span class="hljs-number">2</span>个字符串输出一个  <span class="hljs-number">97531</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::1]：&quot;</span>+str[::<span class="hljs-number">1</span>])     # 正序输出,连续输出所有字符串,即 <span class="hljs-number">0123456789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::2]：&quot;</span>+str[::<span class="hljs-number">2</span>])     # 正序输出,从第一个开始，每隔<span class="hljs-number">2</span>个字符串输出一个即 <span class="hljs-number">02468</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-2:4]:&quot;</span>+str[:-<span class="hljs-number">2</span>:<span class="hljs-number">4</span>])  # 正序输出,从第一个开始，每隔<span class="hljs-number">4</span>个字符输出一个 即 <span class="hljs-number">04</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[1:-2:4]:&quot;</span>+str[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>:<span class="hljs-number">4</span>])# 正序输出,从第二个开始，每隔<span class="hljs-number">4</span>个字符输出一个 即 <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>不同数据类型可以相互转换<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-number">1.</span>  <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>  string = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-number">3.</span>  num2 = <span class="hljs-built_in">int</span>(string)<br><span class="hljs-number">4.</span>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>+num2)<br></code></pre></td></tr></table></figure></li><li><code>+</code>用在字符串中间是连接符，用在数值中间是运算符<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#运算符，结果为3</span><br><span class="hljs-bullet">1.</span>  a = 1<br><span class="hljs-bullet">2.</span>  b = 2<br><span class="hljs-bullet">3.</span>  c = a+b<br><span class="hljs-bullet">4.</span>  print(c)<br><br><span class="hljs-section">#连接符，结果为ab</span><br><span class="hljs-bullet">1.</span>  a = 1<br><span class="hljs-bullet">2.</span>  b = 2<br><span class="hljs-bullet">3.</span>  c = &#x27;a&#x27;+&#x27;b&#x27;<br><span class="hljs-bullet">4.</span>  print(c)<br></code></pre></td></tr></table></figure></li><li>字符串的驻留机制：<a href="https://zhuanlan.zhihu.com/p/35362912">https://zhuanlan.zhihu.com/p/35362912</a></li><li>字符串内建函数：实现了 string 模块的大部分方法。<br>详细参考：<a href="https://www.runoob.com/python/python-strings.html">https://www.runoob.com/python/python-strings.html</a></li></ol><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是任意对象的有序集合，元素之间用逗号隔开。这里的任意对象，包括列表嵌套列表。</p><ol><li>列表删除操作：<ul><li><p><code>del 目标 或 del(目标)</code>\</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除列表</span><br>list1 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br><span class="hljs-comment"># 2种写法</span><br><span class="hljs-built_in">del</span> list1<br><span class="hljs-comment"># del(list1 )</span><br><br><span class="hljs-comment"># 删除指定数据</span><br>list2 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br><span class="hljs-built_in">del</span> list2[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li><li><p><code>pop()</code><br> 删除指定下标的数据，如果不指定下标，默认删除最后一个数据，无论是按照下标还是删除最后一个，pop函数都会返回这个被删除的数据</p></li><li><p><code>remove(数据)</code></p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list1 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br>list1.<span class="hljs-built_in">remove</span>(<span class="hljs-string">&#x27;python&#x27;</span>)<br><span class="hljs-comment"># 也可以写成：list1.remove(list1[0]) </span><br></code></pre></td></tr></table></figure></li><li><p><code>clear(列表名) </code>：清空列表</p></li></ul></li><li>更新列表：使用<code>append()</code>添加列表项</li><li>列表脚本操作符:<br>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</li><li>常用列表函数：<br><a href="https://www.runoob.com/python/python-lists.html">https://www.runoob.com/python/python-lists.html</a></li></ol><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号，列表使用方括号。</p><ol><li>删除元组：<code>del 元组名</code></li><li>对元组连接组合</li><li>元组运算符（进行组合和复制）</li><li>元组索引，截取</li><li>无关闭分隔符：任意无符号的对象，以逗号隔开，默认为元组</li><li>元组内置函数：<br><a href="https://www.runoob.com/python/python-tuples.html">https://www.runoob.com/python/python-tuples.html</a></li></ol><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>一种可变容器模型，且可存储任意类型对象。<br><code>dict</code> 作为 Python 的关键字和内置函数，字典的变量名不建议命名为 dict。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">d = &#123;key1 : <span class="hljs-type">value1</span>, key2 : <span class="hljs-type">value2</span> &#125;<br></code></pre></td></tr></table></figure><p>字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><ul><li>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</li><li>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</li></ul><ol><li>访问字典的值<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python</span><br> <br>tinydict = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Zara&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: 7, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Age&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li>修改字典<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tinydict = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: <span class="hljs-number">7</span>, &#x27;Class&#x27;: &#x27;First&#x27;&#125;<br> <br>tinydict[&#x27;Age&#x27;] = <span class="hljs-number">8</span> <span class="hljs-meta"># 更新</span><br>tinydict[&#x27;School&#x27;] = <span class="hljs-string">&quot;RUNOOB&quot;</span> <span class="hljs-meta"># 添加</span><br></code></pre></td></tr></table></figure></li><li>删除字典元素<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">del</span> tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>]  <span class="hljs-comment"># 删除键是&#x27;Name&#x27;的条目</span><br>tinydict.clear()      <span class="hljs-comment"># 清空字典所有条目</span><br><span class="hljs-built_in">del</span> tinydict          <span class="hljs-comment"># 删除字典</span><br></code></pre></td></tr></table></figure></li><li>字典内置函数&amp;方法<br><a href="https://www.runoob.com/python/python-dictionary.html">https://www.runoob.com/python/python-dictionary.html</a></li></ol><h3 id="7-日期与时间"><a href="#7-日期与时间" class="headerlink" title="7. 日期与时间"></a>7. 日期与时间</h3><p>Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。</p><p>时间间隔是以秒为单位的浮点小数。每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。</p><p><code>time.time()</code> 用于获取当前时间戳 </p><h4 id="struct-time元组"><a href="#struct-time元组" class="headerlink" title="struct_time元组"></a><code>struct_time</code>元组</h4><p>很多Python函数用一个元组装起来的9组数字处理时间:<br>html <div align="center"> <img src="https://img-blog.csdnimg.cn/f3c5757a142747c28166d8d1ede987e6.png " width="80%"> </div></p><h4 id="获取当前时间："><a href="#获取当前时间：" class="headerlink" title="获取当前时间："></a>获取当前时间：</h4><p>从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br> <br><span class="hljs-built_in">localtime</span> = <span class="hljs-type">time</span>.<span class="hljs-built_in">localtime</span>(<span class="hljs-type">time</span>.time())<br>print &quot;本地时间为 :&quot;, <span class="hljs-built_in">localtime</span><br></code></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">本地时间为 : time.struct_time(<span class="hljs-attribute">tm_year</span>=2016, <span class="hljs-attribute">tm_mon</span>=4, <span class="hljs-attribute">tm_mday</span>=7, <span class="hljs-attribute">tm_hour</span>=10, <span class="hljs-attribute">tm_min</span>=3, <span class="hljs-attribute">tm_sec</span>=27, <span class="hljs-attribute">tm_wday</span>=3, <span class="hljs-attribute">tm_yday</span>=98, <span class="hljs-attribute">tm_isdst</span>=0)<br></code></pre></td></tr></table></figure><h4 id="获取格式化的时间-asctime"><a href="#获取格式化的时间-asctime" class="headerlink" title="获取格式化的时间: asctime()"></a>获取格式化的时间: <code>asctime()</code></h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">localtime</span> = <span class="hljs-type">time</span>.asctime( <span class="hljs-type">time</span>.<span class="hljs-built_in">localtime</span>(<span class="hljs-type">time</span>.time()) )<br></code></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">本地时间为 : <span class="hljs-type">Thu</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">10</span>:<span class="hljs-number">05</span>:<span class="hljs-number">21</span> <span class="hljs-number">2016</span><br></code></pre></td></tr></table></figure><h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>使用 time 模块的 <code>strftime</code> 来格式化日期 :<br><code>time.strftime(format[, t])</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">import <span class="hljs-keyword">time</span><br> <br><span class="hljs-comment"># 格式化成2016-03-20 11:45:39形式</span><br><span class="hljs-keyword">print</span> time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) <br> <br><span class="hljs-comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span><br><span class="hljs-keyword">print</span> time.strftime(<span class="hljs-string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>, time.localtime()) <br>  <br><span class="hljs-comment"># 将格式字符串转换为时间戳</span><br>a = <span class="hljs-string">&quot;Sat Mar 28 22:24:24 2016&quot;</span><br><span class="hljs-keyword">print</span> time.mktime(time.strptime(a,<span class="hljs-string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>))<br></code></pre></td></tr></table></figure><p>日期格式化符号解释：<a href="https://www.runoob.com/python/python-date-time.html">https://www.runoob.com/python/python-date-time.html</a></p><h4 id="获取某月日历：引入calendar模块"><a href="#获取某月日历：引入calendar模块" class="headerlink" title="获取某月日历：引入calendar模块"></a>获取某月日历：引入<code>calendar</code>模块</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import calendar<br> <br>cal = calendar.month(2016, 1)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;以下输出2016年1月份的日历:&quot;</span><br><span class="hljs-built_in">print</span> cal<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">以下输出2016年1月份的日历:<br>    January 2016<br>Mo Tu We Th Fr Sa Su<br>            <span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span> 3<br><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span>10<br>11<span class="hljs-number"> 12 </span>13<span class="hljs-number"> 14 </span>15<span class="hljs-number"> 16 </span>17<br>18<span class="hljs-number"> 19 </span>20<span class="hljs-number"> 21 </span>22<span class="hljs-number"> 23 </span>24<br>25<span class="hljs-number"> 26 </span>27<span class="hljs-number"> 28 </span>29<span class="hljs-number"> 30 </span>31<br></code></pre></td></tr></table></figure><p>补充： python中关于时间和日期方面的模块有：<code>Time</code> 模块、<code>Calendar</code>模块、<code>datetime</code>模块、<code>pytz</code>模块、<code>dateutil</code>模块。<br>详细参考：<a href="https://www.runoob.com/python/python-date-time.html">https://www.runoob.com/python/python-date-time.html</a></p><h3 id="8-语句"><a href="#8-语句" class="headerlink" title="8. 语句"></a>8. 语句</h3><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false</p><ol><li>python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现。<br>如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if 判断条件1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句1……</span><br><span class="hljs-attribute">elif 判断条件2</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句2……</span><br><span class="hljs-attribute">elif 判断条件3</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句3……</span><br><span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>    执行语句4……<br></code></pre></td></tr></table></figure></li><li>也可以在同一行的位置上使用if条件判断语句<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> = <span class="hljs-number">100</span> <br> <br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">var</span>  == <span class="hljs-number">100</span> ) : <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;变量 var 的值为100&quot;</span> <br></code></pre></td></tr></table></figure></li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ol><li><p>基本语法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># while循环</span><br><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(<span class="hljs-built_in">statements</span>)……<br><br><span class="hljs-meta"># for循环</span><br><span class="hljs-keyword">for</span> iterating_var in sequence:<br>   statements(s)<br></code></pre></td></tr></table></figure></li><li><p>continue 用于跳过该次循环，break 则是用于退出循环。<br>此外”判断条件”还可以是个常值，表示循环必定成立。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># continue 和 break 用法</span><br> <br><span class="hljs-attribute">i</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">while</span> i &lt; <span class="hljs-number">10</span>:   <br>    <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> i%<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>:     # 非双数时跳过输出<br>        <span class="hljs-attribute">continue</span><br>    <span class="hljs-attribute">print</span> i         # 输出双数<span class="hljs-number">2</span>、<span class="hljs-number">4</span>、<span class="hljs-number">6</span>、<span class="hljs-number">8</span>、<span class="hljs-number">10</span><br> <br><span class="hljs-attribute">i</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">while</span> <span class="hljs-number">1</span>:            # 循环条件为<span class="hljs-number">1</span>必定成立<br>    <span class="hljs-attribute">print</span> i         # 输出<span class="hljs-number">1</span>~<span class="hljs-number">10</span><br>    <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> i &gt; <span class="hljs-number">10</span>:     # 当i大于<span class="hljs-number">10</span>时跳出循环<br>        <span class="hljs-attribute">break</span><br></code></pre></td></tr></table></figure></li><li><p>无限循环：如果条件判断语句永远为 true，循环将会无限的执行下去<br>可以使用 <code>CTRL+C</code>来中断无限循环。</p></li><li><p>循环使用 else 语句</p></li></ol><ul><li>while … else 在循环条件为 false 时执行 else 语句块 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">count</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">count</span> &lt; <span class="hljs-number">5</span>:<br>   <span class="hljs-keyword">print</span> <span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; is  less than 5&quot;</span><br>   <span class="hljs-keyword">count</span> = <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> <span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; is not less than 5&quot;</span><br></code></pre></td></tr></table></figure></li><li>for循环<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,<span class="hljs-built_in">num</span>): <span class="hljs-comment"># 根据因子迭代</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span>%i == <span class="hljs-number">0</span>:      <span class="hljs-comment"># 确定第一个因子</span><br>         j=<span class="hljs-built_in">num</span>/i          <span class="hljs-comment"># 计算第二个因子</span><br>         print (<span class="hljs-string">&#x27;%d 等于 %d * %d&#x27;</span> % (<span class="hljs-built_in">num</span>,i,j))<br>         break            <span class="hljs-comment"># 跳出当前循环</span><br>   <span class="hljs-keyword">else</span>:                  <span class="hljs-comment"># 循环的 else 部分</span><br>      print (<span class="hljs-string">&#x27;%d 是一个质数&#x27;</span> % <span class="hljs-built_in">num</span>)<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>简单语句组<br>如果while 循环体中只有一条语句，可以将该语句与while写在同一行中<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">flag = <span class="hljs-number">1</span><br> <br><span class="hljs-keyword">while</span> (flag): print <span class="hljs-symbol">&#x27;Given</span> flag <span class="hljs-keyword">is</span> really <span class="hljs-literal">true</span>!&#x27;<br></code></pre></td></tr></table></figure></li><li>通过序列索引迭代<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>,  <span class="hljs-string">&#x27;mango&#x27;</span>]<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">index</span> in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fruits)):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当前水果 : %s&#x27;</span> % fruits[<span class="hljs-built_in">index</span>])<br></code></pre></td></tr></table></figure></li></ol><h4 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h4><p> pass 是空语句，是为了保持程序结构的完整性，用做占位语句。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 输出 Python 的每个字母</span><br><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Python&#x27;</span>:<br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;h&#x27;</span>:<br>      pass<br>      <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;这是 pass 块&#x27;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;当前字母 :&#x27;</span>, letter<br></code></pre></td></tr></table></figure><h3 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9. 运算符"></a>9. 运算符</h3><h4 id="算术运算符（略）"><a href="#算术运算符（略）" class="headerlink" title="算术运算符（略）"></a>算术运算符（略）</h4><h4 id="比较运算符（略）"><a href="#比较运算符（略）" class="headerlink" title="比较运算符（略）"></a>比较运算符（略）</h4><h4 id="赋值运算符（略）"><a href="#赋值运算符（略）" class="headerlink" title="赋值运算符（略）"></a>赋值运算符（略）</h4><p>参考：<a href="https://www.runoob.com/python/python-operators.html">https://www.runoob.com/python/python-operators.html</a></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>按位运算符是把数字看作二进制来进行计算的</p><table><thead><tr><th>运算符</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符</td><td>参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td></tr><tr><td>I</td><td>按位或运算符</td><td>只要对应的二个二进位有一个为1时，结果位就为1</td></tr><tr><td>^</td><td>按位异或运算符</td><td>当两对应的二进位相异时，结果为1</td></tr><tr><td>~</td><td>按位取反运算符</td><td>对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符</td><td>运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符</td><td>把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li>and</li><li>or</li><li>not</li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><ul><li>in</li><li>not in<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 10<br>list = [1, 2, 3, 4, 5 ];<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 在给定的列表中 list 中&quot;</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 不在给定的列表中 list 中&quot;</span><br> <br><span class="hljs-comment"># 修改变量 a 的值</span><br>a = 2<br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 在给定的列表中 list 中&quot;</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 不在给定的列表中 list 中&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h4><p>用于比较两个对象的存储单元(本质是判断指针)</p><ul><li>is</li><li>is not</li></ul><p>tips：<code>is 与 == 区别</code> :</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><h3 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h3><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params"> parameters </span>):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><ul><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-attr">a</span>=<span class="hljs-string">&quot;Runoob&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p><ul><li><p>可更改(mutable)与不可更改(immutable)对象:<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><p>不可变类型：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</p></li><li><p>可变类型：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p></li></ul></li><li><p>python 函数的参数传递：</p><ul><li><p>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</p></li><li><p>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</p></li></ul></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p></li><li><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值<br>参数默认值在函数声明时设置</p></li></ul><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] *var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>tuple ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>加了星号（*）的变量名会存放所有未命名的变量参数<br>示例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta">def printinfo( arg1, *vartuple ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">print</span> arg1<br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">var</span> <span class="hljs-keyword">in</span> vartuple: <span class="hljs-meta">#哇哦，这里的for in体现出不定长的特性！！</span><br>      <span class="hljs-keyword">print</span> <span class="hljs-built_in">var</span><br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-meta"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><h4 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="hljs-symbol">:expression</span><br></code></pre></td></tr></table></figure><ul><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">相加后的值为 :  30<br>相加后的值为 :  40<br></code></pre></td></tr></table></figure></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>全局变量</li><li>局部变量</li></ul><h3 id="11-python的版本迭代备注"><a href="#11-python的版本迭代备注" class="headerlink" title="11.python的版本迭代备注"></a>11.python的版本迭代备注</h3><h4 id="关于设置Python解释器的默认字符编码为UTF-8"><a href="#关于设置Python解释器的默认字符编码为UTF-8" class="headerlink" title="关于设置Python解释器的默认字符编码为UTF-8"></a>关于设置Python解释器的默认字符编码为UTF-8</h4><p>一些开源项目里面的python代码会写成：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> sys<br># 设置默认编码为UTF<span class="hljs-number">-8</span><br>sys.setdefaultencoding(<span class="hljs-string">&#x27;utf8&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但Python 3中已经移除了sys.setdefaultencoding()函数，因为它会导致潜在的问题，特别是与第三方库的兼容性。</p><p>在Python 3中，字符串默认使用Unicode编码（UTF-8），而且不再需要显式地设置默认编码,直接使用Unicode字符串而不用担心编码问题。</p><h4 id="decode-和encode"><a href="#decode-和encode" class="headerlink" title="decode( )和encode( )"></a>decode( )和encode( )</h4><p>在Python 3中，decode()方法用于将字节转换为字符串，而encode()方法用于将字符串转换为字节</p><h2 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1. 模块"></a>1. 模块</h3><p>Python 模块(Module)，是一个 Python 文件，以<code> .py</code> 结尾，包含了 Python 对象定义和Python语句。</p><p>模块能够有逻辑地组织Python 代码段。把相关的代码分配到一个模块里能让代码更好用，更易懂。</p><p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><h4 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">import</span> <span class="hljs-keyword">module</span><span class="hljs-number">1</span>[, <span class="hljs-keyword">module</span><span class="hljs-number">2</span>[,... moduleN]]<br></code></pre></td></tr></table></figure><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><h4 id="搜索路径和环境变量"><a href="#搜索路径和环境变量" class="headerlink" title="搜索路径和环境变量"></a>搜索路径和环境变量</h4><p><a href="https://www.runoob.com/python/python-modules.html">https://www.runoob.com/python/python-modules.html</a></p><h4 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h4><p>命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。</p><p>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。如果要给函数内的全局变量赋值，必须使用 global 语句：<br><code>global VarName</code></p><h4 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h4><p>排好序的字符串列表，内容是一个模块里定义过的名字。<br>返回的列表容纳了在一个模块里定义的所有模块，变量和函数。</p><h4 id="globals-和-locals-函数、reload-函数"><a href="#globals-和-locals-函数、reload-函数" class="headerlink" title="globals() 和 locals() 函数、reload() 函数"></a>globals() 和 locals() 函数、reload() 函数</h4><p><a href="https://www.runoob.com/python/python-modules.html">https://www.runoob.com/python/python-modules.html</a></p><h4 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h4><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。</p><p>简单来说，包就是文件夹，但该文件夹下必须存在 <strong>init</strong>.py 文件, 该文件的内容可以为空。<strong>init</strong>.py 用于标识当前文件夹是一个包。<br>更多可以参考：<br><a href="https://www.runoob.com/python3/python3-module.html">https://www.runoob.com/python3/python3-module.html</a></p><h3 id="2-File-文件-方法"><a href="#2-File-文件-方法" class="headerlink" title="2.  File(文件) 方法"></a>2.  File(文件) 方法</h3><h4 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h4><ul><li>raw_input函数<br>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</li><li>input函数<br>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-keyword">input</span>(<span class="hljs-string">&quot;请输入：&quot;</span>)<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;你输入的内容是: &quot;</span>, <span class="hljs-keyword">str</span><br></code></pre></td></tr></table></figure>示例：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">请输入：<span class="hljs-comment">[x*5 for x in range(2,10,2)]</span><br>你输入的内容是:  <span class="hljs-comment">[10, 20, 30, 40]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="打开、关闭和读写文件"><a href="#打开、关闭和读写文件" class="headerlink" title="打开、关闭和读写文件"></a>打开、关闭和读写文件</h4><ul><li><p>open函数 ：打开一个文件，创建一个file对象<br><code>file object = open(file_name ,[access_mode],[buffering])</code></p><ul><li>file_name：file_name变量是一个包含了你要访问的文件名称的字符串值</li><li>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)</li><li>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认</li></ul></li><li><p>File对象的属性</p></li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>file.closed</td><td>返回true如果文件已被关闭，否则返回false</td></tr><tr><td>file.mode</td><td>返回被打开文件的访问模式</td></tr><tr><td>file.name</td><td>返回文件的名称</td></tr><tr><td>file.softspace</td><td>如果用print输出后，必须跟一个空格符，则返回false；否则返回true</td></tr></tbody></table><ul><li><p>close（）函数<br><code>fileObject.close()</code> :<br>刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入</p></li><li><p>write()函数<br><code>fileObject.write(string)</code> :将字符串写入一个打开的文件</p><ul><li>Python字符串可以是二进制数据，而不是仅仅是文字。</li><li>write()方法不会在字符串的结尾添加换行符(‘\n’)。</li></ul></li><li><p>read()函数<br><code>fileObject.read([count])</code> :从一个打开的文件中读取一个字符串</p><ul><li>被传递的参数是要从已打开文件中读取的字节计数</li><li>从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾<br>示例：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"># 打开一个文件<br><span class="hljs-keyword">fo</span> = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-keyword">fo</span>.<span class="hljs-keyword">write</span>( <span class="hljs-string">&quot;www.runoob.com!\nVery good site!\n&quot;</span>)<br>str = <span class="hljs-keyword">fo</span>.<span class="hljs-keyword">read</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;读取的字符串是 : &quot;</span>, str<br># 关闭打开的文件<br><span class="hljs-keyword">fo</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure>运行结果 ：<code>读取的字符串是 :  www.runoob</code></li></ul></li></ul><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><ul><li><code>tell()</code> :返回文件内的当前位置，下一次的读写会发生在文件开头这么多字节之后</li><li><code>seek（offset,[from]）</code> :改变当前文件的位置<ul><li>offset变量表示要移动的字节数</li><li>from变量指定开始移动字节的参考位置</li><li>如果from设为0，将文件的开头作为移动字节的参考位置。<br>  如果设为1，则使用当前的位置作为参考位置。<br>  如果设为2，那么该文件的末尾将作为参考位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 打开一个文件</span><br>fo = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>)<br><span class="hljs-built_in">str</span> = fo.read(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;读取的字符串是 : &quot;</span>, <span class="hljs-built_in">str</span><br> <br><span class="hljs-comment"># 查找当前位置</span><br>position = fo.tell()<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;当前文件位置 : &quot;</span>, position<br> <br><span class="hljs-comment"># 把指针再次重新定位到文件开头</span><br>position = fo.seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">str</span> = fo.read(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;重新读取字符串 : &quot;</span>, <span class="hljs-built_in">str</span><br><span class="hljs-comment"># 关闭打开的文件</span><br>fo.close()<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">读取的字符串是 :  <span class="hljs-type">www.runoob</span><br>当前文件位置 :  10<br>重新读取字符串 :  <span class="hljs-type">www.runoob</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h4><p>Python的<code>os</code>模块提供了执行文件处理操作的方法，比如重命名和删除文件。</p><p>要使用这个模块，必须先 <code>import os</code>。</p><ul><li>os.rename(current_file_name, new_file_name)<br>重命名文件</li><li>os.remove(file_name)<br>删除文件</li></ul><h4 id="Python里的目录"><a href="#Python里的目录" class="headerlink" title="Python里的目录"></a>Python里的目录</h4><ul><li>os.mkdir(“newdir”)<br>在当前目录下创建新的目录</li><li>os.chdir(“newdir”)<br>改变当前的目录<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span><br> <br># 将当前目录改为<span class="hljs-string">&quot;/home/newdir&quot;</span><br><span class="hljs-built_in">os</span>.chdir(<span class="hljs-string">&quot;/home/newdir&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>os.getcwd()<br>显示当前的工作目录</li><li>os.rmdir(‘dirname’)<br>删除目录，目录名称以参数传递，目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br>更多参考：<a href="https://www.runoob.com/python/file-methods.html">https://www.runoob.com/python/file-methods.html</a></li></ul><h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4><p>用于简化资源管理的一种结构。它允许在代码块中打开一个资源（例如文件、网络连接、数据库连接等），并在使用完毕后自动关闭资源，无需显式地调用关闭方法。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> expression [<span class="hljs-keyword">as</span> <span class="hljs-built_in">variable</span>]:<br>    <span class="hljs-comment"># Code block using the resource</span><br></code></pre></td></tr></table></figure><ul><li><p>expression通常是一个返回可上下文管理器（context manager）的表达式，而可上下文管理器是一个具有<code>__enter__()</code>和<code>__exit__()</code>方法的对象。</p></li><li><p><code>__enter__()</code>方法在进入with代码块时被调用，它负责设置资源，例如打开文件或建立网络连接，并返回相关的资源对象。而<code>__exit__()</code>方法在退出with代码块时被调用，它负责释放资源，例如关闭文件或断开网络连接。</p></li></ul><p>在with语句块中可以使用资源对象，并在代码块执行完毕后，Python会自动调用<code>__exit__()</code>方法来释放资源，即使在代码块中发生了异常也会执行。这样可以确保资源的正确关闭，避免资源泄漏。</p><p>常见例子：使用with来打开文件</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(<span class="hljs-symbol">&#x27;example</span>.txt&#x27;, <span class="hljs-symbol">&#x27;r</span>&#x27;) as <span class="hljs-keyword">file</span>:<br>    content = <span class="hljs-keyword">file</span>.read()<br>    # Code <span class="hljs-keyword">block</span> <span class="hljs-keyword">to</span> work <span class="hljs-keyword">with</span> the <span class="hljs-keyword">file</span> content<br><br># <span class="hljs-keyword">After</span> exiting the <span class="hljs-symbol">&#x27;with</span>&#x27; <span class="hljs-keyword">block</span>, the <span class="hljs-keyword">file</span> <span class="hljs-keyword">is</span> automatically closed.<br></code></pre></td></tr></table></figure><p>在这个例子中，open()函数返回一个文件对象，它是一个上下文管理器。<code>with open(&#39;example.txt&#39;, &#39;r&#39;) as file:</code>会打开名为example.txt的文件，并将文件对象赋值给file变量。在代码块中，我们可以使用file对象读取文件内容。不论代码块是否抛出异常，with语句执行完毕后，文件对象会被自动关闭，无需显式调用file.close()方法。</p><h4 id="readline-函数"><a href="#readline-函数" class="headerlink" title="readline( )函数"></a>readline( )函数</h4><p>用于从文件对象中逐行读取数据，用于读取文件的一行内容，并返回一个字符串，包含了该行的内容（包括行尾的换行符 \n）。<br>每次调用readline()，都会读取文件当前位置的下一行，并将文件指针移动到下一行的开头，直到文件末尾。</p><p>当文件对象的指针移动到文件末尾后，再次调用readline()会返回空字符串，表示文件已经读取完毕。因此，在使用readline()时，通常使用循环来逐行读取文件的内容，直到返回空字符串为止，标志文件的末尾。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-built_in">line</span> = <span class="hljs-built_in">file</span>.readline()<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">line</span>:<br>        print(<span class="hljs-built_in">line</span>.strip())  <span class="hljs-comment"># Remove the newline characters</span><br>        <span class="hljs-built_in">line</span> = <span class="hljs-built_in">file</span>.readline()<br></code></pre></td></tr></table></figure><h4 id="strip-函数"><a href="#strip-函数" class="headerlink" title="strip()函数"></a>strip()函数</h4><p>用于去除字符串首尾的指定字符（默认是空格和换行符）或空白字符。它返回一个新的字符串，该字符串是去除了首尾指定字符后的原始字符串。</p><p>语法格式：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">string</span>.strip([<span class="hljs-keyword">chars</span>])<br></code></pre></td></tr></table></figure><p>其中，string是要操作的字符串，而chars是可选参数，用于指定需要去除的字符集合。如果不提供chars参数，则默认去除字符串首尾的空白字符（空格、制表符、换行符等）。</p><p>示例：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;   Hello, world!   &quot;</span><br><span class="hljs-literal">result</span> = <span class="hljs-built_in">text</span>.strip()  <span class="hljs-comment"># Removes leading and trailing whitespaces</span><br>print(<span class="hljs-literal">result</span>)  <span class="hljs-comment"># Output: &quot;Hello, world!&quot;</span><br><br>text2 = <span class="hljs-string">&quot;----Hello, world!---&quot;</span><br>result2 = text2.strip(<span class="hljs-string">&quot;-&quot;</span>)  <span class="hljs-comment"># Removes leading and trailing dashes</span><br>print(result2)  <span class="hljs-comment"># Output: &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3. 内置函数"></a>3. 内置函数</h3><p><a href="https://www.runoob.com/python/python-built-in-functions.html">https://www.runoob.com/python/python-built-in-functions.html</a></p><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h3><h4 id="try…-except…else"><a href="#try…-except…else" class="headerlink" title="try….except…else"></a>try….except…else</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">try:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#运行别的代码</span><br>except <span class="hljs-variable">&lt;名字&gt;</span>：<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果在try部份引发了&#x27;name&#x27;异常</span><br>except <span class="hljs-variable">&lt;名字&gt;</span>，<span class="hljs-variable">&lt;数据&gt;</span>:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span><br>else:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果没有异常发生</span><br></code></pre></td></tr></table></figure><ul><li><p>当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p></li><li><p>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</p></li><li><p>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</p></li><li><p>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</p></li></ul><h4 id="使用except而不带任何异常类型"><a href="#使用except而不带任何异常类型" class="headerlink" title="使用except而不带任何异常类型"></a>使用except而不带任何异常类型</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except:<br>    发生异常，执行这块代码<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br><span class="hljs-keyword">else</span>:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><h4 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except(Exception1<span class="hljs-meta">[</span>, Exception2<span class="hljs-meta">[</span>,<span class="hljs-params">...</span>ExceptionN<span class="hljs-meta">]</span>]):<br>   发生以上多个异常中的一个，执行这块代码<br>   ......................<br>else:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><h4 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h4><p>无论是否发生异常都将执行最后的代码</p><h4 id="异常的参数"><a href="#异常的参数" class="headerlink" title="异常的参数"></a>异常的参数</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except ExceptionType, Argument:<br>    你可以在这输出 Argument 的值<span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>一个异常可以带上参数，可作为输出的异常信息参数。<br>可以通过except语句来捕获异常的参数。</p><ul><li>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。</li></ul><h4 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h4><p><code>raise [Exception, [args,[traceback]]]</code></p><ul><li>Exception 是异常的类型（例如，NameError）参数标准异常中任一种</li><li>args 是自已提供的异常参数</li><li>最后一个参数是可选的（在实践中很少使用），如果存在，跟踪异常对象<br>示例：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def functionName( <span class="hljs-keyword">level</span> ):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">level</span> &lt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> <span class="hljs-keyword">Exception</span>(&quot;Invalid level!&quot;, <span class="hljs-keyword">level</span>)<br>        # 触发异常后，后面的代码就不会再执行<br></code></pre></td></tr></table></figure>tips：为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。</li></ul><p>例如我们捕获以上异常，”except”语句如下所示：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">try</span>:<br>    正常逻辑<br><span class="hljs-keyword">except</span> Exception,err:<br>    触发自定义异常    <br><span class="hljs-keyword">else</span>:<br>    其余代码<br></code></pre></td></tr></table></figure><h4 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h4><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。<br><a href="https://www.runoob.com/python/python-exceptions.html">https://www.runoob.com/python/python-exceptions.html</a></p><h3 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h3><p><a href="https://blog.csdn.net/zhaofuxiang/article/details/53379394">https://blog.csdn.net/zhaofuxiang/article/details/53379394</a></p><h3 id="6-推导式"><a href="#6-推导式" class="headerlink" title="6.推导式"></a>6.推导式</h3><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体</p><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[表达式 for 变量 in 列表]</span> <br><span class="hljs-string">[out_exp_res for out_exp in input_list]</span><br><br>或者 <br><span class="hljs-string"></span><br><span class="hljs-string">[表达式 for 变量 in 列表 if 条件]</span><br><span class="hljs-string">[out_exp_res for out_exp in input_list if condition]</span><br></code></pre></td></tr></table></figure><ul><li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li><li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li><li>if condition：条件语句，可以过滤列表中不符合条件的值。</li></ul><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; key_expr: value_expr for value in collection &#125;<br><br>或<br><br>&#123; key_expr: value_expr for value in collection if condition &#125;<br></code></pre></td></tr></table></figure><h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">&#123; expression for item in Sequence &#125;</span><br>或<br><span class="hljs-comment">&#123; expression for item in Sequence if conditional &#125;</span><br></code></pre></td></tr></table></figure><h4 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h4><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(expression for item in Sequence )</span><br>或<br><span class="hljs-comment">(expression for item in Sequence if conditional )</span><br></code></pre></td></tr></table></figure><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 ( ) 圆括号将各部分括起来，而列表推导式用的是中括号 [ ]，另外元组推导式返回的结果是一个生成器对象。</p><h3 id="7-面向对象"><a href="#7-面向对象" class="headerlink" title="7. 面向对象"></a>7. 面向对象</h3><p>面向对象的基本特征：</p><ul><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。<code>对象是类的实例</code>。</li><li>方法：类中定义的函数。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h4 id="类的定义和实例化对象"><a href="#类的定义和实例化对象" class="headerlink" title="类的定义和实例化对象"></a>类的定义和实例化对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br>    i = <span class="hljs-number">12345</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-comment"># 实例化类</span><br>x = MyClass()<br> <br><span class="hljs-comment"># 访问类的属性和方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br></code></pre></td></tr></table></figure><p>类有一个名为&#96;&#96; <strong>init</strong>()&#96; 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.data = []<br></code></pre></td></tr></table></figure><p>类的实例化操作会自动调用 <code>__init__()</code> 方法。例如<code>x = MyClass()</code>时，对应的 <code>__init__()</code> 方法就会被调用。</p><ul><li><strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Complex:<br>    <span class="hljs-attribute">def</span> __init__(self, realpart, imagpart):<br>        <span class="hljs-attribute">self</span>.r = realpart<br>        <span class="hljs-attribute">self</span>.i = imagpart<br><span class="hljs-attribute">x</span> = Complex(<span class="hljs-number">3</span>.<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span>(x.r, x.i)   # 输出结果：<span class="hljs-number">3</span>.<span class="hljs-number">0</span> -<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li>self代表类的实例，而非类;类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>派生类的定义：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class DerivedClassName(BaseClassName):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><ul><li>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-title">modname</span>.<span class="hljs-type">BaseClassName</span>):</span><br></code></pre></td></tr></table></figure>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(self,n,a,w)<br>        self.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))<br> <br> <br>s = student(<span class="hljs-string">&#x27;ken&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>s.speak()<br></code></pre></td></tr></table></figure></li></ul><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>定义形式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):</span><br><span class="hljs-class">    &lt;statement-1&gt;</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。<br>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(self,n,a,w)<br>        self.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))<br> <br><span class="hljs-comment">#另一个类，多继承之前的准备</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">speaker</span>():<br>    topic = <span class="hljs-string">&#x27;&#x27;</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,t</span>):<br>        self.name = n<br>        self.topic = t<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))<br> <br><span class="hljs-comment">#多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sample</span>(speaker,student):<br>    a =<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g,t</span>):<br>        student.__init__(self,n,a,w,g)<br>        speaker.__init__(self,n,t)<br> <br>test = sample(<span class="hljs-string">&quot;Tim&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">80</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Python&quot;</span>)<br>test.speak()   <span class="hljs-comment">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span><br></code></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>:        <span class="hljs-comment"># 定义父类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用父类方法&#x27;</span>)<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_">Parent</span>): <span class="hljs-comment"># 定义子类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用子类方法&#x27;</span>)<br> <br>c = <span class="hljs-title class_">Child</span>()          <span class="hljs-comment"># 子类实例</span><br>c.myMethod()         <span class="hljs-comment"># 子类调用重写方法</span><br><span class="hljs-variable language_">super</span>(<span class="hljs-title class_">Child</span>,c).myMethod() <span class="hljs-comment">#用子类对象调用父类已被覆盖的方法</span><br></code></pre></td></tr></table></figure><p>super() 函数是用于调用父类(超类)的一个方法。</p><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p>__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</p><h4 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h4><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。</p><p>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。</p><p>类的私有方法<br><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。</p><p>小结：<br>类的专有方法：</p><ul><li><code>__init__</code>: 构造函数，在生成对象时调用</li><li><code>__del__</code> : 析构函数，释放对象时使用</li><li><code>__repr__ </code>: 打印，转换</li><li><code>__setitem__ </code>: 按照索引赋值</li><li><code>__getitem__</code>: 按照索引获取值</li><li><code>__len__</code>: 获得长度</li><li><code>__cmp__</code>: 比较运算</li><li><code>__call__</code>: 函数调用</li><li><code>__add__</code>: 加运算</li><li><code>__sub__</code>: 减运算</li><li><code>__mul__</code>: 乘运算</li><li><code>__truediv__</code>: 除运算</li><li><code>__mod__</code>: 求余运算</li><li><code>__pow__</code>: 乘方</li></ul><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>可以对类的专有方法进行重载</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#!/usr/bin/python3<br> <br><span class="hljs-keyword">class</span> Vector:<br>   def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>:<br>      self.a = a<br>      self.b = b<br> <br>   def <span class="hljs-constructor">__str__(<span class="hljs-params">self</span>)</span>:<br>      return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b)<br>   <br>   def <span class="hljs-constructor">__add__(<span class="hljs-params">self</span>,<span class="hljs-params">other</span>)</span>:<br>      return <span class="hljs-constructor">Vector(<span class="hljs-params">self</span>.<span class="hljs-params">a</span> + <span class="hljs-params">other</span>.<span class="hljs-params">a</span>, <span class="hljs-params">self</span>.<span class="hljs-params">b</span> + <span class="hljs-params">other</span>.<span class="hljs-params">b</span>)</span><br> <br>v1 = <span class="hljs-constructor">Vector(2,10)</span><br>v2 = <span class="hljs-constructor">Vector(5,-2)</span><br>print (v1 + v2)<br></code></pre></td></tr></table></figure><p>运行结果：<code>Vector(7,8)</code></p><h3 id="8-迭代器和生成器"><a href="#8-迭代器和生成器" class="headerlink" title="8.迭代器和生成器"></a>8.迭代器和生成器</h3><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</p><ul><li><p>迭代器是一个可以记住遍历的位置的对象,从集合的第一个元素开始访问,直到所有的元素被访问完结束,只能往前不会后退。</p></li><li><p>迭代器有两个基本的方法：iter() 和 next()。</p></li><li><p>字符串，列表或元组对象都可用于创建迭代器</p></li></ul><h4 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h4><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span></span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h4 id="常规遍历迭代器"><a href="#常规遍历迭代器" class="headerlink" title="常规遍历迭代器"></a>常规遍历迭代器</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">it</span> = iter(<span class="hljs-built_in">list</span>)     <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-keyword">it</span>:        <span class="hljs-comment"># 使用for遍历</span><br>    print (x, <span class="hljs-keyword">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">import sys          <span class="hljs-comment"># 引入 sys 模块</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)     <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> True:         <span class="hljs-comment"># 使用while循环和next()进行遍历</span><br>    try:<br>        print (<span class="hljs-keyword">next</span>(it))<br>    except StopIteration:<br>        sys.<span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><h4 id="创建一个类作为迭代器"><a href="#创建一个类作为迭代器" class="headerlink" title="创建一个类作为迭代器"></a>创建一个类作为迭代器</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__() </code>与<code> __next__()</code> 。<br><code>__iter__() </code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code> __next__()</code>方法并通过 StopIteration 异常标识迭代的完成。</p><p><code> __next__()</code> 方法会返回下一个迭代器对象。</p><p>示例：创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    x = <span class="hljs-variable language_">self</span>.a<br>    <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br> <br>myclass = <span class="hljs-title class_">MyNumbers</span>()<br>myiter = iter(myclass)<br> <br>print(<span class="hljs-keyword">next</span>(myiter))<br>print(<span class="hljs-keyword">next</span>(myiter))<br></code></pre></td></tr></table></figure><p>结果：<code>1 2</code></p><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>示例:在 20 次迭代后停止执行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.a &lt;= <span class="hljs-number">20</span>:<br>      x = <span class="hljs-variable language_">self</span>.a<br>      <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-symbol">else:</span><br>      <span class="hljs-keyword">raise</span> <span class="hljs-title class_">StopIteration</span><br> <br>myclass = <span class="hljs-title class_">MyNumbers</span>()<br>myiter = iter(myclass)<br> <br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-symbol">myiter:</span><br>  print(x)<br></code></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p><p>生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">yield</span> n<br>        n -= <span class="hljs-number">1</span><br> <br><span class="hljs-comment"># 创建生成器对象</span><br>generator = countdown(<span class="hljs-number">5</span>)<br> <br><span class="hljs-comment"># 通过迭代生成器获取值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 3</span><br> <br><span class="hljs-comment"># 使用 for 循环迭代生成器</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(value)  <span class="hljs-comment"># 输出: 2 1</span><br></code></pre></td></tr></table></figure><p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。</p><h3 id="9-多线程"><a href="#9-多线程" class="headerlink" title="9. 多线程"></a>9. 多线程</h3><h3 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10. 正则表达式"></a>10. 正则表达式</h3><h4 id="正则表达式的概念"><a href="#正则表达式的概念" class="headerlink" title="正则表达式的概念"></a>正则表达式的概念</h4><p><a href="https://www.runoob.com/regexp/regexp-intro.html">https://www.runoob.com/regexp/regexp-intro.html</a></p><h4 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h4><p>典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>例如，你可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><p> <strong>python中正则表达式的实现</strong></p><h4 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h4><p>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none（匹配成功re.match方法返回一个匹配的对象，否则返回None）</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">re.<span class="hljs-keyword">match</span>(<span class="hljs-built_in">pattern</span>, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td></tr></tbody></table><p><strong><a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></strong></p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="hljs-comment"># 在起始位置匹配</span><br><span class="hljs-comment"># span()函数作用：返回匹配值的下标</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;com&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>))         <span class="hljs-comment"># 不在起始位置匹配</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hy">(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>稍微复杂一点的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>line = <span class="hljs-string">&quot;Cats are smarter than dogs&quot;</span><br><span class="hljs-comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span><br><span class="hljs-comment"># (.*?) 表示&quot;非贪婪&quot;模式，只保存第一个匹配到的子串</span><br>matchObj = re.<span class="hljs-keyword">match</span>( <span class="hljs-string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)<br> <br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group() : &quot;</span>, matchObj.group())<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="hljs-number">1</span>))<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;No match!!&quot;</span>)<br></code></pre></td></tr></table></figure><p>实例执行结果:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>() :  Cats are smarter than dogs<br><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>) :  Cats<br><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>) :  smarter<br></code></pre></td></tr></table></figure><p>解释：<br>代码尝试从 line 中匹配一个子串，该子串的规则如下：</p><p>捕获 “are” 前面的内容和 “are” 后面的内容。在正则表达式中，括号用于创建分组，以便后续可以通过 matchObj.group(1) 和 matchObj.group(2) 来获取这两个匹配的内容。</p><p>对于给定的 line &#x3D; “Cats are smarter than dogs” 这个例子：</p><p>“Cats” 匹配 (.<em>)，并保存在分组 1 中。<br>“are” 匹配 “are”。<br>“smarter” 匹配 (.</em>?)，并保存在分组 2 中。<br>所以，最终成功匹配的结果是：</p><p>matchObj.group() : Cats are smarter than dogs：整个匹配的字符串。<br>matchObj.group(1) : Cats：匹配到的第一个分组，即 “are” 前面的内容 “Cats”。<br>matchObj.group(2) : smarter：匹配到的第二个分组，即 “are” 后面的内容 “smarter”。</p><h4 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h4><p>扫描整个字符串并返回第一个成功的匹配</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.search(pattern, string, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><ul><li>re.match与re.search的区别<br>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</li></ul><h4 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.sub(pattern, repl, string, <span class="hljs-attribute">count</span>=0, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul><p>前三个为必选参数，后两个为可选参数。</p><p>repl 参数是一个函数的情况：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">import re<br> <br><span class="hljs-meta"># 将匹配的数字乘以 2</span><br>def <span class="hljs-built_in">double</span>(matched):<br>    value = <span class="hljs-built_in">int</span>(matched.<span class="hljs-keyword">group</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(value * <span class="hljs-number">2</span>)<br> <br>s = <span class="hljs-string">&#x27;A23G4HFD567&#x27;</span><br><span class="hljs-keyword">print</span>(re.sub(<span class="hljs-string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, <span class="hljs-built_in">double</span>, s))<br></code></pre></td></tr></table></figure><h4 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h4><p>用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">re<span class="hljs-selector-class">.compile</span>(pattern<span class="hljs-selector-attr">[, flags]</span>)<br></code></pre></td></tr></table></figure><h4 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h4><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">re<span class="hljs-selector-class">.findall</span>(pattern, string, flags=<span class="hljs-number">0</span>)<br>或<br>pattern<span class="hljs-selector-class">.findall</span>(string<span class="hljs-selector-attr">[, pos[, endpos]</span>])<br></code></pre></td></tr></table></figure><ul><li>pattern 匹配模式。</li><li>string 待匹配的字符串。</li><li>pos 可选参数，指定字符串的起始位置，默认为 0。</li><li>endpos 可选参数，指定字符串的结束位置，默认为字符串的长度<br>示例：</li></ul><ol><li>查找字符串中的所有数字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>result1 = re.findall(<span class="hljs-string">r&#x27;\d+&#x27;</span>,<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br> <br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)   <span class="hljs-comment"># 查找数字</span><br>result2 = pattern.findall(<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br>result3 = pattern.findall(<span class="hljs-string">&#x27;run88oob123google456&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br> <br><span class="hljs-built_in">print</span>(result1)<br><span class="hljs-built_in">print</span>(result2)<br><span class="hljs-built_in">print</span>(result3)<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;123</span>&#x27;, <span class="hljs-symbol">&#x27;456</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;123</span>&#x27;, <span class="hljs-symbol">&#x27;456</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;88</span>&#x27;, <span class="hljs-symbol">&#x27;12</span>&#x27;]<br></code></pre></td></tr></table></figure></li><li>多个匹配模式，返回元组列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>result = re.findall(<span class="hljs-string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="hljs-string">&#x27;set width=20 and height=10&#x27;</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[(<span class="hljs-symbol">&#x27;width</span>&#x27;, <span class="hljs-symbol">&#x27;20</span>&#x27;), (<span class="hljs-symbol">&#x27;height</span>&#x27;, <span class="hljs-symbol">&#x27;10</span>&#x27;)]<br></code></pre></td></tr></table></figure></li></ol><h4 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h4><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.finditer(pattern, string, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><h4 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h4><p>按照能够匹配的子串将字符串分割后返回列表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.split(pattern, string[, <span class="hljs-attribute">maxsplit</span>=0, <span class="hljs-attribute">flags</span>=0])<br></code></pre></td></tr></table></figure><ul><li>maxsplit分割次数，maxsplit&#x3D;1 分割一次，默认为 0，不限制次数。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>)<br>[<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;(\W+)&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="hljs-number">1</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>]<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;a*&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>)   <span class="hljs-comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br>[<span class="hljs-string">&#x27;hello world&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="导入自己写的Python文件作为自定义库"><a href="#导入自己写的Python文件作为自定义库" class="headerlink" title="导入自己写的Python文件作为自定义库"></a>导入自己写的Python文件作为自定义库</h3><p>只需要将需要引用的函数或变量定义在一个.py文件中，然后在其他.py文件中通过import语句导入即可。</p><p>注意，当你导入一个自定义库时，Python会执行该库中的所有顶层代码。这意味着如果在自定义库中有一些不是函数或类定义的代码，它们也将会被执行。因此，最好将不需要立即执行的代码放在条件语句中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># my_custom_library.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_numbers</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>custom_variable = <span class="hljs-string">&quot;This is a custom variable.&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 这里的代码只有在直接运行 my_custom_library.py 文件时才会执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is executed only when running my_custom_library.py directly.&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="import导入一个库"><a href="#import导入一个库" class="headerlink" title="import导入一个库"></a>import导入一个库</h4><ul><li>可以通过库的名称引用库中的类:</li></ul><p>例如，假设有一个名为my_module.py的Python文件，其中定义了一个类MyClass，你可以使用以下方式引用这个类：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># 导入my_module库</span><br><span class="hljs-keyword">import</span> my_module<br><br><span class="hljs-meta"># 创建MyClass的实例</span><br><span class="hljs-title">obj</span> = my_module.<span class="hljs-type">MyClass</span>()<br><br><span class="hljs-meta"># 调用MyClass的方法</span><br><span class="hljs-title">obj</span>.some_method()<br></code></pre></td></tr></table></figure><ul><li>另一种方式是使用from关键字，这样你可以直接使用类名，而不需要使用库名称来引用类：<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># 从my_module库导入<span class="hljs-keyword">MyClass</span>类<br><span class="hljs-keyword">from</span> my_module import <span class="hljs-keyword">MyClass</span><br><br># 创建<span class="hljs-keyword">MyClass</span>的实例<br>obj = <span class="hljs-keyword">MyClass</span>()<br><br># 调用<span class="hljs-keyword">MyClass</span>的方法<br>obj.some_method()<br></code></pre></td></tr></table></figure></li></ul><h3 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h3><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h3 id="使用python进行GUI设计"><a href="#使用python进行GUI设计" class="headerlink" title="使用python进行GUI设计"></a>使用python进行GUI设计</h3><h3 id="使用-Python-语言来编码和解码-JSON-对象"><a href="#使用-Python-语言来编码和解码-JSON-对象" class="headerlink" title="使用 Python 语言来编码和解码 JSON 对象"></a>使用 Python 语言来编码和解码 JSON 对象</h3><h3 id="使用python进行AI绘画"><a href="#使用python进行AI绘画" class="headerlink" title="使用python进行AI绘画"></a>使用python进行AI绘画</h3>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习指南</title>
    <link href="/2023/07/26/Git-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/26/Git-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>常用的Git命令整理</p><span id="more"></span> <h3 id="拷贝仓库"><a href="#拷贝仓库" class="headerlink" title="拷贝仓库"></a>拷贝仓库</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;url</span>&gt; [directory]<br></code></pre></td></tr></table></figure><p>url为git仓库地址，directory为本地目录</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>git branch：列出你在本地的分支</li><li>git branch  branchname：创建分支</li><li>git merge branchname：将任意分支合并到到当前分支中，branchname为需要合并的分支</li><li>git branch -d (branchname)：删除分支</li><li>git log –-oneline：查看简洁的历史记录</li><li>git log –graph ：查看历史中什么时候出现了分支、合并</li><li>git checkout:<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git checkout .              <span class="hljs-comment">#放弃工作区中全部的修改</span><br>git checkout -- filename    <span class="hljs-comment">#放弃工作区中某个文件的修改</span><br><br>git checkout <span class="hljs-keyword">branchname </span>    <span class="hljs-comment">#切换分支</span><br>git checkout -<span class="hljs-keyword">b </span>(<span class="hljs-keyword">branchname)#创建新分支并立即切换到该分支下</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li>git remote：查看当前的远程仓库</li><li>git pull：提取远程仓仓库</li><li>git push：推送到远程仓库</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">head</span>       <span class="hljs-comment">#当前版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>^      <span class="hljs-comment">#回退到上一个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>^^     <span class="hljs-comment">#回退到上上一个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>~<span class="hljs-string">3</span>     <span class="hljs-comment">#回退到往上3个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>~<span class="hljs-string">10</span>    <span class="hljs-comment">#回退到往上10个版本</span><br></code></pre></td></tr></table></figure><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3><ul><li>git config：配置用户名和邮箱地址<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;你的用户名&#x27;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&#x27;你的邮箱&#x27;</span><br></code></pre></td></tr></table></figure></li><li>git status -s：查看相关文件的状态<ul><li>M - 被修改</li><li>A - 被添加</li><li>D - 被删除</li><li>R - 重命名</li><li>?? - 未被跟踪</li></ul></li><li>git add：将文件添加到缓存<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> .       <span class="hljs-comment">#添加所有文件到缓存</span><br><span class="hljs-keyword">it</span> <span class="hljs-built_in">add</span> *.java   <span class="hljs-comment">#添加某一类文件到缓存</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用好GitHub桌面和网页端"><a href="#使用好GitHub桌面和网页端" class="headerlink" title="使用好GitHub桌面和网页端"></a>使用好GitHub桌面和网页端</h3><p>相对复杂的：合并冲突，远程新建&#x2F;删除仓库等操作可以在桌面和网页版完成，更清楚简单。</p><p>更多可以参考：<br><a href="https://blog.csdn.net/qtiao/article/details/97783243">https://blog.csdn.net/qtiao/article/details/97783243</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>some tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openCV学习指南</title>
    <link href="/2023/07/26/openCV%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/26/openCV%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>一些opencv的函数积累，还有传统opencv处理项目的流程整理</p><span id="more"></span> <h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><h3 id="pnp解算"><a href="#pnp解算" class="headerlink" title="pnp解算"></a>pnp解算</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">bool solvePnP(InputArray objectPoints, InputArray imagePoints, <br>               InputArray cameraMatrix, InputArray distCoeffs, <br>               OutputArray rvec, OutputArray tvec, bool <span class="hljs-attribute">useExtrinsicGuess</span>=<span class="hljs-literal">false</span>, <br>               int <span class="hljs-attribute">flags</span>=ITERATIVE )<br></code></pre></td></tr></table></figure><p>函数solvepnp接收一组对应的3D坐标和2D坐标，计算得到两组坐标对应的几何变换（旋转矩阵rvec，平移矩阵tvec）,从而建立相机拍摄2D图像中物体坐标和3D世界坐标系中物体坐标的映射关系。</p><h3 id="重映射"><a href="#重映射" class="headerlink" title="重映射"></a>重映射</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec,<br>                   InputArray cameraMatrix, InputArray distCoeffs, <br>                   OutputArray imagePoints, OutputArray <span class="hljs-attribute">jacobian</span>=noArray(), <br>                   double <span class="hljs-attribute">aspectRatio</span>=0 )                  <br></code></pre></td></tr></table></figure><p>根据所给的3D坐标和已知的几何变换来求解投影后的2D坐标</p><h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><h3 id="同时标定两个摄像头"><a href="#同时标定两个摄像头" class="headerlink" title="同时标定两个摄像头"></a>同时标定两个摄像头</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">double stereoCalibrate(<span class="hljs-title class_">InputArrayOfArrays</span> objectPoints, <span class="hljs-title class_">InputArrayOfArrays</span> imagePoints1,<br>　　　　　　　　　　　　　<span class="hljs-title class_">InputArrayOfArrays</span> imagePoints2, <br>                       <span class="hljs-title class_">InputOutputArray</span> cameraMatrix1,<span class="hljs-title class_">InputOutputArray</span> distCoeffs1, <br>                       <span class="hljs-title class_">InputOutputArray</span> cameraMatrix2, <span class="hljs-title class_">InputOutputArray</span> distCoeffs2, <br>                       <span class="hljs-title class_">Size</span> imageSize,<span class="hljs-title class_">OutputArray</span> R,<span class="hljs-title class_">OutputArray</span> T, <span class="hljs-title class_">OutputArray</span> E, <br>                       <span class="hljs-title class_">OutputArray</span> F,<br>                       <span class="hljs-title class_">TermCriteria</span>  criteria=<span class="hljs-title class_">TermCriteria</span>(<span class="hljs-title class_">TermCriteria</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:COUNT+TermCriteria</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:EPS</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1e-6</span>),<br>                       int flags=<span class="hljs-variable constant_">CALIB_FIX_INTRINSIC</span> )<br></code></pre></td></tr></table></figure><p>能够求出两个摄像头的内外参数矩阵，还能够得出两个摄像头的位置关系R,T</p><h3 id="立体矫正"><a href="#立体矫正" class="headerlink" title="立体矫正"></a>立体矫正</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, <br>                   InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, <br>                   InputArray R, InputArray T,OutputArray R1, OutputArray R2, <br>                   OutputArray P1, OutputArray P2,OutputArray Q, <br>                   int <span class="hljs-attribute">flags</span>=CALIB_ZERO_DISPARITY, double <span class="hljs-attribute">alpha</span>=-1,<br>                   Size <span class="hljs-attribute">newImageSize</span>=Size(), Rect* <span class="hljs-attribute">validPixROI1</span>=0, <br>                   Rect* <span class="hljs-attribute">validPixROI2</span>=0 )<br></code></pre></td></tr></table></figure><p>计算每个摄像机(实际上)的旋转矩阵，从而使两个摄像机图像平面成为同一平面。因此，这使得所有的外极线平行，从而简化了稠密立体对应问题。</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="预处理流程"><a href="#预处理流程" class="headerlink" title="预处理流程"></a>预处理流程</h3><p>常规步骤：</p><ul><li><p>图像颜色空间转换：RGB2HSV</p><ul><li>原因：HSV中的H表示色调，S表示饱和度，V表示亮度。不同颜色在HSV空间有严格的分量范围，从而将颜色进行量化。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mat imgHSV;<br>cvt<span class="hljs-constructor">Color(<span class="hljs-params">imgOriginal</span>, <span class="hljs-params">imgHSV</span>, COLOR_BGR2HSV)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>直方图均衡化(三个通道各自均衡化再组合)</p><ul><li>目的：通过拉伸像素强度分布范围来增强图像对比度，利于后面的二值化处理。</li><li>效果对比：<img src="/images/opencv/p2.png" alt="直方图均衡化效果对比"></li><li>代码：  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">vector&lt;Mat&gt; hsvSplit;<br><span class="hljs-built_in">split</span>(imgHSV, hsvSplit);                    <span class="hljs-comment">//通道分离</span><br><span class="hljs-built_in">equalizeHist</span>(hsvSplit[<span class="hljs-number">2</span>], hsvSplit[<span class="hljs-number">2</span>]);     <span class="hljs-comment">//通道各自均衡化</span><br><span class="hljs-built_in">merge</span>(hsvSplit, imgHSV);                    <span class="hljs-comment">//通道合并</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>阈值处理</p><ul><li>目的：图像进行目标分割，可用于目标检测、图像增强等。</li><li>常用的阈值处理办法：<br>  <code>二值化阈值处理</code>：threshold函数，大于阈值设为最大值，小于就是0。(最简单但是感觉不太好用，轮廓提取不明显。)<br>  <code>自适应阈值处理</code>:根据图像的局部特征，自动确定每个像素点的阈值，能够在不同光照条件下得到更好的效果。(但是不能筛选特定颜色的轮廓目标，可以区分背景和前景)<br>  <code>双阈值化操作</code>：将在两个阈值内的像素值设置为白色（255），而不在阈值区间内的像素值设置为黑色（0），可以用来筛选指定颜色的物体。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mat imgThresholded;<br><span class="hljs-keyword">in</span><span class="hljs-constructor">Range(<span class="hljs-params">imgHSV</span>, LOWERB, UPPERB, <span class="hljs-params">imgThresholded</span>)</span>;    <span class="hljs-comment">//双阈值化操作</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>开闭操作：</p><ul><li>目的：<br>  <code>开运算</code>：先腐蚀后膨胀，用于消除细小物体、在窄区域分离物体、平滑大物体边界。<br>  <code>闭运算</code>：先膨胀后腐蚀，用于填充物体空洞、消除噪声、连接邻近物体、平滑边界。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//得到一个矩形卷积核</span><br>Mat element = get<span class="hljs-constructor">StructuringElement(MORPH_RECT, Size(8, 8)</span>);<br><span class="hljs-comment">//闭操作，填充物体空洞</span><br>morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_CLOSE, <span class="hljs-params">element</span>)</span>;<br>dilate(imgThresholded, imgThresholded, <span class="hljs-number">300</span><span class="hljs-operator"> * </span><span class="hljs-number">300</span>, <span class="hljs-constructor">Point(-1, -1)</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//开操作，去除噪点</span><br>morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_OPEN, <span class="hljs-params">element</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="轮廓修复"><a href="#轮廓修复" class="headerlink" title="轮廓修复"></a>轮廓修复</h3><p>预处理的逻辑比较通用，但是在实际光线和物体呈现角度的因素影响下，预处理得到的轮廓是不太好的，比如圆可能识别出来是个月牙、形状被分割成好几个物体、正方形可能只识别了一个多边形的轮廓，并没有完整的被抠出来等等，这样的预处理效果不足以用于后续的轮廓判断，因此需要进行轮廓修复。</p><ul><li>修复效果图：<img src="/images/opencv/p1.png" alt="轮廓修复"></li></ul><h4 id="凸包检测-多边形填充-闭运算"><a href="#凸包检测-多边形填充-闭运算" class="headerlink" title="凸包检测+多边形填充+闭运算"></a>凸包检测+多边形填充+闭运算</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">Contours(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">contour</span>, <span class="hljs-params">hierarchy</span>, RETR_EXTERNAL, CHAIN_APPROX_TC89_KCOS)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; contour.size<span class="hljs-literal">()</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//凸包检测</span><br>        convex<span class="hljs-constructor">Hull(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">hull</span>, <span class="hljs-params">false</span>, <span class="hljs-params">true</span>)</span>;<br>        <span class="hljs-comment">//凸包填充</span><br>        fill<span class="hljs-constructor">Poly(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">hull</span>, Scalar(255, 255, 255)</span>);<br>        <span class="hljs-comment">//闭操作，填充空洞</span><br>        morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_CLOSE, <span class="hljs-params">element</span>)</span>;<br>        dilate(imgThresholded, imgThresholded, <span class="hljs-number">770</span><span class="hljs-operator"> * </span><span class="hljs-number">770</span>, <span class="hljs-constructor">Point(-1, -1)</span>, <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="轮廓判断"><a href="#轮廓判断" class="headerlink" title="轮廓判断"></a>轮廓判断</h3><p>整体逻辑很简单，使用多边形拟合得到轮廓的边数信息，再与目标形状的边数进行比对判断是否为所求形状。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;vector&lt;Point&gt;&gt; contour;<br>vector&lt;Vec4i&gt; hierarchy;<br>find<span class="hljs-constructor">Contours(<span class="hljs-params">imgPre</span>, <span class="hljs-params">contour</span>, <span class="hljs-params">hierarchy</span>, RETR_EXTERNAL, CHAIN_APPROX_TC89_KCOS)</span>;<br><br>vector&lt;vector&lt;Point&gt;&gt; con<span class="hljs-constructor">Poly(<span class="hljs-params">contour</span>.<span class="hljs-params">size</span>()</span>);<br>vector&lt;Rect&gt; bound<span class="hljs-constructor">Rect(<span class="hljs-params">contour</span>.<span class="hljs-params">size</span>()</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; contour.size<span class="hljs-literal">()</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">string</span> objectType;<span class="hljs-comment">//形状</span><br>    <span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span>;<br>    <span class="hljs-keyword">if</span> (area &lt; <span class="hljs-number">6000</span>)<br>        continue;<br><br>    <span class="hljs-built_in">float</span> peri = arc<span class="hljs-constructor">Length(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">true</span>)</span>;<br>    approx<span class="hljs-constructor">PolyDP(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">conPoly</span>[<span class="hljs-params">i</span>], 0.02 <span class="hljs-operator">*</span> <span class="hljs-params">peri</span>, <span class="hljs-params">true</span>)</span>;<span class="hljs-comment">//光滑曲线折线化</span><br>    boundRect<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = bounding<span class="hljs-constructor">Rect(<span class="hljs-params">conPoly</span>[<span class="hljs-params">i</span>])</span>;<br><br>    <span class="hljs-built_in">int</span> objCor = (<span class="hljs-built_in">int</span>)conPoly<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.size<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (objCor != SHAPE<span class="hljs-operator"> &amp;&amp; </span>SHAPE !=<span class="hljs-number">5</span>) continue;<span class="hljs-comment">//不找圆形的时候，边数非目标</span><br>    <span class="hljs-keyword">if</span> (objCor &lt; SHAPE<span class="hljs-operator"> &amp;&amp; </span>SHAPE<span class="hljs-operator"> == </span><span class="hljs-number">5</span>)continue;<span class="hljs-comment">//找圆形的时候，排除其余形状</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;FIND!!!&quot;</span>&lt;&lt;objCor&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但是现实情况往往更复杂，以下为笔者在轮廓识别的过程中进行的优化：<ul><li><code>圆度检测</code>：<br> 其他图像可能在轮廓修复和开闭操作之后，棱角不明显，接近圆形，从而导致误识别，因此引入圆度检测。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">if</span><span class="hljs-constructor">Circle(<span class="hljs-params">vector</span>&lt;Point&gt;<span class="hljs-params">contour</span>)</span> &#123;<br><span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>)</span>;                    <span class="hljs-comment">//计算轮廓面积</span><br><span class="hljs-built_in">float</span> len = arc<span class="hljs-constructor">Length(<span class="hljs-params">contour</span>, <span class="hljs-params">true</span>)</span>;               <span class="hljs-comment">//计算轮廓周长</span><br><span class="hljs-built_in">float</span> roundness = (<span class="hljs-number">4</span><span class="hljs-operator"> * </span>CV_PI<span class="hljs-operator"> * </span>area)<span class="hljs-operator"> / </span>(len<span class="hljs-operator"> * </span>len); <span class="hljs-comment">//计算圆度</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;未确定圆的圆度：&quot; &lt;&lt; roundness &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (roundness &lt; <span class="hljs-number">0.92</span>) &#123;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;没过检测，圆度：&quot; &lt;&lt; roundness &lt;&lt; endl;</span><br>    return <span class="hljs-literal">false</span>;<br>&#125;<br>return <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>矩形检测</code>：圆形在预处理之后，有概率被误识别为矩形；为更好的区分矩形和圆形，引入矩形检测。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">if</span><span class="hljs-constructor">Rect(<span class="hljs-params">vector</span>&lt;Point&gt;<span class="hljs-params">contour</span>)</span> &#123;<br> <span class="hljs-built_in">float</span> rectangularity;<br> <span class="hljs-comment">//计算最小外接矩形的面积：</span><br> RotatedRect minrect = min<span class="hljs-constructor">AreaRect(<span class="hljs-params">contour</span>)</span>;     <span class="hljs-comment">//最小外接矩形</span><br> <span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>)</span>;                <span class="hljs-comment">//计算轮廓面积</span><br> <span class="hljs-built_in">int</span> Sminrect = minrect.size.height<span class="hljs-operator"> * </span>minrect.size.width;<br> <span class="hljs-keyword">if</span> (Sminrect<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) rectangularity = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">else</span> rectangularity = (<span class="hljs-built_in">float</span>)area<span class="hljs-operator"> / </span>Sminrect;<br> <span class="hljs-comment">// cout &lt;&lt; &quot;矩形度：&quot;&lt;&lt;rectangularity&lt;&lt;&quot;最小外接矩形面积：&quot;&lt;&lt; Sminrect&lt;&lt;&quot;轮廓面积:&quot; &lt;&lt; area &lt;&lt; endl;</span><br> <span class="hljs-keyword">if</span> (rectangularity &lt;<span class="hljs-number">0.86</span>)return <span class="hljs-literal">false</span>;<br> return <span class="hljs-literal">true</span>;<br> &#125;<br><br> *************在轮廓函数中，采用矩形度和圆度双重检测，有效提高矩形的识别精确度****************<br><br> <span class="hljs-keyword">if</span> (objCor<span class="hljs-operator"> == </span><span class="hljs-number">4</span>) &#123;<br>         <span class="hljs-comment">//矩形度检测</span><br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">if</span><span class="hljs-constructor">Circle(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span> ! <span class="hljs-keyword">if</span><span class="hljs-constructor">Rect(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span>) &#123;</span><br><span class="hljs-pattern-match">             cout &lt;&lt; &quot;矩形没过检测！！&quot; &lt;&lt; endl;</span><br><span class="hljs-pattern-match">             continue;</span><br><span class="hljs-pattern-match">         &#125;;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="在图片上进行标记"><a href="#在图片上进行标记" class="headerlink" title="在图片上进行标记"></a>在图片上进行标记</h3><h4 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawContours</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">InputOutputArray image,</span></span><br><span class="hljs-params"><span class="hljs-function">InputArrayOfArrays contours,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> contourIdx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> Scalar&amp; color,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> thickness=<span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> lineType=<span class="hljs-number">8</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">InputArray hierarchy = noArray(),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> maxLevel = INT_MAX,</span></span><br><span class="hljs-params"><span class="hljs-function">Point offset = Point() )</span></span>;<br></code></pre></td></tr></table></figure><h4 id="框出目标物体"><a href="#框出目标物体" class="headerlink" title="框出目标物体"></a>框出目标物体</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> cv::<span class="hljs-variable constant_">rectangle</span> (InputOutputArray img, Point pt1, Point pt2, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Scalar</span> &amp;color, <span class="hljs-keyword">int</span> thickness=<span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> lineType=LINE_8, <span class="hljs-keyword">int</span> shift=<span class="hljs-number">0</span>)<br>***或者****<br><span class="hljs-keyword">void</span> cv::<span class="hljs-variable constant_">rectangle</span> (InputOutputArray img, Rect rec, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Scalar</span> &amp;color, <span class="hljs-keyword">int</span> thickness=<span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> lineType=LINE_8, <span class="hljs-keyword">int</span> shift=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="标注点"><a href="#标注点" class="headerlink" title="标注点"></a>标注点</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//标注矩形顶点</span><br><span class="hljs-built_in">for</span>(int j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>circle(img, conPoly[i][j], <span class="hljs-number">3</span>, Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">120</span>), -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="计算点的坐标"><a href="#计算点的坐标" class="headerlink" title="计算点的坐标"></a>计算点的坐标</h3><h4 id="找圆点"><a href="#找圆点" class="headerlink" title="找圆点"></a>找圆点</h4><ul><li>霍夫检测（我感觉很难调参而且精度不太行）</li><li>最小二乘法拟合圆（没试过，但是据说可以，就是得自己造轮子）</li><li>先识别得到一个圆度大于0.9的圆，再找最小外接矩形，矩形中点即为圆心（有点偷奸耍滑，但是几何上说得通嘿嘿）<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">CircleCenter(Mat <span class="hljs-params">img</span>, Rect <span class="hljs-params">rect</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> x = rect.width<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> y = rect.height<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    Point Radius = <span class="hljs-constructor">Point(<span class="hljs-params">rect</span>.<span class="hljs-params">x</span> + <span class="hljs-params">x</span>, <span class="hljs-params">rect</span>.<span class="hljs-params">y</span> + <span class="hljs-params">y</span>)</span>;<br>    circle(img, Radius, <span class="hljs-number">3</span>, <span class="hljs-constructor">Scalar(0, 255, 120)</span>, -<span class="hljs-number">1</span>);<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="找矩形的四个顶点"><a href="#找矩形的四个顶点" class="headerlink" title="找矩形的四个顶点"></a>找矩形的四个顶点</h4><p>只要通过矩形检测，四边形就是矩形啦。多边形拟合之后的那个conpoly就是矩形的角点点集。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMakeLists 学习指南</title>
    <link href="/2023/07/25/CMakeLists-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/25/CMakeLists-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>CMake是一个元（meta）构建系统，可用于为许多其他构建工具创建构建文件。<br>三天速通！结合UGAS的CMakeLists食用更香捏！</p><span id="more"></span> <h4 id="上交教程："><a href="#上交教程：" class="headerlink" title="上交教程："></a>上交教程：</h4><p><a href="https://sjtu-robomaster-team.github.io/vision-learning-4-cmake-introduction/">https://sjtu-robomaster-team.github.io/vision-learning-4-cmake-introduction/</a></p><h4 id="完整教程："><a href="#完整教程：" class="headerlink" title="完整教程："></a>完整教程：</h4><p><a href="https://zhuanlan.zhihu.com/p/367808125">https://zhuanlan.zhihu.com/p/367808125</a></p><h4 id="核心语法："><a href="#核心语法：" class="headerlink" title="核心语法："></a>核心语法：</h4><p><a href="https://zhuanlan.zhihu.com/p/368701263">https://zhuanlan.zhihu.com/p/368701263</a></p><h2 id="使用Cmake-VScode编译构建C-文件"><a href="#使用Cmake-VScode编译构建C-文件" class="headerlink" title="使用Cmake+VScode编译构建C++文件"></a>使用Cmake+VScode编译构建C++文件</h2><ul><li>编写好CMakeLists.txt</li><li>执行Cmake的confit命令。直接调用命令台工具(<code>Ctrl + Shift + P</code>)，然后选择<code>Cmake Config</code></li><li>点击下面的<code>build</code>按钮,编译成功。<ul><li>所有的编译后的东西自动被vscode的cmake插件放入了build文件夹中，这个文件夹也是cmake插件自动生成的。</li></ul></li><li>运行生成即可run你的工程文件。</li></ul><h3 id="速览：处理多源文件目录的方法"><a href="#速览：处理多源文件目录的方法" class="headerlink" title="速览：处理多源文件目录的方法"></a>速览：<code>处理多源文件目录的方法</code></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><br><span class="hljs-keyword">project</span> (hello_headers)<br><span class="hljs-comment">#设置了项目的名字为 hello_headers</span><br><br><span class="hljs-keyword">set</span>(SOURCES<br>    src/Hello.cpp<br>    src/main.cpp<br>)<br><span class="hljs-comment">#set 指令创建了一个变量，第一个参数为变量名 `SOURCES`，后面的参数就是这个变量所指代的内容</span><br><br><span class="hljs-keyword">add_executable</span>(hello_headers <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><span class="hljs-comment"># $&#123;SOURCES&#125; 使用前面创建的变量来代替要进行编译的文件。</span><br><span class="hljs-comment"># hello_headers 指明了生成可执行文件需要的资源文件</span><br><span class="hljs-comment">#PRIVATE 关键字。</span><br><br><span class="hljs-keyword">target_include_directories</span>(hello_headers<br>    PRIVATE <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><span class="hljs-comment">#添加编译需要用到的头文件,hello_headers指明了需要的头文件的目录</span><br><span class="hljs-comment">#$&#123;PROJECT_SOURCE_DIR&#125;指明include文件所在的文件夹路径。(include文件夹所在的目录。)</span><br></code></pre></td></tr></table></figure><ul><li>关键字有三种，PRIVATE | PUBLIC | INTERFACE，不同的关键字在进行CMake编译后会生成不同的include 文件夹</li><li>在CMake中，变量的使用都是 ${变量名} 这种格式。</li><li>除了README.md文件是用来讲解的文件外，另外几个文件都是要进行编译的。</li><li>${PROJECT_SOURCE_DIR}指当前项目的顶级(上级)源目录,则在编写程序时引用include里面的头文件可以直接写头文件名，不用写相对路径了</li><li>${CMAKE_CXX_FLAGS} C++编译器的编译选项。具体常用选项有：<ul><li><code>-rdynamic</code> 通知链接器将所有符号添加到动态符号表，通过使用 dlopen 来实现向后跟踪</li><li><code>-O3</code> 开启优化</li><li><code>-fPIC</code> 编译器产生与位置无关代码，即产生的代码中全部使用相对地址</li><li><code>-ggdb</code> 编译器生成gdb专用的更为丰富的调试信息</li><li><code>-std=c++11</code></li><li><code>-Wall</code> 编译后显示所有警告<br>  （还有一些不太常用的，网址自查：<a href="https://blog.csdn.net/m0_51551385/article/details/125083575?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=%EF%BC%89">https://blog.csdn.net/m0_51551385/article/details/125083575?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D）</a></li></ul></li></ul><p><code>编译指令：</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> build<br><br><span class="hljs-keyword">cd</span> build<br><br>cmake ..<br><br><span class="hljs-keyword">make</span><br></code></pre></td></tr></table></figure><p>编译完成后，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hello_headers<br></code></pre></td></tr></table></figure><p>就可以运行程序文件。</p><h3 id="高级点的语法："><a href="#高级点的语法：" class="headerlink" title="高级点的语法："></a>高级点的语法：</h3><h4 id="递归搜索所有的-cpp文件并将列表存储在一个变量中"><a href="#递归搜索所有的-cpp文件并将列表存储在一个变量中" class="headerlink" title="递归搜索所有的.cpp文件并将列表存储在一个变量中:"></a>递归搜索所有的.cpp文件并将列表存储在一个变量中:</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">file(GLOB_RECURSE UGAS_SOURCE CONFIGURE_DEPENDS<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/src/</span>*.cpp<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/src/</span>*.cc)<br></code></pre></td></tr></table></figure><ul><li><code>CONFIGURE_DEPENDS</code><br>告知 CMake 有关配置过程的其他输入文件的信息。如果修改了任何命名文件，生成系统将重新运行 CMake 以重新配置文件并再次生成生成系统。<br>将文件指定为以分号分隔的路径列表。</li><li><code>configure_file</code>：通过读取输入文件中的内容，将 CMakeLists.txt 文件中的变量转变为 C&#x2F;C++ 中可识别的宏定义，然后存入输出文件中。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">configure<span class="hljs-constructor">_file(&lt;<span class="hljs-params">input</span>&gt; &lt;<span class="hljs-params">output</span>&gt;)</span><br></code></pre></td></tr></table></figure>具体参考：<a href="https://zhuanlan.zhihu.com/p/436923370">https://zhuanlan.zhihu.com/p/436923370</a></li></ul><p>输入文件为 xxx（目录路径）-config.h.in<br>输出文件为 xxx-config.h</p><h4 id="选项开关："><a href="#选项开关：" class="headerlink" title="选项开关："></a>选项开关：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">option</span><span class="hljs-params">(&lt;OPTION_NAME&gt; <span class="hljs-string">&quot;&lt;help_text&gt;&quot;</span> [value])</span></span><br></code></pre></td></tr></table></figure><p>第一个参数为选项名称。此选项不仅可以是boolean，也可以是string或list。</p><p>第二个参数为选项介绍，为string。</p><p>第三个参数为选项默认值，依据选项类型设置。</p><ul><li>条件分支：<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (CONDITION_1)<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">elseif</span> (CONDITION_2)<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></li></ul><h4 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a><code>find_package</code></h4><p>查找并载入一个外部包</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">find_package(&lt;PackageName&gt; <span class="hljs-comment">[version]</span> <span class="hljs-comment">[EXACT]</span> <span class="hljs-comment">[QUIET]</span> <span class="hljs-comment">[MODULE]</span><br>             <span class="hljs-comment">[REQUIRED]</span> <span class="hljs-comment">[<span class="hljs-comment">[COMPONENTS]</span> <span class="hljs-comment">[components...]</span>]</span><br>             <span class="hljs-comment">[OPTIONAL_COMPONENTS components...]</span><br>             <span class="hljs-comment">[NO_POLICY_SCOPE]</span>)<br></code></pre></td></tr></table></figure><p>最常用用法:<br>find_package(OpenCV 4.7 REQUIRED) <br>find_package(HikCameraSDK REQUIRED)<br>查找名为 XX 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。</p><ul><li>include_directories<br>cmake使用 include_directories是用来 提供搜索头文件路径</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">include_directories (<span class="hljs-selector-attr">[AFTER|BEFORE]</span> <span class="hljs-selector-attr">[SYSTEM]</span> dir1 <span class="hljs-selector-attr">[dir2 ...]</span>)<br></code></pre></td></tr></table></figure><h4 id="在ROS2环境下编译："><a href="#在ROS2环境下编译：" class="headerlink" title="在ROS2环境下编译："></a>在ROS2环境下编译：</h4><ul><li>生成目标文件，并且不需要再使用target_link_libraries  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ament_auto_add_executable</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">ament_auto_add_library</span><br></code></pre></td></tr></table></figure></li><li><code>ament_auto_find_build_dependencies</code><br>  ROS2环境下的链接库方式，相当于不用写find_package了。（ROS之前连接库的指令）</li><li><code>ament_auto_package</code><br>  这个用来代替以前的export（导出库）和两次install（安装库），以及最后的ament_package</li></ul><ul><li><code>link_directories</code><br>链接库；添加需要链接的库文件路径之后就可以使用相对路径，使用TARGET_LINK_LIBRARIES时，只需给出动态链接库名即可。</li><li><code>target_link_libraries </code><ul><li>如果所有目标都使用相关的include目录，则需要使用link_libraries;<br>如果路径是特定于目标，就用target_link_libraries </li><li>如果所有目标都使用相关的include目录，则需要使用link_libraries；<br>如果路径是特定于目标，就用target_link_libraries</li></ul></li></ul><ol start="6"><li><code>DEBUG</code>时使用的命令：</li></ol><ul><li><p>打印变量信息</p><ul><li>SET(USER_KEY, “Hello World”)\</li></ul></li></ul><p>#设置变量</p><ul><li>MESSAGE( STATUS “this var key &#x3D; ${USER_KEY}.”)</li><li>message([<mode>] “message text” …)</mode></li></ul><p>UGAS的CMakeLists.txt参考：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">project</span>(ugas VERSION <span class="hljs-number">1.0</span> LANGUAGES C CXX)<br><br><span class="hljs-comment"># Set compilation flags</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O3&quot;</span>)<br><br><span class="hljs-keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="hljs-keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Clang&quot;</span>)<br>    <span class="hljs-keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cmake)<br><br><span class="hljs-comment"># Set configure_file</span><br><span class="hljs-keyword">set</span> (CONFIGURE_DIR_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/config)<br><span class="hljs-keyword">configure_file</span> (<br>        <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/config.h.in&quot;</span><br>        <span class="hljs-string">&quot;$&#123;CONFIGURE_DIR_PATH&#125;/config.h&quot;</span>)<br><br><span class="hljs-comment"># Initialize custom options</span><br><span class="hljs-keyword">option</span> (ENABLE_DEBUG_CANVAS <span class="hljs-string">&quot;Enable debug canvas to draw debug image&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_RECORDING <span class="hljs-string">&quot;Enable recording of raw camera image&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_OPENVINO <span class="hljs-string">&quot;Enable openvino to identify buff&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_ROS <span class="hljs-string">&quot;Enable ROS to visualize positions&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-comment"># Set the output executable file name:</span><br><span class="hljs-comment"># When compiling in the ROS environment, the output executable file name will be the node name.</span><br><span class="hljs-comment"># Otherwise, the output file name will be the project name.</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_NAME main)<br><span class="hljs-keyword">else</span> ()<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Find non-ros packages</span><br><span class="hljs-keyword">find_package</span>(OpenCV <span class="hljs-number">4.7</span> REQUIRED)<br><span class="hljs-keyword">find_package</span>(HikCameraSDK REQUIRED)<br><br><span class="hljs-keyword">if</span> (ENABLE_OPENVINO)<br>    <span class="hljs-keyword">find_package</span>(OpenVINO REQUIRED)<br>    <span class="hljs-keyword">set</span>(OpenVINO_LIB openvino::runtime)<br><span class="hljs-keyword">endif</span> (ENABLE_OPENVINO)<br><br><span class="hljs-comment"># Include project source directory</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src <span class="hljs-variable">$&#123;CONFIGURE_DIR_PATH&#125;</span>)<br><br><span class="hljs-comment"># Recursively search for all source files under the &#x27;src&#x27; folder and store them into UGAS_SOURCE variable</span><br><span class="hljs-comment"># Flag &#x27;CONFIGURE_DEPENDS&#x27; asks cmake to detect GLOB result changes so no need to rerun cmake when adding a new source file.</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE UGAS_SOURCE CONFIGURE_DEPENDS<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cc)<br><br><span class="hljs-comment"># Find ros packages &amp; add source files to compilation</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    <span class="hljs-keyword">find_package</span> (ament_cmake_auto REQUIRED)<br>    ament_auto_find_build_dependencies ()<br>    ament_auto_add_executable(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;UGAS_SOURCE&#125;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;UGAS_SOURCE&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Link libraries</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span> <span class="hljs-variable">$&#123;HikCameraSDK_LIB&#125;</span> <span class="hljs-variable">$&#123;OpenVINO_LIB&#125;</span> -lpthread)<br><br><span class="hljs-comment"># Install package</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    ament_auto_package()<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="使用ninja构建"><a href="#使用ninja构建" class="headerlink" title="使用ninja构建"></a>使用ninja构建</h3><h4 id="概念——生成器"><a href="#概念——生成器" class="headerlink" title="概念——生成器"></a>概念——生成器</h4><p>CMake生成器负责为底层构建系统编写输入文件(例如Makefile)。<br>运行<code>cmake--help</code>将显示可用的生成器。<br>CMake包括不同类型的生成器，如命令行生成器、IDE生成器和其他生成器。</p><ol><li>命令行生成工具生成器<br>这些生成器用于命令行构建工具，如Make和Ninja。</li><li>IDE构建工具生成器<br>这些生成器用于集成开发环境，其中包括它们自己的编译器。例如Visual Studio和Xcode，它们本身就包含一个编译器。</li><li>其他生成器<br>这些生成器创建配置并与其他IDE工具共同工作，并且必须包含在IDE或命令行生成器中。</li></ol><table><thead><tr><th>Note</th><th>在本例中，ninja是通过命令sudo apt-get install ninja-build安装的。</th></tr></thead></table><h4 id="调用生成器"><a href="#调用生成器" class="headerlink" title="调用生成器"></a>调用生成器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> cmake .. <span class="hljs-literal">-G</span> Ninja<br><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>build.ninja  CMakeCache.txt  CMakeFiles  cmake_install.cmake  rules.ninja<br></code></pre></td></tr></table></figure><p>CMake将生成所需的Ninja构建文件，这些文件可以通过使用Ninja命令运行。</p><h4 id="实例：使用Ninja编译UGAS"><a href="#实例：使用Ninja编译UGAS" class="headerlink" title="实例：使用Ninja编译UGAS"></a>实例：使用Ninja编译UGAS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/ros2_ws/src &amp; <span class="hljs-built_in">cd</span> ~/ros2_ws                   <span class="hljs-comment">#创建工作区文件夹</span><br><span class="hljs-built_in">cp</span> -r ~/Desktop/UGAS ./src/ugas                         <span class="hljs-comment">#拷贝目录</span><br>colcon build --packages-select ugas --cmake-args  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DENABLE_ROS=ON -GNinja<br><span class="hljs-built_in">source</span> ./install/local_setup.bash                       <span class="hljs-comment">#配置该功能包环境</span><br>ros2 run ugas main                                      <span class="hljs-comment">#运行一个节点</span><br></code></pre></td></tr></table></figure><p>tips:</p><ul><li>colcon：使用colcon构建ros包，相当于ros1中的catkin工具</li><li>cp -r Dir&#x2F; &#x2F;home&#x2F;test ：将Dir目录copy到test目录下</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu使用技巧</title>
    <link href="/2023/07/25/Ubuntu%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/07/25/Ubuntu%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>一些使用技巧和操作命令整理合集</p><span id="more"></span> <h3 id="在-Ubuntu-Linux-上安装-Deb-文件的-3-种方法"><a href="#在-Ubuntu-Linux-上安装-Deb-文件的-3-种方法" class="headerlink" title="在 Ubuntu Linux 上安装 Deb 文件的 3 种方法"></a>在 Ubuntu Linux 上安装 <code>Deb</code> 文件的 3 种方法</h3><blockquote><ol><li>使用软件中心安装</li><li>使用命令行安装：</li></ol></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sudo apt install path<span class="hljs-emphasis">_to_deb_file</span><br><span class="hljs-emphasis">或者</span><br><span class="hljs-emphasis">sudo dpkg -i path_to_deb_</span>file<br></code></pre></td></tr></table></figure><p>在这两个命令中，使用已下载的 deb 文件的路径和名称来替换 path_to_deb_file 。</p><h3 id="关于权限和存储"><a href="#关于权限和存储" class="headerlink" title="关于权限和存储"></a>关于权限和存储</h3><p>查看权限：</p><ul><li><code>ls -l filename</code>  <ul><li>可以是文件或者文件夹</li></ul></li></ul><p>修改权限：</p><ul><li><code>chmod o w filename</code><ul><li>授予写的权限</li></ul></li><li><code>chmod go-rw filename</code><ul><li>删除filename组群和其他人的读写权限</li></ul></li><li><code>sudo chmod  -R 777 /var/www</code>  <ul><li>给“&#x2F;var&#x2F;www”这个目录赋予所有人可读可写可执行权限</li></ul></li></ul><p>访问权限：</p><ul><li><p>读取 <code>r</code> ：数字表示 4，允许查看、下载文件内容、显示目录列表；</p></li><li><p>写入 <code>w</code> ：数字表示 2，允许修改文件内容，允许在目录中新建、移动、删除文件或子目录；</p></li><li><p>可执行 <code>x</code> ：数字表示 1，允许运行程序、切换目录。</p></li></ul><p>归属（所有权）</p><ul><li>属主：拥有该文件或目录的用户帐号；</li><li>属组：拥有该文件或目录的组帐号。</li></ul><p>操作对象</p><pre><code class="hljs">u 文件属主权限g 同组用户权限o 其它用户权限a 所有用户（包括以上三种）s（setuid）：该位是让普通用户可以以 root 用户的角色运行只有 root 帐号才能运行的程序或命令</code></pre><p>权限设定</p><pre><code class="hljs">+ 增加权限- 取消权限= 设置权限</code></pre><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><h4 id="相对路径的表现形式"><a href="#相对路径的表现形式" class="headerlink" title="相对路径的表现形式"></a>相对路径的表现形式</h4><ul><li>绝对路径：从 &#x2F; （根目录）为起点的路径。</li><li>相对路径：以当前目录为起点（当前文件所在的路径相对于其它文件或文件夹的路径关系）。</li></ul><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>直接使用目录名或文件名</td><td>表示当前工作目录中的子目录、文件的位置</td></tr><tr><td>.开头</td><td>表示以当前的工作目录作为起点，如 .&#x2F;etc</td></tr><tr><td>..开头</td><td>表示以当前目录的上一级目录（父目录）作为起点，如 ..&#x2F;etc</td></tr><tr><td>以 “~用户名” 形式开头</td><td>表示以指定用户名的宿主目录作为起点</td></tr><tr><td>以 “~” 形式开头</td><td>表示以当前用户的宿主目录作为起点</td></tr></tbody></table><h4 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a><code>cd</code> 命令</h4><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>cd&#x2F;</td><td>切换到系统根目录</td></tr><tr><td>cd~或cd</td><td>切换到当前用户的宿主目录（家目录）</td></tr><tr><td>cd-</td><td>切换到 上一次执行cd命令 之前所在的目录</td></tr></tbody></table><h4 id="ls-命令：用于显示指定工作目录下的文件及子目录"><a href="#ls-命令：用于显示指定工作目录下的文件及子目录" class="headerlink" title="ls 命令：用于显示指定工作目录下的文件及子目录"></a><code>ls</code> 命令：用于显示指定工作目录下的文件及子目录</h4><p>可使用命令 ls –help、man ls 查看所有参数。</p><ul><li><code>ls -a</code> :查看当前目录下的所有文件<br><a href="https://blog.csdn.net/duanbaoke/article/details/115462030">https://blog.csdn.net/duanbaoke/article/details/115462030</a></li></ul><blockquote><p>3.1  通配符:参数可结合通配符一起使用。</p></blockquote><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>？</td><td>代表任意一个字符，只能占一个字符；</td></tr><tr><td>*</td><td>代表任意数个字符，可以是0个或多个；</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任意一个字符，每个通配符只匹配一次，多个通配符可一起使用，不区分大小写。如ls [abc]，ls [a-c]，ls [1ab][1ab]。</td></tr></tbody></table><blockquote><p>3.2 ls-l:查看某一个目录会得到一个7个字段的列表。</p></blockquote><h4 id="alias：设置命令的别名"><a href="#alias：设置命令的别名" class="headerlink" title="alias：设置命令的别名"></a><code>alias</code>：设置命令的别名</h4><p><code>alias [别名]=‘指令名称’ </code>，等于号左右不能有空格，指令名称必须是可执行的完整的命令；</p><p>参数：若不加任何参数，则列出目前所有的别名设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> 命令别名      <span class="hljs-comment">#查看别名</span><br><br><span class="hljs-built_in">unalias</span> 命令别名   <span class="hljs-comment">#取消命令别名</span><br></code></pre></td></tr></table></figure><h4 id="du-选项-文件或目录"><a href="#du-选项-文件或目录" class="headerlink" title="du [选项] [文件或目录...] \"></a><code>du [选项] [文件或目录...] </code>\</h4><p>统计指定目录（或文件）所占用磁盘空间的大小。</p><p>有-a,-s,-h,-c,–math-depth&#x3D;n等选项，要用自己查</p><h4 id="修改权限命令：chmod"><a href="#修改权限命令：chmod" class="headerlink" title="修改权限命令：chmod"></a>修改权限命令：<code>chmod</code></h4><p>命令格式：<code>chmod [ugoa][+-=][rwx]文件或目录 </code>；<br>或用数字表示：<code>chmod [777] </code>文件或目录 ，默认为操作所有用户a；</p><p> 常用格式： <code>-R</code>：递归修改指定目录下所有子项的权限；</p><h4 id="设置目录和文件的默认权限-umask"><a href="#设置目录和文件的默认权限-umask" class="headerlink" title="设置目录和文件的默认权限 umask"></a>设置目录和文件的默认权限 <code>umask</code></h4><p>umask查看：umask<br>umask设置：umask 000，umask 022 #新建目录或者文件，再查看权限</p><p>umask（权限反码） 作用：</p><ul><li>控制新建的文件或者目录的权限默认值</li><li>默认权限去除umask的权限为新建的文件或者目录的权限</li></ul><p>新建的文件或者目录的权限为默认最大权限减去umask权限。<br>umask 默认值为 <code>022</code>，普通文件的最大默认权限.为 <code>666</code>，目录的最大默认权限为 <code>777</code>;</p><h4 id="ln"><a href="#ln" class="headerlink" title="ln - \"></a><code>ln -</code> \</h4><p>为文件或目录创建链接文件，在文件之间建立连接。</p><p>链接文件类型：</p><ul><li>软链接（符号链接）(symbolic link):产生一个特殊的档案，该档案的内容是指向另一个档案的位置</li><li>硬链接(hard link):一个档案可以有多个文件名（一个文件可以有好几个文件名，只有将最后一个文件名从 磁盘上删除，才能把这个文件删掉）</li></ul><p>知识点：<br>参考：<a href="https://blog.csdn.net/duanbaoke/article/details/115485100">https://blog.csdn.net/duanbaoke/article/details/115485100</a></p><ul><li>在Linux中，文件名和文件类型是分开存储的，</li><li>在Linux中，只有文件的<code>硬链接数==0</code> 才会被删除</li><li>使用 ls -l 可以查看一个文件的硬链接数量<br>在日常工作中，几乎不会创建文件的硬链接，只有超级用户才能建立目录的硬连接。</li><li>硬链接是存在同一个档案系统中，而软链接却可以跨越不同的档案系统</li><li>ln- 在文件间产生连接。默认产生硬链接，有-s选项，则产生软链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建硬链接：<span class="hljs-built_in">ln</span> 源文件 目标位置<br><span class="hljs-built_in">ln</span> -s 源文件或目录名... 链接文件或目标位置<br></code></pre></td></tr></table></figure></li></ul><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h4><p>将需要复制的文件或目录（源）重建一份，并保存为新的文件或目录。</p><p><code>cp[选项]...源文件或目录.…目标文件或目录...</code><br>-f,-i,-p,-r四个选项。<br>注：复制多个文件或目录时，目标位置必须是目录，且目标目录必须已存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -p test.rb /home/test <br><span class="hljs-comment">#将test.rb copy到test目录，并且保留原文件的属性</span><br><br><span class="hljs-built_in">cp</span> -p test.rb /home/test/haha.rp  <br><span class="hljs-comment">#将test.rb copy到test目录，并将文件名修改为haha.rp</span><br><br><span class="hljs-built_in">cp</span> -r Dir/ /home/test      <br><span class="hljs-comment">#将Dir目录copy到test目录下</span><br><br><span class="hljs-built_in">cp</span> -fr Dir/* /home/test    <br><span class="hljs-comment">#将Dir下面的所有文件强制copy到test目录下</span><br><br><span class="hljs-built_in">cp</span> /root/&#123;1,2,3&#125;.txt ./    <br><span class="hljs-comment">#批量复制三个同扩展文件到当前目录</span><br><br><span class="hljs-built_in">cp</span> test.rb&#123;,.bak&#125;          <br><span class="hljs-comment">#备份test.rb，并在尾部加上.bak后缀</span><br></code></pre></td></tr></table></figure><h4 id="rm-删除-unlink-文件"><a href="#rm-删除-unlink-文件" class="headerlink" title="rm :删除 (unlink) 文件"></a><code>rm</code> :删除 (unlink) 文件</h4><p>常用选项：-f,-i,-r</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> test.php        <span class="hljs-comment">#删除文件需要确认</span><br><br><span class="hljs-built_in">rm</span> -f test.php     <span class="hljs-comment">#强制删除文件不确认</span><br><br><span class="hljs-built_in">rm</span> -rfv ./test     <span class="hljs-comment">#递归强制删除当前的test目录，并显示删除的详细过程</span><br><br><span class="hljs-built_in">rm</span> -rf aa/         <span class="hljs-comment">#递归强制删除aa目录下的所有</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>删除文件可以直接使用 rm 命令，若删除目录则必须配合选项 “ -r “，因为目录下有 . 和 .. 两个隐藏子目录；</li><li>不要直接删除系统中已有的目录或配置文件，以避免出现意外故障；</li><li>删除目录下文件时建议最好先切换到目录下再执行 rm -rf 命令 <br>（ 1 . cd aa 2 . rm -rf aa&#x2F;）</li></ul><h4 id="mv：-移动文件或目录、对单个文件进行重命名。"><a href="#mv：-移动文件或目录、对单个文件进行重命名。" class="headerlink" title="mv： 移动文件或目录、对单个文件进行重命名。\"></a><code>mv</code>： 移动文件或目录、对单个文件进行重命名。\</h4><p><code>mv [选项] 源文件或目录 目标文件或目录</code></p><ul><li>将指定的文件或目录转移位置；</li><li>如果目标位置与源位置相同，则相当于重命名操作。</li></ul><h4 id="rename-批量修改文件名"><a href="#rename-批量修改文件名" class="headerlink" title="rename:批量修改文件名"></a><code>rename</code>:批量修改文件名</h4><p><code>rename 旧字符 新字符 文件名</code><br><code>rename 旧文件 新文件 目标文件</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">rename</span> <span class="hljs-keyword">abc</span> def <span class="hljs-keyword">abc</span>    # 修改 <span class="hljs-keyword">abc</span> 名字为 dec<br></code></pre></td></tr></table></figure><h4 id="tree：在终端输入下面的指令查看文件结构"><a href="#tree：在终端输入下面的指令查看文件结构" class="headerlink" title="tree：在终端输入下面的指令查看文件结构"></a><code>tree</code>：在终端输入下面的指令查看文件结构</h4><p>安装tree:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> tree<br></code></pre></td></tr></table></figure><h4 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h4><p>这里记录使用zip命令进行压缩和解压文件。</p><p>压缩：</p><ul><li><code>zip filename.zip file</code><ul><li>压缩单个文件；将file压缩为filename.zip，file不能是目录</li></ul></li><li><code>zip -r filename.zip filedir</code><ul><li>压缩目录文件</li></ul></li></ul><p>解压：</p><ul><li><code>unzip filename.zip -d filedir</code><ul><li>将filename.zip解压到filedir目录，如果不指定-d filedir则解压到当前目录</li></ul></li></ul><h3 id="仓库克隆"><a href="#仓库克隆" class="headerlink" title="仓库克隆"></a>仓库克隆</h3><p> linux 系统下 <code>github 仓库的克隆</code>可以直接在终端通过指令克隆。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ttroy50/</span>cmake-examples.git cmake-examples<br></code></pre></td></tr></table></figure><p>第一行是跳转至 home 目录，第二行是将github链接地址的内容克隆到 cmake-example 目录下，输入后会自动新建一个cmake-example 目录并把下载的代码放进去，十分方便。</p><h3 id="linux设置串口别名"><a href="#linux设置串口别名" class="headerlink" title="linux设置串口别名"></a>linux设置串口别名</h3><p><a href="https://blog.csdn.net/beiguodexueCSDN/article/details/103099456">https://blog.csdn.net/beiguodexueCSDN/article/details/103099456</a></p><h3 id="设置免密登录"><a href="#设置免密登录" class="headerlink" title="设置免密登录"></a>设置免密登录</h3><h4 id="方案一-编辑-etc-sudoers-文件"><a href="#方案一-编辑-etc-sudoers-文件" class="headerlink" title="方案一:编辑 /etc/sudoers 文件"></a>方案一:编辑 <code>/etc/sudoers</code> 文件</h4><p>(在香橙派上已成功实现)<br>步骤如下：</p><p>1.打开终端，使用以下命令打开sudoers文件：</p><ul><li><code>sudo visudo</code></li></ul><p>2.在文件中找到以下行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">%sudo   <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>:<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>3.在该行下面添加以下内容：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">yourusername <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) NOPASSWD: <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>4.按下<code>Ctrl + X</code>，输入<code>y</code>保存并退出文件</p><p>5.重启系统，成功!</p><h4 id="方案二：系统设置"><a href="#方案二：系统设置" class="headerlink" title="方案二：系统设置"></a>方案二：系统设置</h4><p>在setting中找到usr，有一个自动登录系统，开启该功能后，重启系统可以自动登录(怎么不算是免密登录呢&#x2F;dog)</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相机标定</title>
    <link href="/2023/07/25/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <url>/2023/07/25/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>几步完成相机标定！（图传也有相机，也可以标定）</p><span id="more"></span> <ul><li>step 1:打印标定板（不能有折痕，要哑光纸打印，A3大小），贴在碳板上，一定要平整。</li><li>step 2:用需要标定的相机拍照，设定好需要的分辨率，拍20-30张不同角度的标定板照片，要求标定板要占大部分相片区域（80%以上）</li><li>step 3:使用matlab进行标定。<br>关于options：<ul><li>(1)Radial Distortion：径向畸变<br> 2 Coefficients选项:使用四次多项式来估计透镜的径向畸变,适用于一般相机<br> 3 Coefficients选项:使用六次多项式来估计透镜的径向畸变,仅适用于大视场相机</li><li>(2)Compute：<br> 关于Skew:假设X轴和Y轴不垂直。这意味着图像像素不是矩形的。所以，Skew选项一般不需要选择<br> 关于Tangential Distortion：当镜头的主轴与相机传感器不垂直时，会发生切向失真<br><code>选择options的要求是使平均误差尽量小，低于0.5为可用</code></li></ul></li><li>step 4：将matlab标定得到的畸变参数写成opencv可用的畸变系数的排列（k<sub>1</sub>,k<sub>2</sub>,p<sub>1</sub>,p<sub>2</sub>,k<sub>3</sub>）,其中三个径向畸变，两个切向畸变<ul><li>RadialDistortion里面的两个参数对应k<sub>1</sub>和k<sub>2</sub>，k<sub>3</sub>为0（对于鱼眼镜头等径向畸变特别大的才需要计算k3）</li><li>TangentialDistortion里面的两个参数对应p<sub>1</sub>,p<sub>2</sub></li><li>记录大疆图传相机数据：<br>  畸变系数：（-0.285400532140372、0.106341621768377、 0、0、   -0.0203255154424868）<br>  内参矩阵:(matlab直接计算得到)<br>$$\begin{matrix}<br>870.536594077599&amp;0&amp;0\<br>0&amp;871.002811118890&amp;0\<br>959.879173875982&amp;554.055610210946&amp;1\<br>\end{matrix}$$<br>需要将上方的内参矩阵转置之后才能给opencv使用：<br>$$\begin{matrix}<br>870.536594077599&amp;0&amp;959.879173875982\<br>0&amp;871.00281111889&amp;554.055610210946\<br>0&amp;0&amp;1\<br>\end{matrix}$$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/2023/07/25/vim/"/>
    <url>/2023/07/25/vim/</url>
    
    <content type="html"><![CDATA[<p>vim共分为3种模式，分别是<code>命令模式</code>、<code>输入模式</code>、<code>底线命令模式</code>。</p><span id="more"></span> <h4 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1. 命令模式"></a>1. 命令模式</h4><p>启动vim，默认进入命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>常用命令：</p><ul><li><code>i</code> 切换到输入模式，以输入字符。</li><li><code>x</code> 删除当前光标所在处的字符。</li><li><code>:</code> 切换到底线命令模式，以在最底一行输入命令。</li></ul><h4 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2. 输入模式"></a>2. 输入模式</h4><p>正常输入即可。<br>按<code>ESC</code>退出输入模式，切换到命令模式。</p><h4 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3. 底线命令模式"></a>3. 底线命令模式</h4><p>在命令模式下按下 <code>:</code>（英文冒号）进入底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，基本命令（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li><li>wq 保存并退出<br>按<code>ESC</code>退出底线命令模式。</li></ul><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h4><p>step1 :在终端输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> runoob.txt<br></code></pre></td></tr></table></figure><p>使用vim建立一个名为 runoob.txt 的文件。<br>直接输入 vim 文件名 就能够进入 vi 的一般模式了。<br><code>记得 vi 后面一定要加文件名，不管该文件存在与否！</code></p><p>step 2:按<code>i</code>进入编辑模式，编辑文件内容</p><p>step 3:按<code>ESC</code>退出编辑模式</p><p>step 4：按<code>:wq</code>保存退出</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>some tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>creat your own blogs</title>
    <link href="/2023/07/25/creat-your-own-blogs/"/>
    <url>/2023/07/25/creat-your-own-blogs/</url>
    
    <content type="html"><![CDATA[<h1 id="通过github创建自己的博客"><a href="#通过github创建自己的博客" class="headerlink" title="通过github创建自己的博客"></a>通过github创建自己的博客</h1><span id="more"></span> <p><a href="https://blog.csdn.net/Dabie_haze/article/details/117407833">创建博客的详细教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/111614119">教程2</a></p><p>补充：</p><ul><li><p><a href="https://blog.csdn.net/yyuggjggg/article/details/120836231#:~:text=1.%E5%8F%8C%E5%87%BB%202%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%203%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%204%EF%BC%9A%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E4%B8%80%E6%AD%A5,5%E7%82%B9%E5%87%BBnext%EF%BC%8C%E5%85%B6%E4%BA%92%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%206.%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%80%E7%9B%B4%E6%98%AF%E2%80%9Cnext%E2%80%9D%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%9C%80%E5%90%8E%E7%82%B9%E5%87%BBfinish%207.%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%208.%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%AD%A3%E5%B8%B8">安装npm的教程</a></p></li><li><p><a href="https://blog.csdn.net/DongShanYuXiao/article/details/129902599">npm使用国内淘宝镜像的方法</a></p></li><li><p><a href="https://blog.csdn.net/qq_36667170/article/details/79094257">获取&#x2F;更新SSH</a></p></li><li><p>Hexo初始化报错：</p></li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">fatal: could not <span class="hljs-keyword">create</span> <span class="hljs-keyword">work</span> tree dir <span class="hljs-string">&#x27;C:\Program Files\Hexo_blog\hexo\ZoeChen04616.github.io&#x27;</span>: Permission denied<br><br></code></pre></td></tr></table></figure><p>是权限不够，不能新建文件夹所以不能建立工作目录。在文件夹属性-安全-user找写入权限添加上就好。</p><ul><li><p>Hexo部署时报错：Error: Spawn failed <br> <a href="https://blog.csdn.net/qq_45020818/article/details/126949337">解决方案</a> </p></li><li><p>关于hexo博客更换主题：<br><a href="https://zhuanlan.zhihu.com/p/385525053">教程</a></p></li><li><p>一些主题推荐：<br><a href="https://zhuanlan.zhihu.com/p/137679728">点这里看看</a> <br><a href="https://hexo.io/themes/">官方的主题库</a></p></li><li><p>hexo常用口令：</p><ul><li><code>hexo clean</code> : 清除缓存</li><li><code>hexo g</code>：生成静态网页</li><li><code>hexo d</code>：同步远程github仓库</li><li><code>hexo s</code>：本地预览效果</li><li><code>hexo new post &quot;article title&quot;</code> ： 新建一篇文章</li></ul></li></ul><h2 id="网页访问量统计"><a href="#网页访问量统计" class="headerlink" title="网页访问量统计"></a>网页访问量统计</h2><p><a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/">看这个教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>some skills about web</tag>
      
      <tag>hexo</tag>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积累向的视觉小知识</title>
    <link href="/2023/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%A7%86%E8%A7%89%E6%95%99%E7%A8%8B/"/>
    <url>/2023/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%A7%86%E8%A7%89%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>没有特定的主题，遇到有啥不会的就往里补充。</p><span id="more"></span> <h4 id="1-O1-O2-O3-Os优化（gcc）"><a href="#1-O1-O2-O3-Os优化（gcc）" class="headerlink" title="1.-O1,-O2,-O3,-Os优化（gcc）"></a>1.-O1,-O2,-O3,-Os优化（gcc）</h4><ol><li><p>使用-Q –help &#x3D;optimizers来获取每个优化标识所启用的优化选项。</p></li><li><p>解释：</p><blockquote><ol><li>-O，-O1：</li></ol></blockquote></li></ol><p>这两个命令的效果是一样的，目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。</p><blockquote><ol start="2"><li>-O2:</li></ol></blockquote><p>该优化选项会牺牲部分编译速度，除了执行-O1所执行的所有优化之外，还会采用几乎所有的目标配置支持的优化算法，用以提高目标代码的运行速度。</p><blockquote><ol start="3"><li>-O3:</li></ol></blockquote><p>该选项除了执行-O2所有的优化选项之外，一般都是采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等。</p><p>这个选项会提高执行代码的大小，当然会降低目标代码的执行时间。</p><blockquote><ol start="4"><li>-Os:</li></ol></blockquote><p>这个优化标识和-O3有异曲同工之妙，当然两者的目标不一样，-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。为了降低目标代码大小，会禁用下列优化选项，一般就是压缩内存中的对齐空白(alignment padding)</p><blockquote><ol start="5"><li>-Ofast:</li></ol></blockquote><p>该选项将不会严格遵循语言标准，除了启用所有的-O3优化选项之外，也会针对某些语言启用部分优化。如：-ffast-math </p><blockquote><ol start="6"><li>-Og:</li></ol></blockquote><p>该标识会精心挑选部分与-g选项不冲突的优化选项，当然就能提供合理的优化水平，同时产生较好的可调试信息和对语言标准的遵循程度。</p><h4 id="2-动态连接库-共享库-和静态连接库"><a href="#2-动态连接库-共享库-和静态连接库" class="headerlink" title="2.动态连接库(共享库)和静态连接库"></a>2.动态连接库(共享库)和静态连接库</h4><p>1.静态链接库 <code>＊.a</code><br>将需要调用的函数统一链接到可执行文件中，成为可执行文件的一部分。</p><ul><li>优点：<br>运行速度快（因为已经链接到可执行文件中了）<br>不需要重新编译代码就可以链接<br>(因为已经和可执行文件链接在一起了，可执行文件调用链接库时可以直接跳转)</li><li>缺点：<br>占用内存，当多个程序调用相同的函数时，内存中就会存在该函数的多个备份</li></ul><p>2.动态链接库 <code>＊.so</code><br>仅加入被调函数的描述信息，当程序执行时由运行链接加载库。<br>仅当被装入内存时，才开始运行。相对于静态链接库，动态链接库只会在内存中保留一份。</p><ul><li>优点：不占用内存；可以实现进程之间的资源共享。<br>（因此动态库也称为共享库） </li><li>缺点：速度比静态的慢</li></ul><h4 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h4><ol><li>定义：在操作系统中用来指定操作系统运行环境的一些参数，要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。<br>用户通过设置环境变量，来更好的运行进程。</li></ol><ul><li>windows系统中的环境变量：PATH<br>可以直接在终端输入echo %PATH%查看系统所有的环境变量</li><li>linux系统中的环境变量： export<br>可以直接在终端输入export查看系统所有的环境变量</li><li>暂时不管CMakeLists里面的环境变量</li></ul><ol start="2"><li>linux中，添加路径到环境变量里面的方法：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">echo <span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;~/.aspera/connect/bin/:<span class="hljs-variable">$PATH</span>&quot;</span> &gt;&gt;.bashrc<br></code></pre></td></tr></table></figure>即，添加到.bashrc的脚本中。（也可以用vim直接编辑.bashrc内容）</li></ol><ul><li><p>.bashrc是一个配置文件，也是一个隐藏文件，存在于用户的家目录~下，需要用<code>ls -a</code>才能查看到，每次登陆bash，这个文件就会被执行一次，在文件内的代码会被运行一遍。<br>参考：<a href="https://cloud.tencent.com/developer/article/1457751">https://cloud.tencent.com/developer/article/1457751</a></p></li><li><p>bash: 终端的那个框</p></li><li><p>echo 输出命令</p></li><li><p><code>&gt;&gt;</code>表示一个类似管道的意思</p></li></ul><h4 id="4-opencv配置环境"><a href="#4-opencv配置环境" class="headerlink" title="4.opencv配置环境"></a>4.opencv配置环境</h4><p>查看UGAS的opencv配置，后面新建项目如果要使用opencv，直接将.props文件复制粘贴到项目文件夹，再在VS里面<code>添加现有属性表</code>即可。</p><h4 id="5-分辨率"><a href="#5-分辨率" class="headerlink" title="5.分辨率"></a>5.分辨率</h4><p>分辨率只是数学上的一个概念，跟任何设备无关。<br>它仅仅是用来表示横向和纵向有多少个像素点而已，可以粗略理解为图片的尺寸以及清晰度。<br>参考：<a href="https://zhuanlan.zhihu.com/p/424498440">https://zhuanlan.zhihu.com/p/424498440</a><br> （分辨率？1080P、2K、4K?英寸？）</p><h4 id="6-image-distorition：图像畸变"><a href="#6-image-distorition：图像畸变" class="headerlink" title="6. image distorition：图像畸变"></a>6. image distorition：图像畸变</h4><h4 id="7-oop-python面向对象编程"><a href="#7-oop-python面向对象编程" class="headerlink" title="7. oop: python面向对象编程"></a>7. oop: python面向对象编程</h4><h4 id="8-markdown怎么写下标：例如k1"><a href="#8-markdown怎么写下标：例如k1" class="headerlink" title="8. markdown怎么写下标：例如k1"></a>8. markdown怎么写下标：例如k<sub>1</sub></h4><h4 id="9-markdown怎么表示矩阵："><a href="#9-markdown怎么表示矩阵：" class="headerlink" title="9.markdown怎么表示矩阵："></a>9.markdown怎么表示矩阵：</h4><p>$$\begin{matrix}<br>0&amp;1&amp;1\<br>1&amp;1&amp;0\<br>1&amp;0&amp;1\<br>\end{matrix}$$</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/25/hello-world/"/>
    <url>/2023/07/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This is my very first post. </p><span id="more"></span> <p>I hope the blogs can record my learning journey, and through my learning journey, I could gradually enrich my little knowledge planet.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
