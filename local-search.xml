<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>摄像头选型</title>
    <link href="/2023/10/19/%E7%9B%B8%E6%9C%BA%E9%80%89%E5%9E%8B/"/>
    <url>/2023/10/19/%E7%9B%B8%E6%9C%BA%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>怎么挑选合适的摄像头呢？</p><p>参考：曾佬的《了解CV和RoboMaster视觉组》</p><span id="more"></span> <p>不同焦距的镜头其视距和视野范围不同，一般来说，<code>视距大（看的远）的镜头，其视野范围小 （可视角小）；而视距短（看的近些）的镜头，视野范围大</code>。</p><p>现在的手机的摄影系统都是由多个镜头组成的，每个镜头的焦距一般不同，从而适应不同焦段和视野的摄影需求。高级的镜头通常可以调节光圈大小，从而改变镜头的进光量。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>比赛中的任务需求催生了对摄像头成像效果的要求。拿RM的各兵种需要的摄像头举例：</p><ul><li>普通步兵：广角镜头（适用近战，可视角广）或是6mm的镜头（中庸选择，兼顾长短）</li><li>打符的步兵：8mm、12mm的长焦镜头，获得更好的远距离成像效果</li><li>哨兵：可能配置两个相机，分别搭载广角镜头和中短焦镜头，广角用于“广撒网”，对敌方目标进行大致定位，之后交由另外一个相机进行精确定位。</li></ul><h3 id="镜头选型工具"><a href="#镜头选型工具" class="headerlink" title="镜头选型工具"></a>镜头选型工具</h3><p><a href="https://www.hikrobotics.com/cn/machinevision/visionproduct?typeId=40&id=247">海康机器人-镜头选型工具</a>:<br>输入参数可以自动计算需要的视场角和靶面尺寸、焦距等，不过它推荐的肯定是自家产品，只需拿着参数自行联系经销商或去tb上找平替款即可。</p><h4 id="像素尺寸"><a href="#像素尺寸" class="headerlink" title="像素尺寸"></a>像素尺寸</h4><p>像素是组成图象的最基本单元要素：点。分辨率是指在长和宽的两个方向上各拥有的像素个数。</p><h3 id="相机畸变"><a href="#相机畸变" class="headerlink" title="相机畸变"></a>相机畸变</h3><p>由于凸透镜本身的性质和镜头制造的工艺问题，光线在通过镜头时无法保持物体在空间中原本的位置关系，成像会发生畸变。通过相机标定来去除这种畸变以便还原图像中物体的真实位置。(之前的博客有更新这个！)</p><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>光圈就是镜头前面可以开闭的小扇叶。（M12镜头一般不可以调节光圈，但板级工业相机一般有一个“auto aperture”的选项，可以根据环境亮度调节“虚拟光圈”，毕竟上面没有机械光圈）。</p><ul><li>不同光圈大小代表不同的镜头开度，影响镜头的进光量。一般用f值刻画光圈的开合程度，<code>f越小说明通光孔的直径越大</code>。</li><li>光圈还和成像的景深有关系，越大的光圈得到的景深越小，即成清晰像的范围越小。</li><li>不可追求景深而将光圈缩得太小。一方面是进光量大大下降（平方反比级），另一方面是光在通过小孔的时候会有强烈的衍射现象，导致像的边缘模糊，边界不够锐利。</li></ul><p>因此，在调大光圈提高进光量的同时，能够成清晰像的距离范围就缩小了。二者需要权衡。也可以通过调节其他参数来提高画面的亮度和可视性：<code>曝光时间、增益、gamma</code>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雷达的一丢丢科普</title>
    <link href="/2023/09/13/%E9%9B%B7%E8%BE%BE%E7%9A%84%E4%B8%80%E4%B8%A2%E4%B8%A2%E7%A7%91%E6%99%AE/"/>
    <url>/2023/09/13/%E9%9B%B7%E8%BE%BE%E7%9A%84%E4%B8%80%E4%B8%A2%E4%B8%A2%E7%A7%91%E6%99%AE/</url>
    
    <content type="html"><![CDATA[<p>雷达是一种使用无线电波来检测物体并测量其距离、速度和方向的系统，被广泛用于航空航天，导航，天气预报和军事领域。</p><span id="more"></span><h2 id="雷达的概念"><a href="#雷达的概念" class="headerlink" title="雷达的概念"></a>雷达的概念</h2><p>雷达是英文”Radar”的音译，意思为无线电探测和测距。即用无线电的方法发现目标，并测定他们的空间位置。因此，雷达也被称为“无线电定位”。</p><center class="half"><img src="/images/雷达/p4.png" width="200/"><img src="/images/雷达/p7.png" width="330/"></center><p>雷达的基本任务是测定有关目标的距离，高度，方向，速度等距离参数。各种雷达的用途和结构不尽相同，但基本原理是一致的；主要由天线，发射机，接收机，信号处理机，显示器等组成。</p><img align="right" src="/images/雷达/p10.png">雷达发射机产生足够的电磁能量，经过收发转换开关传送给天线。天线将这些电磁能量辐射出去，集中在某一个很窄的方向上，形成波束，向前传播。当电磁波遇到波束内的目标后，将沿着各个方向产生发射，其中的一部分电磁能量反射回雷达的方向，被雷达天线获取。天线获取的发射信号经过收发转换开关送到接收机，形成雷达的回波信号。由于雷达的回波信号非常微弱，有时甚至会被噪音所淹没，因此，需要接收机放大微弱的回波信号，经过信号处理机处理，提取出包含在回波中的信息，再送到显示器中。显示器就能显示出目标的距离，方向，速度等各项参数。<h2 id="Radar和Lidar的辨析"><a href="#Radar和Lidar的辨析" class="headerlink" title="Radar和Lidar的辨析"></a>Radar和Lidar的辨析</h2><p>当下智能驾驶和无人机领域十分火热，大家常常听说到的激光雷达（Lidar），其实跟我们今天介绍的雷达不太一样。相较于雷达，全称是<code>radio detection and ranging </code>中文翻译为电磁波的探测和测量；激光雷达的全称是 <code>light detection and ranging</code>，中文翻译为光的探测和测量。</p><p>两者的本质区别在于发射的信号不同。雷达在二战期间开始发展，而激光雷达技术则是在1960年激光器被发明后不久才开始被大规模运用起来。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/p2.png" alt="激光雷达原理图"></p><p>激光雷达的基本原理和雷达相同，但是由于激光光源与无限电波相比具有更高的相干性和准直度，因此在空间中传播时不易发生干涉和衍射等现象，它可以检测物体的形状和位置，构建精确度极高的图像。</p><iframe src="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Uriah%E6%9B%B4%E6%96%B0%E8%A7%86%E9%A2%91/%E5%AE%A4%E5%86%85%E5%90%88%E6%88%90_%E4%BD%8E%E6%AF%94%E7%89%B9%E7%8E%87_for%20webpage_an.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe src="https://terra-1-g.djicdn.com/65c028cd298f4669a7f0e40e50ba1131/Uriah%E6%9B%B4%E6%96%B0%E8%A7%86%E9%A2%91/%E8%A1%8C%E4%BA%BA%E6%A3%80%E6%B5%8B_%E5%AE%A4%E5%A4%96small%20size_composer_an.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>radar和lidar相比有着更长的发展时间和技术成熟度，且更适应恶劣环境；而lidar成本更高，虽然有着更高的精度，但更适用于常规的场景。两者在军事和民用领域都有着各自的优势。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/%E5%AF%B9%E6%AF%94%E9%9B%B7%E8%BE%BE%E5%92%8C%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE.png" alt="对比雷达和激光雷达"></p><h2 id="雷达的发展"><a href="#雷达的发展" class="headerlink" title="雷达的发展"></a>雷达的发展</h2><h3 id="最初的老式雷达"><a href="#最初的老式雷达" class="headerlink" title="最初的老式雷达"></a>最初的老式雷达</h3><p>老式的雷达一般都长这样， 有点像卫星电视的接收器，通过刚才我介绍的雷达基本原理，可以将雷达比作一个手电筒，在未知的周围环境中，通过发送电磁能量，探测目标，就像手电筒一样，指哪哪里就亮。</p><center class="half"><img src="/images/雷达/pp.png" width="365/"><img src="/images/雷达/pop.png" width="300/"></center>老式的雷达有一个可以旋转的脖子，将雷达天线转来转去，以探测不同的方向，至于天线没转到的方向，就是雷达的视野盲区了。<p><img src="/images/%E9%9B%B7%E8%BE%BE/ppp.jfif" alt="雷达的显示屏"><br>传统雷达的显示屏长这样，屏幕上旋转的亮条，就是雷达正探测到的地方，被照到的目标物体会在显示屏中标记出来其对于雷达参考系原点的相对坐标。<br>不过，这个坐标只是目标物体在被探测到的时刻的位置，要想知道目标下一时刻的位置，就得等雷达下一次转过来再次探测到它。这显得非常不灵活，对于目标信息的获取也是滞后的。</p><h3 id="相控阵雷达"><a href="#相控阵雷达" class="headerlink" title="相控阵雷达"></a>相控阵雷达</h3><p>为了解决这个问题，后面就出现了相控阵雷达，顾名思义，就是相位控制电子扫描阵列雷达。它不再像之前的雷达那样将天线转来转去，而是利用雷达面板上的每一个最小探测单元发出电信号的相位差来控制探测方向。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p9.png" alt="相控阵雷达"><br>相控阵雷达可以利用电信号的控制，一秒钟对目标空域扫描成百上千次，还可以一边扫描空域，一边连续跟踪若干个目标。相控阵雷达的显示屏上不再有一根旋转的扫描线，而是整个屏幕都常亮。当今国内外研制的舰载雷达，机载雷达，弹道导航防御雷达以及星载雷达均采用有源相控阵雷达天线。</p><h3 id="现代雷达的技术发展"><a href="#现代雷达的技术发展" class="headerlink" title="现代雷达的技术发展"></a>现代雷达的技术发展</h3><p>雷达起源于二战期间，在二战之后进入高速发展阶段。而现代的雷达，具有五大看家绝活,三大智能技术。<br>其中，五大看家绝活分别是：</p><ul><li>脉冲压缩技术：让雷达看得更远；</li><li>动目标显示：让雷达发现运动的目标；</li><li>恒虚警检测：让雷达更精确的发现目标；</li><li>相控阵点扫：让雷达不需要旋转，看得更快；</li><li>脉冲多普雷技术：解决了机载雷达只能向前看不能向下看的问题，让雷达看得更全面。</li></ul><p>三大智能技术分别是：</p><ul><li>雷达微波成像（SAR）</li><li>目标识别技术（ATR）</li><li>反干扰技术(ECCM)。</li></ul><p>通过字面意思可以看出，它们的作用分别是给目标进行画像、准确识别目标是什么物体以及反干扰技术。大家熟知的“萨德”就是将目标识别技术运用到弹道导弹识别中比较成功的装备。</p><h3 id="中国雷达的发展史"><a href="#中国雷达的发展史" class="headerlink" title="中国雷达的发展史"></a>中国雷达的发展史</h3><p>介绍完雷达，再来介绍一下我们中国的雷达。说到中国雷达，就不得不说到南京的小红楼。</p><p><img src="/images/%E9%9B%B7%E8%BE%BE/p1.png" alt="小红楼"><br>1946年，国民党国防部第六厅在南京征地80亩，建立了“特种电讯器材修理所”，也就是后来被誉为中国雷达工业发源地的“小红楼”。49年建国之后，雷达研究所逐渐发展成为目前的中国电科14所。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p3.png" alt="中国电科"></p><p>从小红楼开始，中国的雷达工业从无到有，从落后到先进，到了今天，中国的雷达已经形成了<code>陆海空天四维一体</code>的装备体系：</p><ul><li><p>陆：陆基雷达作为国土防空的主力装备，守护着我们国土的每一个角落；<br><img src="/images/%E9%9B%B7%E8%BE%BE/p11.png" alt="陆载雷达"></p></li><li><p>海：中国海军拥有全球顶尖的有源相控阵雷达，近年来下水的“辽宁舰”、“山东舰”等举世瞩目的海上“大国重器”，均有舰载有源相控阵雷达的保驾护航。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p12.png" alt="舰载雷达"></p></li><li><p>空：机载火控雷达作为战斗机实施火力攻击的眼睛和向导，决定着战斗机的战斗水平，对取得战斗的胜利至关重要。<br><img src="/images/%E9%9B%B7%E8%BE%BE/p13.png" alt="机载雷达"></p></li><li><p>天：从航天发射场到国内其他测量站点，从陆地到深航远海的测量船；我们的精密测量雷达组成了一个巨大的陆海基航天测控网，在茫茫宇宙中对飞船的发射，运行，回收，实施空中的跟踪接力。使飞船始终置于被探测，追踪和控制之中。<br><img src="/images/%E9%9B%B7%E8%BE%BE/%E6%9C%80%E5%90%8E%E4%B8%80%E5%BC%A0.png" alt="陆海基航天测控网"></p></li></ul><p>简单介绍完中国雷达的发展史，接下来，让我的另外两位朋友具体介绍一下中国雷达在军事上的三种具体的应用类别：陆载雷达、机载雷达、舰载雷达。</p>]]></content>
    
    
    <categories>
      
      <category>长见识了</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科普小知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV配置教程</title>
    <link href="/2023/09/11/OpenCV%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <url>/2023/09/11/OpenCV%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>尊嘟很好用！！</p><span id="more"></span> <p><strong>Step1 下载并安装OpenCV</strong></p><p>访问 <a href="https://opencv.org/releases/">Releases - OpenCV</a> 找到最新版的OpenCV（在最上方且标有*号），点击“Windows”按钮下载。</p><p>下载完成后，将得到的zip文件就地解压，双击里面的distrib.7z.exe，会出现界面Extract to（解压至），如图将下面的文本框中的内容修改为“D:\”，指明OpenCV的安装路径为D盘根目录。</p><p><img src="/images/image/136cf546-0a1f-4c4d-8365-359a4699e60f.png"></p><p><strong>Step2 配置环境变量</strong></p><p>打开 D:\opencv\build\x64 文件夹，内装有命名风格类似“vc**”的文件夹</p><p>按下Windows键，输入env，点击“编辑系统环境变量”</p><p><img src="/images/image/158523ee-7503-4f71-a918-dab6a2062171.png"></p><p>在弹出的对话框中，点击“环境变量(N)”，会弹出一个新对话框，选择“Path”，点击“编辑”</p><p><img src="/images/image/7f6caa9d-3fcd-49a6-b3e7-6c9b1cc72cf4.png"></p><p>如图所示，点击“新建”，把刚才的文件夹按照 D:\opencv\build\x64\vc**\bin 的格式添加进去。</p><p>注意：如果有一个文件夹就添加一项，如果有两个文件夹就添加数字大的那一项，不要遗漏后面的 “\bin”。</p><p><img src="/images/image/be22d535-60a8-4eb1-862d-d0b2c61f5c7b.png"></p><p><strong>Step3 配置openCV.props</strong></p><p>这里要分两种情况讨论，请先打开本文件同目录下的openCV.props文件，在第五行有注释：文件适用于OpenCV *.*.*。</p><p>情况1：该文件与你安装的OpenCV版本一致，那么非常简单，你只需要将文件拷贝到 D:\openCV\openCV.props 处，即可完成配置。</p><p>情况2：该文件与你安装的OpenCV版本不一致（版本过旧），那么你需要对此文件做如下修改。</p><ol><li>将&lt;LibraryPath&gt;中 vc** 的数字改为你刚才添加进环境变量中的那个数字<br><img src="/images/image/ac1d4a74-0807-44d1-a123-3e593f709e06.png"></li><li>打开刚才LibraryPath中的文件夹 D:\opencv\build\x64\vc**\lib，找到里面命名风格类似opencv_world***.lib的文件，把&lt;AdditionalDependencies&gt;中opencv_world***.lib的数字改为这个文件的数字（注意不要有d）。<br><img src="/images/image/5ca41cc8-22f5-4580-9063-abc30d9dce88.png"></li><li>保存修改，把文件拷贝到 D:\openCV\openCV.props 处，完成配置。</li></ol><p>完成后的opencv目录如图所示。</p><p><img src="/images/image/83d0fbf8-9431-4c3d-a1e8-b34dfea2af35.png"></p><p><strong>Step4 重启电脑</strong></p><p>修改环境变量后，一般要重启才能生效，请重启你的电脑。</p><p><strong>Step5 在vs项目中引用openCV.props属性文件</strong></p><p>每次新建项目之后，只需要将属性表放到项目路径下，并添加到项目中就可以使用了。</p><p><code>添加属性表</code>：先把属性表复制、粘贴到当前项目的项目文件夹中，然后打开“属性管理器”，找到对应的“模式”和“位数”，例如“Debug|x64”，然后点击鼠标右键选择“添加现有属性表”，把复制、粘贴好的属性表文件添加进来即可。</p><br>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模绘图学习笔记</title>
    <link href="/2023/09/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%98%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%98%E5%9B%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>常用的数学建模绘图的方法整理</p><span id="more"></span> <h2 id="权重图、热力图、三维地图"><a href="#权重图、热力图、三维地图" class="headerlink" title="权重图、热力图、三维地图"></a>权重图、热力图、三维地图</h2><p>表示相关位置的重要程度。</p><h3 id="权重图"><a href="#权重图" class="headerlink" title="权重图"></a>权重图</h3><p>一般用excel的色阶工具，加上PPT的修饰。</p><ul><li>excel列出表格数据，色阶着色</li><li>复制到PPT，选择原格式粘贴</li><li>使用PPT的布局调整宽度和长度，以及数据的对齐方式</li><li>使用PPT的表设计，可以加边框（设置颜色和粗细，选定数据加边框）<ul><li>表设计里面的底纹，可以选<code>渐变</code>等样式</li></ul></li></ul><p><img src="/images/MathematicsModeling/p1.png" alt="色阶图"></p><h3 id="热力图和三维地图"><a href="#热力图和三维地图" class="headerlink" title="热力图和三维地图"></a>热力图和三维地图</h3><ol><li>使用python：</li></ol><ul><li><p>普通热力图和平滑彩虹热力图：<a href="https://zhuanlan.zhihu.com/p/567780409">https://zhuanlan.zhihu.com/p/567780409</a></p></li><li><p>地图类：使用python包folium：<a href="https://www.zhihu.com/question/33783546">https://www.zhihu.com/question/33783546</a></p><ul><li>使用 jupyterlab 进行演示，安装和配置教程见：<a href="https://blog.csdn.net/weixin_37641832/article/details/94437445">https://blog.csdn.net/weixin_37641832/article/details/94437445</a></li></ul><p>  补充说明：<br>  (1) 打开jupyter：<br>  在cmd里输入<br>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">jupyter</span> lab --<span class="hljs-literal">no</span>-browser<br></code></pre></td></tr></table></figure><br>  会得到一个URL，在浏览器中打开即可。\</p></li></ul><p>(2) 关闭：先关闭网页，再在cmd中输入Ctrl+C退出。</p><p>更新：使用PyCharm一样可以直接得到地图，但是需要保存为本地heml文件。详细教程参考：<a href="https://cloud.tencent.com/developer/article/2165996/">https://cloud.tencent.com/developer/article/2165996\</a><br>（我更喜欢PyCharm这个IDE，所以使用的是这个教程，不过大概操作都差不多;里面还有一个实战案例）</p><ul><li>python读取数据的方法:<a href="https://zhuanlan.zhihu.com/p/138965952">https://zhuanlan.zhihu.com/p/138965952</a></li></ul><ol start="2"><li>使用excel制作：</li></ol><p><img src="/images/MathematicsModeling/p2.png" alt="热力图"></p><ul><li><p>选中excel表格数据，选择“三维地图”，默认场景为地球，可“<code>选择新场景--新建自定义地图--浏览背景图片</code>”。在图层1中选择位置x,y对应x,y坐标，数据会自动调整最值和缩放比例。选择<code>热力图</code>形式，在<code>图层选项</code>里面调整色阶和影响半径。最后点击<code>捕获屏幕</code>就可以导出最后的图像。</p></li><li><p>选中excel表格数据，选择“三维地图”，默认场景为地球，可以选择<code>平面地图</code>把它展平。</p></li></ul><p><img src="/images/MathematicsModeling/p3.png" alt="三维地图"></p><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>matlab,python,office都可以制作散点图。</p><p><img src="/images/MathematicsModeling/p4.png" alt="散点图"></p><ol><li>office制作散点图：难度低，但是需要做的生动形象，就需要一些技巧了。</li></ol><ul><li>更换散点为小球啥的，看起来新颖一点:<br>选择散点图里面的散点-设置数据系列格式-选择标记-标记选项-把大小调成合适的小球的大小-在网上找到小球的图片，复制到剪贴板-在填充选择图片或纹理填充-剪贴板-在边框可以设置<code>无线条</code></li><li>更换背景使之更符合问题背景:<br>在<code>设置绘图区格式</code>里面-选择填充-图片或纹理填充-插入图片</li><li>补充的一些office制作图表技巧:<ul><li>切换x,y轴: 自己百度去。</li><li>调整坐标轴的范围使数据点分布均匀一点：<br>  在<code>设置图标区格式</code>里的图表选项-选择垂直轴选项-坐标轴选项-设置边界</li><li>坐标轴可以设置刻度线啥的，好看一点的话就是<code>主刻度线交叉</code>，<code>次刻度线内部</code></li><li>PPT里面不同形状可以组合图形，互补互切啥的。</li></ul></li></ul><h2 id="着色图表"><a href="#着色图表" class="headerlink" title="着色图表"></a>着色图表</h2><p><img src="/images/MathematicsModeling/p5.png" alt="着色图表"></p><p>使用方法：Matlab or Excel +PPT</p><h3 id="普通折线图、线性拟合图——点实线透明，色彩对比鲜明"><a href="#普通折线图、线性拟合图——点实线透明，色彩对比鲜明" class="headerlink" title="普通折线图、线性拟合图——点实线透明，色彩对比鲜明"></a>普通折线图、线性拟合图——点实线透明，色彩对比鲜明</h3><p>推荐把点的颜色设置得比较深，把线的颜色设的稍浅，显得更有层次感。<br>不同线之间颜色选择：</p><ul><li>对比色</li><li>同色系的不同色调（一大段有多张相似图表，每张图选择一个色系）</li><li>matlab&#x2F;excel就可以实现。</li></ul><h3 id="面积图——实际上就是在一块面积内填渐变色"><a href="#面积图——实际上就是在一块面积内填渐变色" class="headerlink" title="面积图——实际上就是在一块面积内填渐变色"></a>面积图——实际上就是在一块面积内填渐变色</h3><ol><li>利用office自带的面积图叠一层：</li></ol><ul><li>优点：简单方便，只要把数据复制一遍选择<code>面积图</code>即可。</li><li>缺点：office的曲线图带有平滑拟合，而面积图无平滑拟合，所以会有留白。</li></ul><ol start="2"><li>使用PS处理 (自己百度去)</li></ol><p>注意：不要滥用渐变色、透明度、阴影、虚线、发光，色彩搭配要注意不能显得太廉价。</p><h2 id="突出对比的智能图表（雷达图，漏斗图，条形图）"><a href="#突出对比的智能图表（雷达图，漏斗图，条形图）" class="headerlink" title="突出对比的智能图表（雷达图，漏斗图，条形图）"></a>突出对比的智能图表（雷达图，漏斗图，条形图）</h2><p>office自带了丰富的图表类型！！！</p><h3 id="利用插件制作图表"><a href="#利用插件制作图表" class="headerlink" title="利用插件制作图表"></a>利用插件制作图表</h3><p>常用的插件：</p><ul><li><code>iSlide插件</code><br>设计排版中的<code>矩阵布局</code>，<code>环形布局</code>很好用；有丰富的案例库，主题库，图示库，智能图表，图标库……</li><li>口袋动画PA插件：主要是做动画的，其中的<code>矢量工具</code>很好用</li></ul><h2 id="流程图-层次图"><a href="#流程图-层次图" class="headerlink" title="流程图&amp;层次图"></a>流程图&amp;层次图</h2><p><img src="/images/MathematicsModeling/p7.png" alt="流程图"></p><p><img src="/images/MathematicsModeling/p6.png" alt="流程图"></p><h2 id="三维立体图-PPT就可以制作"><a href="#三维立体图-PPT就可以制作" class="headerlink" title="三维立体图(PPT就可以制作)"></a>三维立体图(PPT就可以制作)</h2><ol><li>图标素材的来源：</li></ol><ul><li>阿里巴巴</li><li>Office自带图标</li><li>iSlide插件的图标库</li></ul><ol start="2"><li>三维绘图的关键点：形状效果的棱台和三维旋转</li></ol><ul><li>棱台注意调节深度、光线、材质等。（调节凭感觉）</li><li>各种材质的小球可以使用棱台效果调节宽度得到</li><li>图标库里面的二维小人，可以添加棱台效果使之变得立体一点</li><li>三维旋转XYZ轴的调节是玄学……</li></ul><p><img src="/images/MathematicsModeling/p8.png" alt="三维立体图1"></p><p><img src="/images/MathematicsModeling/p9.png" alt="三维立体图2"></p><h2 id="铅笔画、素描画"><a href="#铅笔画、素描画" class="headerlink" title="铅笔画、素描画"></a>铅笔画、素描画</h2><p>使用工具：PPT里面的艺术效果：<br>选中图片——菜单栏的图片格式——调整工具栏的艺术效果——艺术效果选项——微调一下：透明度、压力、铅笔大小</p>]]></content>
    
    
    <categories>
      
      <category>建模技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建模绘图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 学习指南</title>
    <link href="/2023/08/03/MySQL-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/08/03/MySQL-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>MySQL是一种关系型数据库管理系统，被广泛用于存储和管理结构化数据。它是开源的，免费使用，并且支持多种操作系统。</p><p>以下是一些MySQL的基本概念：</p><ul><li><p>数据库和表格</p><ul><li>数据库：MySQL可以管理多个数据库，每个数据库是一个独立的数据存储单元。</li><li>表格：数据库由多个表格组成，每个表格是一个二维数据结构，用于存储数据。</li></ul></li><li><p>基本数据类型<br>MySQL支持多种数据类型,<br>常用的数据类型有：</p><ul><li>INT：整数类型</li><li>VARCHAR：可变长度字符串类型</li><li>DATE：日期类型</li><li>FLOAT：浮点数类型</li></ul></li><li><p>SQL语句<br>SQL（Structured Query Language）是用于与数据库进行交互的语言。通过SQL语句可以完成各种操作:</p><ul><li>查询数据：使用SELECT语句来检索数据。</li><li>插入数据：使用INSERT INTO语句将数据插入表格。</li><li>更新数据：使用UPDATE语句更新表格中的数据。</li><li>删除数据：使用DELETE FROM语句删除表格中的数据。</li></ul></li><li><p>数据库连接<br>连接数据库是在Python或其他编程语言中与MySQL进行交互的第一步。连接器库（如mysql-connector-python或pymysql）提供了与数据库建立连接的功能。</p></li></ul><p>一旦建立了数据库连接，你可以通过执行SQL语句来读取、写入和修改数据库中的数据。</p><h2 id="安装MySQL教程"><a href="#安装MySQL教程" class="headerlink" title="安装MySQL教程"></a>安装MySQL教程</h2><p><a href="https://blog.csdn.net/m0_52559040/article/details/121843945">https://blog.csdn.net/m0_52559040/article/details/121843945</a></p><h2 id="常用cmd命令"><a href="#常用cmd命令" class="headerlink" title="常用cmd命令"></a>常用cmd命令</h2><ul><li><code>mysql -uroot -p</code>  : 启动数据库<ul><li>最初，都是使用 root 用户登录，工作中如果一直用 root 用户登录，因为权限太大，风险是很大的，所以等创建好权限适合的用户后，就不要经常登录 root 用户了。</li></ul></li><li><code>\h</code> ：查看命令行说明</li><li><code>\c</code> ：clear the current input statement</li><li><code>\G</code> : send commend to mysql server, display result vertically</li><li><code>\p</code> : print current command</li><li><code>\q</code> : Quit Mysql</li><li><code>\s</code> : get status information from the server<br>更多命令输入<code>\h</code>查看</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查看当前的数据库"><a href="#查看当前的数据库" class="headerlink" title="查看当前的数据库"></a>查看当前的数据库</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">show databases<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_one;<br></code></pre></td></tr></table></figure><ul><li>创建数据库时设置字符编码:<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_three charset utf8;<br></code></pre></td></tr></table></figure>通常我们会在数据库中存放中文数据，所以最好把数据库的编码方式设置成 utf-8 ，这样中文才能正常显示。</li><li>查看和显示数据库的编码方式<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_one;<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> MyDB_two;<br></code></pre></td></tr></table></figure></li><li>修改数据库编码<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> MyDB_one <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8;<br></code></pre></td></tr></table></figure></li></ul><h3 id="进入或切换数据库"><a href="#进入或切换数据库" class="headerlink" title="进入或切换数据库"></a>进入或切换数据库</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> MyDB_one<br><span class="hljs-keyword">use</span> MyDB_two;<br></code></pre></td></tr></table></figure><p>刚连接上 MySQL 时，没有处于任何一个数据库中，如果要使用某一个数据库，就需要进入到这个数据库中。</p><p><code>use 数据库名</code> 这个命令后面的分号可以省略，这是 SQL 语句中唯一可以省略分号的语句。</p><ul><li>显示当前数据库：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">database</span>()</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><h4 id="查看当前数据库中的表"><a href="#查看当前数据库中的表" class="headerlink" title="查看当前数据库中的表"></a>查看当前数据库中的表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br></code></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Phone_table(pid <span class="hljs-type">INT</span>, <span class="hljs-type">name</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>), price <span class="hljs-type">INT</span>);<br></code></pre></td></tr></table></figure><h4 id="显示表信息"><a href="#显示表信息" class="headerlink" title="显示表信息"></a>显示表信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Phone_table;<br></code></pre></td></tr></table></figure><h4 id="给表增加字段"><a href="#给表增加字段" class="headerlink" title="给表增加字段"></a>给表增加字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> Phone_table <span class="hljs-keyword">add</span> color <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><h4 id="删除表的字段"><a href="#删除表的字段" class="headerlink" title="删除表的字段"></a>删除表的字段</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> Phone_table <span class="hljs-keyword">drop</span> price;<br></code></pre></td></tr></table></figure><p>更多操作参考：<a href="https://zhuanlan.zhihu.com/p/370510336">https://zhuanlan.zhihu.com/p/370510336</a></p><h1 id="import-pymysql-操作MySQL数据库"><a href="#import-pymysql-操作MySQL数据库" class="headerlink" title="import pymysql 操作MySQL数据库"></a>import pymysql 操作MySQL数据库</h1><ul><li><code>pip install pymysql</code> 安装pymysql库</li><li>在python脚本中导入库：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pymysql<br></code></pre></td></tr></table></figure></li><li>建立数据库连接<br>使用<code>pymysql.connect( )</code>函数来建立与MySQL数据库的连接。提供MySQL服务器的主机名、用户名、密码和数据库名称等信息。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 建立数据库连接</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">connection </span>= pymysql.connect(<br>    <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attribute">user</span>=<span class="hljs-string">&#x27;your_username&#x27;</span>,<br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;your_password&#x27;</span>,<br>    <span class="hljs-attribute">database</span>=<span class="hljs-string">&#x27;your_database_name&#x27;</span><br>)<br></code></pre></td></tr></table></figure></li><li>创建游标对象<br>在连接上创建游标对象，用于执行SQL查询和获取结果。<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cursor</span> = <span class="hljs-keyword">connection</span>.<span class="hljs-keyword">cursor</span>()<br></code></pre></td></tr></table></figure></li><li>执行SQL查询<ul><li>查询数据  <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment"># 查询数据</span><br>query = <span class="hljs-string">&quot;SELECT * FROM your_table_name;&quot;</span><br>cursor.execute(query)<br><br><span class="hljs-comment"># 获取所有结果</span><br>results = cursor.fetchall()<br><br><span class="hljs-comment"># 遍历结果并打印</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">row</span> <span class="hljs-keyword">in</span> results:<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">row</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li>插入数据  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 插入数据</span><br>query = <span class="hljs-string">&quot;INSERT INTO your_table_name (column1, column2, column3) VALUES (%s, %s, %s);&quot;</span><br>data = (<span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>)<br>cursor.execute(query, data)<br><br><span class="hljs-comment"># 提交更改</span><br>connection.commit()<br></code></pre></td></tr></table></figure>使用游标对象cur执行了一个INSERT语句，向名为<code>your_table_name</code>的表格中插入一条数据。</li></ul><p>INSERT语句中的参数使用占位符%s表示。这样做可以防止SQL注入攻击。<code>cur.execute()</code>方法将会将后面提供的参数值安全地插入到SQL语句中。</p><p>调用了<code>conn.commit()</code>来提交更改，将数据插入到数据库中。如果没有调用commit()方法，数据库将不会保存插入的数据。</p><ul><li>关闭连接<br>在完成所有数据库操作后，关闭游标和连接。  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cursor</span>.<span class="hljs-keyword">close</span>()<br><span class="hljs-keyword">connection</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure></li></ul><h2 id="样例源码：更新库中用户数据"><a href="#样例源码：更新库中用户数据" class="headerlink" title="样例源码：更新库中用户数据"></a>样例源码：更新库中用户数据</h2><p>假设你有一个名为users的表格，包含id、name和age三列。现在，你想根据id来更新某个用户的信息。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> pymysql<br><br>def update_user_by_id(user_id, <span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>):<span class="hljs-type"></span><br>    <span class="hljs-meta"># 建立数据库连接</span><br>    connection = pymysql.connect(<br>        host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        user=<span class="hljs-string">&#x27;your_username&#x27;</span>,<br>        password=<span class="hljs-string">&#x27;your_password&#x27;</span>,<br>        database=<span class="hljs-string">&#x27;your_database_name&#x27;</span><br>    )<br><br>    <span class="hljs-keyword">try</span>:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 创建游标对象</span><br>        cursor = connection.cursor()<br><br>        <span class="hljs-meta"># 执行UPDATE操作</span><br>        query = <span class="hljs-string">&quot;UPDATE users SET name=%s, age=%s WHERE id=%s;&quot;</span><br>        data = (<span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>, user_id)<br>        cursor.execute(query, data)<br><br>        <span class="hljs-meta"># 提交更改</span><br>        connection.commit()<br><br>        print(<span class="hljs-string">&quot;User information updated successfully!&quot;</span>)<br>    except Exception as e:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 如果出现错误，回滚更改</span><br>        connection.rollback()<br>        print(f<span class="hljs-string">&quot;Error: &#123;str(e)&#125;&quot;</span>)<br>    finally:<span class="hljs-type"></span><br>        <span class="hljs-meta"># 关闭游标和连接</span><br>        cursor.close()<br>        connection.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<span class="hljs-type"></span><br>    <span class="hljs-meta"># 要更新的用户信息</span><br>    user_id = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">new</span><span class="hljs-type">_name</span> = <span class="hljs-string">&quot;Alice Smith&quot;</span><br>    <span class="hljs-keyword">new</span><span class="hljs-type">_age</span> = <span class="hljs-number">32</span><br><br>    update_user_by_id(user_id, <span class="hljs-keyword">new</span><span class="hljs-type">_name</span>, <span class="hljs-keyword">new</span><span class="hljs-type">_age</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS学习指南</title>
    <link href="/2023/07/31/CSS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/31/CSS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS-（层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述"><a href="#CSS-（层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述" class="headerlink" title="CSS （层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。概述"></a>CSS （层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。<br><span id="more"></span><br>概述</h2><p>CSS 与 HTML 和 JavaScript 并称 Web 三大核心技术。一般用它来定义 HTML 元素 的样式，但它也能用于其他标记语言，如 SVG 和 XML。</p><p>浏览器会根据 CSS 的样式定义将其选定的元素显示为恰当的形式。一条 CSS 的样式定义包括属性和属性值，它们共同决定网页的外观。</p><p>一条 CSS 规则包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_Selector">选择符</a> 和一组 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Property/CSS">属性 （en-US）</a> 定义。下面这个例子用来将页面中的所有标签显示为黑色背景和黄色文本：<code>&lt;p&gt;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* p 选择符用来选择页面中的所有 &lt;p&gt; 标签 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-comment">/* color 属性用来定义文本颜色，这里为黄色 */</span><br>  <span class="hljs-attribute">color</span>: yellow;<br><br>  <span class="hljs-comment">/* background-color 属性用来定义元素的背景色，这里为黑色 */</span><br>  <span class="hljs-attribute">background-color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>CSS 中的“C”表示“层叠的”，意为<code>多个选择符之间具有特定的优先级</code>。这一点非常重要，因为复杂网站可能会有非常多的 CSS 规则，因此必须规定好这些规则的优先级，以免乱套。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python项目1_爬虫学习指南</title>
    <link href="/2023/07/31/python%E9%A1%B9%E7%9B%AE1-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/31/python%E9%A1%B9%E7%9B%AE1-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>记录python项目1–爬虫的学习过程</p><span id="more"></span><h1 id="基础步骤"><a href="#基础步骤" class="headerlink" title="基础步骤"></a>基础步骤</h1><h2 id="step1-安装requests库和BeautifulSoup库"><a href="#step1-安装requests库和BeautifulSoup库" class="headerlink" title="step1 :安装requests库和BeautifulSoup库"></a>step1 :安装requests库和BeautifulSoup库</h2><p>在pycharm的设置上找到项目解释器，查询插件安装。</p><p>可能出现报错：安装版本与python版本不一致，安装最新的即可。</p><p>在书写爬虫程序的开头引入两个模块：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> requests<br><span class="hljs-title">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br></code></pre></td></tr></table></figure><h2 id="step-2：获取爬虫所需的header和cookie"><a href="#step-2：获取爬虫所需的header和cookie" class="headerlink" title="step 2：获取爬虫所需的header和cookie"></a>step 2：获取爬虫所需的header和cookie</h2><p>获取header和cookie是一个爬虫程序必须的，它直接决定了爬虫程序能不能准确的找到网页位置进行爬取。</p><p>首先进入想要爬取的网页页面，按下F12，就会出现网页的js语言设计部分。</p><p>找到网页上的Network部分。然后按下ctrl+R刷新页面。如果，进行就有文件信息，就不用刷新了，当然刷新了也没啥问题。</p><p>然后，浏览Name部分，找到我们想要爬取的文件，鼠标右键，选择copy，复制下网页的URL。</p><h2 id="step-3-获取网页"><a href="#step-3-获取网页" class="headerlink" title="step 3: 获取网页"></a>step 3: 获取网页</h2><p>使用request请求</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://tophub.today/n/KqndgxeLl9&#x27;</span>, <span class="hljs-attribute">cookies</span>=cookies, <span class="hljs-attribute">headers</span>=headers)<br></code></pre></td></tr></table></figure><h3 id="requests-get-url-函数"><a href="#requests-get-url-函数" class="headerlink" title="requests.get(url)函数"></a>requests.get(url)函数</h3><p>获取一个网页，最简单的代码就是<code>r=requests.get(url) </code>url：输入目标网址</p><p>requests.get(url)方法就是构造一个向服务器请求资源的Request对象，这个对象是Request库内部生成的。</p><p>Request库有两个重要对象，分别是<code>Request</code>和<code>Response</code>。Request对象对应的是请求，向目标网址发送一个请求访问服务。而Response对象，是包含了爬虫返回的内容。</p><p>实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-comment">#get()获取网页</span><br>r = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>)<br><span class="hljs-comment"># 检查连接状态</span><br><span class="hljs-built_in">print</span>(r.status_code)<br><span class="hljs-comment"># 检测r的类型</span><br><span class="hljs-built_in">print</span>(type(r))<br><span class="hljs-comment"># 获取页面的头部信息</span><br><span class="hljs-built_in">print</span>(r.headers)<br></code></pre></td></tr></table></figure><p>返回内容为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">200</span><br>&lt;class &#x27;requests.models.Response&#x27;&gt;<br>&#123;&#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;, &#x27;Content-Length&#x27;: &#x27;<span class="hljs-number">1145</span>&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Server&#x27;: &#x27;bfe&#x27;, &#x27;Date&#x27;: &#x27;Tue, 24 Mar <span class="hljs-number">2020</span> 07:31:58 GMT&#x27;&#125;<br></code></pre></td></tr></table></figure><p>Response对象的属性，有以下几种 :</p><ul><li><p>r.status_code： HTTP请求的返回状态，200表示连接成功，404表示失败</p></li><li><p>r.text： HTTP响应内容的字符串形式，即，ur对应的页面内容</p></li><li><p>r.encoding：从HTTP header中<code>猜测</code>的响应内容编码方式,是自己定义的，实际内容编码在<code>r.apparent_encoding</code>里。如果两者不同会出现分析内容为乱码的情况，需要替换编码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 查看编码</span><br><span class="hljs-built_in">print</span>(r.encoding)<br><span class="hljs-built_in">print</span>(r.apparent_encoding)<br><span class="hljs-comment"># 替换编码,假设实际响应内容编码为utf-8</span><br>r.<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</p></li><li><p>r.content： HTTP响应内容的二进制形式</p></li></ul><p>这几个属性，都是访问网页时必要的属性。如果状态码是200，就可以用Response属性来获取网页信息。</p><h2 id="step-4-解析网页-分析简化地址"><a href="#step-4-解析网页-分析简化地址" class="headerlink" title="step 4:解析网页,分析简化地址"></a>step 4:解析网页,分析简化地址</h2><p>回到网页，按F12，找到网页的Elements部分；用左上角的小框带箭头的标志，点击网页内容，网页会自动在右边显示出对应的代码。在找到想要爬取的页面部分的网页代码后，将鼠标放置于代码上，右键，copy到selector部分。</p><p>此时复制的selector相当于网页上对应部分存放的地址。由于爬虫需要的是网页上的一类信息，所以需要对获取的地址进行分析，提取，制造<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors">CSS选择器</a><br>。那个地址本身只能获取到你选择的网页上的那一小部分内容。</p><h2 id="step-5-爬取内容，清洗数据"><a href="#step-5-爬取内容，清洗数据" class="headerlink" title="step 5:爬取内容，清洗数据"></a>step 5:爬取内容，清洗数据</h2><p>用一个标签存储上面提炼出的像地址一样的东西，标签会拉取到爬虫想获得的网页内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#爬取内容</span><br><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr # &gt; td.al &gt; a&quot;</span><br></code></pre></td></tr></table></figure><p>之后我们就要soup和text过滤掉不必要的信息，比如js类语言，排除这类语言对于信息受众阅读的干扰。</p><h3 id="soup-select-函数"><a href="#soup-select-函数" class="headerlink" title="soup.select()函数"></a>soup.select()函数</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span>(<span class="hljs-built_in">self</span>, selector, namespaces=<span class="hljs-literal">None</span>, limit=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>功能：查找html中所需要的内容<br>主要使用的参数是<code>selector</code>，其定义为”包含CSS选择器的字符串“。</p><p>soup.select( )可通过以下方法进行查找：</p><ul><li>通过（HTML）标签名查找</li><li>通过CCS类选择器查找</li><li>通过CCS id 选择器查找</li><li>组合查找</li><li>子标签查找</li><li>通过属性查找</li></ul><p>参考：<a href="https://blog.csdn.net/wei_lin/article/details/102334956">https://blog.csdn.net/wei_lin/article/details/102334956</a></p><h2 id="实例源码1：爬取实时微博热搜"><a href="#实例源码1：爬取实时微博热搜" class="headerlink" title="实例源码1：爬取实时微博热搜"></a>实例源码1：爬取实时微博热搜</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import requests<br><span class="hljs-keyword">from</span> bs4 import BeautifulSoup<br><br><span class="hljs-comment"># 爬虫头数据</span><br>cookies = &#123;<br>    <span class="hljs-string">&#x27;Hm_lvt_3b1e939f6e789219d8629de8a519eab9&#x27;</span>: <span class="hljs-string">&#x27;1690790195&#x27;</span>,<br>    <span class="hljs-string">&#x27;Hm_lpvt_3b1e939f6e789219d8629de8a519eab9&#x27;</span>: <span class="hljs-string">&#x27;1690790469&#x27;</span>,<br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;authority&#x27;</span>: <span class="hljs-string">&#x27;tophub.today&#x27;</span>,<br>    <span class="hljs-string">&#x27;accept&#x27;</span>: <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span>,<br>    <span class="hljs-string">&#x27;accept-language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>,<br>    <span class="hljs-string">&#x27;cache-control&#x27;</span>: <span class="hljs-string">&#x27;max-age=0&#x27;</span>,<br>    # <span class="hljs-string">&#x27;cookie&#x27;</span>: <span class="hljs-string">&#x27;Hm_lvt_3b1e939f6e789219d8629de8a519eab9=1690790195; Hm_lpvt_3b1e939f6e789219d8629de8a519eab9=1690790469&#x27;</span>,<br>    <span class="hljs-string">&#x27;referer&#x27;</span>: <span class="hljs-string">&#x27;https://www.bing.com/&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua&#x27;</span>: <span class="hljs-string">&#x27;&quot;Not/A)Brand&quot;;v=&quot;99&quot;, &quot;Microsoft Edge&quot;;v=&quot;115&quot;, &quot;Chromium&quot;;v=&quot;115&quot;&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="hljs-string">&#x27;?0&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-ch-ua-platform&#x27;</span>: <span class="hljs-string">&#x27;&quot;Windows&quot;&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-dest&#x27;</span>: <span class="hljs-string">&#x27;document&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-mode&#x27;</span>: <span class="hljs-string">&#x27;navigate&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-site&#x27;</span>: <span class="hljs-string">&#x27;cross-site&#x27;</span>,<br>    <span class="hljs-string">&#x27;sec-fetch-user&#x27;</span>: <span class="hljs-string">&#x27;?1&#x27;</span>,<br>    <span class="hljs-string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188&#x27;</span>,<br>&#125;<br><br><br><span class="hljs-comment">#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr:nth-child(1) &gt; td.al &gt; a</span><br><span class="hljs-comment">#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; td.al &gt; a</span><br><br><span class="hljs-comment">#数据存储</span><br>fo = open(<span class="hljs-string">&quot;./微博热搜.txt&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-comment">#获取网页</span><br>response = requests.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://tophub.today/n/KqndgxeLl9&#x27;</span>, <span class="hljs-attribute">cookies</span>=cookies, <span class="hljs-attribute">headers</span>=headers)<br><span class="hljs-comment">#解析网页</span><br>response.<span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-comment">#爬取内容</span><br><span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;#page &gt; div.c-d.c-d-e &gt; div.Zd-p-Sc &gt; div:nth-child(1) &gt; div.cc-dc-c &gt; div &gt; div.jc-c &gt; table &gt; tbody &gt; tr &gt; td.al &gt; a&quot;</span><br><span class="hljs-comment">#数据清洗</span><br><span class="hljs-attribute">a</span>=soup.select(content)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(0,len(a)):<br>    a[i] = a[i].text<br>    fo.write(a[i]+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>fo.close()<br></code></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h2 id="1-绕过反爬机制"><a href="#1-绕过反爬机制" class="headerlink" title="1. 绕过反爬机制"></a>1. 绕过反爬机制</h2><h3 id="请求频率限制"><a href="#请求频率限制" class="headerlink" title="请求频率限制"></a>请求频率限制</h3><p>使用sleep等待随机时间，或者使用代理ip去访问。</p><h4 id="随机延迟"><a href="#随机延迟" class="headerlink" title="随机延迟"></a>随机延迟</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.sleep</span>(random<span class="hljs-selector-class">.randint</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h4 id="建立代理ip池"><a href="#建立代理ip池" class="headerlink" title="建立代理ip池"></a>建立代理ip池</h4><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立属于自己的开放代理IP池</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> fake_useragent <span class="hljs-keyword">import</span> UserAgent<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IpPool</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 测试ip是否可用url</span><br>        self.test_url = <span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span><br>        <span class="hljs-comment"># 获取IP的 目标url</span><br>        self.url = <span class="hljs-string">&#x27;https://www.89ip.cn/index_&#123;&#125;.html&#x27;</span><br><br>        self.headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: UserAgent().random&#125;<br>        <span class="hljs-comment"># 存储可用ip</span><br>        self.file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;ip_pool.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_html</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;获取页面&#x27;&#x27;&#x27;</span><br>        html = requests.get(url=url, headers=self.headers).text<br><br>        <span class="hljs-keyword">return</span> html<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>(<span class="hljs-params">self, url</span>):<br>     <span class="hljs-string">&#x27;&#x27;&#x27;数据处理  获取ip 和端口&#x27;&#x27;&#x27;</span> <br>        html = self.get_html(url=url)<br>        <span class="hljs-comment"># print(html)</span><br>       <br>        elemt = etree.HTML(html)<br>        <br>        ips_list = elemt.xpath(<span class="hljs-string">&#x27;//table/tbody/tr/td[1]/text()&#x27;</span>)<br>        ports_list = elemt.xpath(<span class="hljs-string">&#x27;//table/tbody/tr/td[2]/text()&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> ip, port <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(ips_list, ports_list):<br>            <span class="hljs-comment"># 拼接ip与port</span><br>            proxy = ip.strip() + <span class="hljs-string">&quot;:&quot;</span> + port.strip()<br>            <span class="hljs-comment"># print(proxy)</span><br>            <br>            <span class="hljs-comment"># 175.44.109.195:9999</span><br>            self.test_proxy(proxy)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_proxy</span>(<span class="hljs-params">self, proxy</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;测试代理IP是否可用&#x27;&#x27;&#x27;</span><br>        proxies = &#123;<br>            <span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">&#x27;http://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(proxy),<br>            <span class="hljs-string">&#x27;https&#x27;</span>: <span class="hljs-string">&#x27;https://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(proxy),<br>        &#125;<br>        <span class="hljs-comment"># 参数类型</span><br>        <span class="hljs-comment"># proxies</span><br>        <span class="hljs-comment"># proxies = &#123;&#x27;协议&#x27;: &#x27;协议://IP:端口号&#x27;&#125;</span><br>        <span class="hljs-comment"># timeout 超时设置 网页响应时间3秒 超过时间会抛出异常</span><br>        <span class="hljs-keyword">try</span>:<br>            resp = requests.get(url=self.test_url, proxies=proxies, headers=self.headers, timeout=<span class="hljs-number">3</span>)<br>           <span class="hljs-comment"># 获取 状态码为200 </span><br>            <span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;\033[31m可用\033[0m&#x27;</span>)<br>                <span class="hljs-comment"># 可以的IP 写入文本以便后续使用</span><br>                self.file.write(proxy)<br>                <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;不可用&#x27;</span>)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(proxy, <span class="hljs-string">&#x27;不可用&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;执行函数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 快代理每页url 的区别</span><br>        <span class="hljs-comment"># https://www.kuaidaili.com/free/inha/1/</span><br>        <span class="hljs-comment"># https://www.kuaidaili.com/free/inha/2/</span><br>        <span class="hljs-comment"># .......</span><br><span class="hljs-comment"># 提供的免费ip太多</span><br>        <span class="hljs-comment"># 这里只获取前100页提供的免费代理IP测试</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):<br>            <span class="hljs-comment"># 拼接完整的url</span><br>            page_url = self.url.<span class="hljs-built_in">format</span>(i)<br>            <span class="hljs-comment"># 注意抓取控制频率</span><br>            time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<br>            self.get_proxy(url=page_url)<br><br>        <span class="hljs-comment"># 执行完毕关闭文本</span><br>        self.file.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ip = IpPool()<br>    ip.crawl()<br><br></code></pre></td></tr></table></figure><h4 id="使用开源项目proxcyPool-不好用，ip拿不出来"><a href="#使用开源项目proxcyPool-不好用，ip拿不出来" class="headerlink" title="使用开源项目proxcyPool(不好用，ip拿不出来)"></a>使用开源项目proxcyPool(不好用，ip拿不出来)</h4><p>项目仓库：<a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></p><ol><li>redis常用命令：</li></ol><ul><li>启动server<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redis-server<span class="hljs-selector-class">.exe</span> redis<span class="hljs-selector-class">.windows</span><span class="hljs-selector-class">.conf</span> <br></code></pre></td></tr></table></figure>先输入上面的命令手动开启server，再重新开个终端，输入<code>redis-cli.exe</code>开始运行。</li><li>关闭redis<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">shutdown<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>在 Windows 上，Redis 默认情况下并不会自动生成日志文件，也不会将日志输出到文件中。Redis 会将日志输出到控制台（Console），除非在配置文件中显式地指定了日志文件路径。</p></li><li><p>开启爬取代理 IP </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> proxyPool.<span class="hljs-keyword">py</span> schedule<br></code></pre></td></tr></table></figure></li><li><p>使用代理 IP，需要启动 webApi 服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> proxyPool.<span class="hljs-keyword">py</span> server<br></code></pre></td></tr></table></figure><p>启动web服务后, 默认配置下会开启 <code>127.0.0.1:5010</code> 的api接口服务。</p></li></ol><table><thead><tr><th>api</th><th>method</th><th>Description</th><th>params</th></tr></thead><tbody><tr><td>&#x2F;</td><td>GET</td><td>api介绍</td><td>None</td></tr><tr><td>&#x2F;get</td><td>GET</td><td>随机获取一个代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;pop</td><td>GET</td><td>获取并删除一个代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;all</td><td>GET</td><td>获取所有代理</td><td>可选参数: ?type&#x3D;https 过滤支持https的代理</td></tr><tr><td>&#x2F;count</td><td>GET</td><td>查看代理数量</td><td>None</td></tr><tr><td>&#x2F;delete</td><td>GET</td><td>删除代理</td><td>?proxy&#x3D;host:ip</td></tr></tbody></table><p>如果要在爬虫代码中使用的话， 可以将此api封装成函数直接使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>():<br>    <span class="hljs-keyword">return</span> requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/get/&quot;</span>).json()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_proxy</span>(<span class="hljs-params">proxy</span>):<br>    requests.get(<span class="hljs-string">&quot;http://127.0.0.1:5010/delete/?proxy=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(proxy))<br><br><span class="hljs-comment"># your spider code</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHtml</span>():<br>    <span class="hljs-comment"># ....</span><br>    retry_count = <span class="hljs-number">5</span><br>    proxy = get_proxy().get(<span class="hljs-string">&quot;proxy&quot;</span>)<br>    <span class="hljs-keyword">while</span> retry_count &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">try</span>:<br>            html = requests.get(<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, proxies=&#123;<span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(proxy)&#125;)<br>            <span class="hljs-comment"># 使用代理访问</span><br>            <span class="hljs-keyword">return</span> html<br>        <span class="hljs-keyword">except</span> Exception:<br>            retry_count -= <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 删除代理池中代理</span><br>    delete_proxy(proxy)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h4 id="重新找了一个开源的代理ip池"><a href="#重新找了一个开源的代理ip池" class="headerlink" title="重新找了一个开源的代理ip池"></a>重新找了一个开源的代理ip池</h4><p><a href="https://github.com/Python3WebSpider/ProxyPool.git">https://github.com/Python3WebSpider/ProxyPool.git</a></p><h3 id="伪装浏览器进行访问-User-Agent"><a href="#伪装浏览器进行访问-User-Agent" class="headerlink" title="伪装浏览器进行访问(User-Agent)"></a>伪装浏览器进行访问(User-Agent)</h3><p>User-Agent中文名为用户代理，简称 UA，是Http协议中的一部分，属于头域的组成部分。它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p><h4 id="如何查看UA"><a href="#如何查看UA" class="headerlink" title="如何查看UA"></a>如何查看UA</h4><p>打开一个网页，按下F12，选择network，再点击headers就可以看到User-Agent</p><p>如果同一个网站被相同浏览器频繁访问，很容易被网站识别为爬虫程序，所以一般通过使用多个User-Agent随机调用的方式，可以有效避免同一个请求头访问网站。</p><h4 id="调用python中的useragent模块"><a href="#调用python中的useragent模块" class="headerlink" title="调用python中的useragent模块"></a>调用python中的useragent模块</h4><p>Python 中的第三方模块 fake_useragent 可以返回一个随机封装好的UA，直接使用即可。</p><p>先安装库：<code>pip install fake-useragent</code></p><p>简单的使用一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> fake_useragent<br><br><span class="hljs-comment"># 实例化 user-agent 对象</span><br>ua = fake_useragent.UserAgent()<br><span class="hljs-built_in">print</span>(ua.chrome)<br></code></pre></td></tr></table></figure><p>要频繁抓取一个网页，每次都设置一样的UA，这也会被网站怀疑，因此需要在抓取网页的过程中随机更换UA：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> fake_useragent<br><br><span class="hljs-comment"># 实例化 user-agent 对象</span><br>ua = fake_useragent.UserAgent()<br><span class="hljs-built_in">print</span>(ua.random)<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">import</span> fake_useragent<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> random<br><br>url = <span class="hljs-string">r&#x27;http://www.baidu.com/&#x27;</span><br>ua = fake_useragent.UserAgent()<br>list2 = []<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>:ua.random&#125;<span class="hljs-comment">#headers = &#123;&quot;User-Agent&quot;: ua.random&#125;</span><br>    list2.append(headers)<br>i= random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>req = request.Request(url,headers= list2[i])<br>pat = <span class="hljs-string">r&#x27;&lt;title&gt;(.*?)&lt;/title&gt;&#x27;</span><br>response = request.urlopen(req)<br><span class="hljs-built_in">print</span>(response.status)<br>reponse = request.urlopen(req).read().decode()<br>data = re.findall(pat,reponse)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#百度一下，你就知道</span><br></code></pre></td></tr></table></figure><h1 id="爬虫项目"><a href="#爬虫项目" class="headerlink" title="爬虫项目"></a>爬虫项目</h1><h2 id="DouBanSpider-–-豆瓣读书爬虫"><a href="#DouBanSpider-–-豆瓣读书爬虫" class="headerlink" title="DouBanSpider – 豆瓣读书爬虫"></a>DouBanSpider – 豆瓣读书爬虫</h2><p>可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。</p><h3 id="记录报错："><a href="#记录报错：" class="headerlink" title="记录报错："></a>记录报错：</h3><h4 id="AttributeError-module-‘urllib’-has-no-attribute-‘quote’"><a href="#AttributeError-module-‘urllib’-has-no-attribute-‘quote’" class="headerlink" title="AttributeError: module ‘urllib’ has no attribute ‘quote’"></a>AttributeError: module ‘urllib’ has no attribute ‘quote’</h4><p>报错的意思是在urllib模块中找不到名为quote的属性或函数。在Python中，urllib是一个用于处理URL的标准库模块，其中包含了许多有用的函数，包括quote和unquote函数，用于URL编码和解码。</p><p>在Python 3中，quote函数已经移动到了urllib.parse模块中，所以正确的调用方式应该是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import urllib<span class="hljs-selector-class">.parse</span><br><br>url = <span class="hljs-string">&quot;https://example.com/?query=hello world&quot;</span><br>encoded_url = urllib<span class="hljs-selector-class">.parse</span><span class="hljs-selector-class">.quote</span>(url)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(encoded_url)</span></span><br></code></pre></td></tr></table></figure><h4 id="soup-BeautifulSoup-plain-text"><a href="#soup-BeautifulSoup-plain-text" class="headerlink" title="soup &#x3D; BeautifulSoup(plain_text)"></a>soup &#x3D; BeautifulSoup(plain_text)</h4><p>这个警告是来自BeautifulSoup库，它是一个用于解析HTML和XML文档的Python库。该警告表明您在创建BeautifulSoup对象时没有显式地指定解析器.可以将解析器设置为”lxml”，因为它是一个快速且功能强大的解析器。代码示例如下：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br># 显式指定解析器为<span class="hljs-string">&quot;lxml&quot;</span><br>soup = BeautifulSoup(plain_text, features=<span class="hljs-string">&quot;lxml&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果在代码中<code>已经显式指定了解析器为&quot;lxml&quot;，但仍然收到相同的警告</code>，那么代码中可能有多个地方创建了BeautifulSoup对象，并且其中某些地方没有传递features&#x3D;”lxml”参数。请检查代码中的其他地方，确认所有的BeautifulSoup对象创建都传递了正确的解析器参数。</p><h3 id="关于直接输出的解码问题"><a href="#关于直接输出的解码问题" class="headerlink" title="关于直接输出的解码问题"></a>关于直接输出的解码问题</h3><p>使用codecs库里面的escape_decode函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">book_list<span class="hljs-selector-class">.append</span>(<span class="hljs-selector-attr">[title,rating,people_num,author_info,pub_info]</span>)<br><br>           title_output = codecs<span class="hljs-selector-class">.escape_decode</span>(title)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           rating_output = codecs<span class="hljs-selector-class">.escape_decode</span>(rating)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           people_num_output = codecs<span class="hljs-selector-class">.escape_decode</span>(people_num)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           author_info_output = codecs<span class="hljs-selector-class">.escape_decode</span>(author_info)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           pub_info_output = codecs<span class="hljs-selector-class">.escape_decode</span>(pub_info)<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.decode</span>()<br>           <span class="hljs-built_in">print</span>(title_output,rating_output,people_num_output,author_info_output,pub_info_output)<br></code></pre></td></tr></table></figure><h3 id="写入excel的技术积累"><a href="#写入excel的技术积累" class="headerlink" title="写入excel的技术积累"></a>写入excel的技术积累</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">def print_book_lists_excel(book_lists,book_tag_lists):<br>    wb=Workbook(optimized_write=True)<br>    <span class="hljs-keyword">ws</span>=[]<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)):<br>        <span class="hljs-keyword">ws</span>.<span class="hljs-keyword">append</span>(wb.create_sheet(title=book_tag_lists[i].decode())) #utf8-&gt;unicode<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)): <br>        <span class="hljs-keyword">ws</span>[i].<span class="hljs-keyword">append</span>([<span class="hljs-string">&#x27;序号&#x27;</span>,<span class="hljs-string">&#x27;书名&#x27;</span>,<span class="hljs-string">&#x27;评分&#x27;</span>,<span class="hljs-string">&#x27;评价人数&#x27;</span>,<span class="hljs-string">&#x27;作者&#x27;</span>,<span class="hljs-string">&#x27;出版社&#x27;</span>])<br>        <span class="hljs-built_in">count</span>=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">bl</span> in book_lists[i]:<br>            <span class="hljs-keyword">ws</span>[i].<span class="hljs-keyword">append</span>([<span class="hljs-built_in">count</span>,<span class="hljs-keyword">bl</span>[<span class="hljs-number">0</span>],float(<span class="hljs-keyword">bl</span>[<span class="hljs-number">1</span>]),<span class="hljs-keyword">int</span>(<span class="hljs-keyword">bl</span>[<span class="hljs-number">2</span>]),<span class="hljs-keyword">bl</span>[<span class="hljs-number">3</span>],<span class="hljs-keyword">bl</span>[<span class="hljs-number">4</span>]])<br>            <span class="hljs-built_in">count</span>+=<span class="hljs-number">1</span><br>    save_path=<span class="hljs-string">&#x27;book_list&#x27;</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(book_tag_lists)):<br>        save_path+=(<span class="hljs-string">&#x27;-&#x27;</span>+book_tag_lists[i].decode())<br>    save_path+=<span class="hljs-string">&#x27;.xlsx&#x27;</span><br>    wb.save(save_path)<br></code></pre></td></tr></table></figure><p>这段代码也提供了utf-8转unicode的方式：.decode( )函数</p><h2 id="bilibili用户数据爬虫"><a href="#bilibili用户数据爬虫" class="headerlink" title="bilibili用户数据爬虫"></a>bilibili用户数据爬虫</h2><p>p</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2023/07/28/python%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/28/python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>记录python的学习过程~</p><span id="more"></span> <h2 id="pycharm配置python开发环境"><a href="#pycharm配置python开发环境" class="headerlink" title="pycharm配置python开发环境"></a>pycharm配置python开发环境</h2><p>参考：<br><a href="https://blog.csdn.net/yuhui_2000/article/details/109185168">https://blog.csdn.net/yuhui_2000/article/details/109185168</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><ul><li>单行注释以 ＃ 号开头</li><li>多行注释用两个三引号&#96;&#96;&#96;包含起来<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>  <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">2.  第一行注释</span><br><span class="hljs-string">3.  第二行注释</span><br><span class="hljs-string">4.  &#x27;&#x27;&#x27;</span><br><span class="hljs-number">5.</span>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello,World!&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Python的行与缩进"><a href="#2-Python的行与缩进" class="headerlink" title="2. Python的行与缩进"></a>2. Python的行与缩进</h3><ul><li>使用缩进来表示代码块，不需要像C或者C++一样使用大括号。</li><li>缩进的空格数可变，但是同一个代码块的语句必须包含相同的缩进空格数</li><li>使用四个空格来表示一个缩进层级<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> x &gt; 0:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is positive&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;positive number&quot;</span>) <br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is zero or negative&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-多行语句"><a href="#3-多行语句" class="headerlink" title="3. 多行语句"></a>3. 多行语句</h3><p>Python 通常是一行写完一条语句；长语句可通过反斜杠（\）来实现多行语句。</p><p>python的print()函数中参数end&#x3D;’ ‘默认为\n，所以会自动换行。</p><ul><li>end&#x3D;’ ‘  表示不换行</li><li>end&#x3D;’\t’——表示缩进，就是按一下Tab键</li><li>end&#x3D;’\n’——相当于换行</li><li>end&#x3D;’\r’ 返回行首，最后一个字符的输入会将之前的字符全部覆盖掉</li></ul><h3 id="4-等待用户输入：input-函数"><a href="#4-等待用户输入：input-函数" class="headerlink" title="4. 等待用户输入：input() 函数"></a>4. 等待用户输入：input() 函数</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Who are you?&quot;</span>)<br>2.  you = input()<br>3.  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>4.  <span class="hljs-built_in">print</span>(you)<br></code></pre></td></tr></table></figure><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><ul><li>变量命名和赋值：Python 的变量无须提前声明，赋值的同时也就声明了变量。<br>  eg:<code>a = 42</code></li><li>查询关键字：keyword模块中的kwlist是一个列表，存放了Python中所有的关键字(str格式)。<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">#列出所有关键字<br><span class="hljs-keyword">import</span> keyword<br>keyword.kwlist <br><br>#判断是否为关键字，为真,返回<span class="hljs-literal">True</span>，为假,返回<span class="hljs-literal">False</span><br>keyword.iskeyword(<span class="hljs-string">&quot;break&quot;</span>)<br>keyword.iskeyword(<span class="hljs-string">&quot;breaka&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h3><p>Python 中拥有 6 大数据类型：number、string、list（列表）、tuple（元组）、sets （集合）、dictionary（字典）。</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>类型：int、float、bool、complex (复数)</p><p>使用 type() 函数来查看数字类型</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=1 <span class="hljs-attribute">b</span>=3.14 <span class="hljs-attribute">c</span>=<span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(type(a)) <span class="hljs-built_in">print</span>(type(b)) <span class="hljs-built_in">print</span>(type(c))<br></code></pre></td></tr></table></figure><p>运算类型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.  print((<span class="hljs-number">3</span>+<span class="hljs-number">1</span>))        #加法运算，输出结果是 <span class="hljs-number">4</span><br><span class="hljs-attribute">2</span>.  print((<span class="hljs-number">8</span>.<span class="hljs-number">4</span>-<span class="hljs-number">3</span>))      #减法运算，输出结果是<span class="hljs-number">5</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">3</span>.  print(<span class="hljs-number">15</span>/<span class="hljs-number">4</span>)         #除法运算，输出结果是 <span class="hljs-number">3</span>.<span class="hljs-number">75</span><br><span class="hljs-attribute">4</span>.  print(<span class="hljs-number">15</span>//<span class="hljs-number">4</span>)        #整除运算，输出结果是 <span class="hljs-number">3</span><br><span class="hljs-attribute">5</span>.  print(<span class="hljs-number">15</span>%<span class="hljs-number">4</span>)         #取余运算，输出结果是 <span class="hljs-number">3</span><br><span class="hljs-attribute">6</span>.  print(<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)          #乘法运算，输出结果是 <span class="hljs-number">6</span><br><span class="hljs-attribute">7</span>.  print(<span class="hljs-number">2</span>**<span class="hljs-number">3</span>)         #乘方运算，输出结果是 <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>math 模块、cmath 模块:<br>数学运算常用的函数基本都在 math 模块、cmath 模块中。<br>要使用 math 或 cmath 函数必须先导入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> math<br></code></pre></td></tr></table></figure><p>更多数学函数、三角函数、<code>pi</code>,<code>e</code>、随机数函数等，详细参考：<br><a href="https://www.runoob.com/python/python-numbers.html">https://www.runoob.com/python/python-numbers.html</a></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>单引号与双引号的作用一样，但是当引号里包含单引号时，则该引号需使用双引号；三引号可以指示一个多行的字符串，也可以在三引号中自由使用单引号和双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#单引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;welcome to hangzhou&#x27;</span>)<br><span class="hljs-comment">#双引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;what’s your name?&quot;</span>)<br><span class="hljs-comment">#三引号示例</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;Mike:Hi,How are you?</span><br><span class="hljs-string">LiMing:Fine,Thank you!and you?</span><br><span class="hljs-string">Mike:I’m fine,too!&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>tips：</p><ol><li><p>使用双反斜杠（<code>\\</code>）来表示反斜杠本身，而 \n 表示换行</p></li><li><p>想要指示某些不需要使用转义符进行特别处理的字符串，那么需要指定一个原始字符串。原始字符串通过给字符串加上前缀 r 或 R：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">r&quot;换行符是\n。&quot;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(s)</span><br>换行符是\n。<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&#x27;it\&#x27;s me&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s</span><br>&quot;it&#x27;s me&quot;<br><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-string">&quot;换行符是\\n。&quot;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(s)</span><br>换行符是\n。<br></code></pre></td></tr></table></figure><p>详细可参考：<a href="https://blog.csdn.net/yawei_liu1688/article/details/108364192">https://blog.csdn.net/yawei_liu1688/article/details/108364192</a></p></li><li><p>字符串的截取（切片） ：<code>字符串常量[start_index:end_index+1]</code>(左闭右开)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-number">1.</span>  <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;Lingyi&#x27;</span><br><span class="hljs-number">2.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>]) <span class="hljs-meta">#输出结果为L</span><br><span class="hljs-number">3.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]) <span class="hljs-meta">#输出结果为ing</span><br><span class="hljs-number">4.</span>  <span class="hljs-keyword">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">-1</span>]) <span class="hljs-meta">#输出结果为i</span><br></code></pre></td></tr></table></figure></li></ol><ul><li>[:] 这种形式 就是 从哪截取到哪里 如果是负数 就从后往前找</li><li>[::] 这种形式 第一个 ：代表处理后的字符串，第二个 ： 代表间隔截取，正数正向输出，负数代表逆向输出<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">str</span> = &#x27;<span class="hljs-number">0123456789</span>&#x27;<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[0:3]：&quot;</span>+str[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])     # 正向截取字符串 <span class="hljs-number">0</span>~<span class="hljs-number">3</span>（不包含<span class="hljs-number">3</span>）,即 <span class="hljs-number">012</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:]:&quot;</span>+str[:])          # 正向输出所有字符串,即<span class="hljs-number">0123456789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[6:]：&quot;</span>+str[<span class="hljs-number">6</span>:])       # 正向输出字符,从 <span class="hljs-number">6</span> ~ 结束  即 <span class="hljs-number">6789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-3]：&quot;</span>+str[:-<span class="hljs-number">3</span>])     # 正向输出,从开始 ~ 倒数第第<span class="hljs-number">3</span>个字符（不含第<span class="hljs-number">3</span>个）即 <span class="hljs-number">0123456</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[2]：&quot;</span>+str[<span class="hljs-number">2</span>])         #输出第<span class="hljs-number">3</span>个字符 即 <span class="hljs-number">2</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-1]：&quot;</span>+str[:-<span class="hljs-number">1</span>])     # 正向输出,从开始 ~ 倒数第第<span class="hljs-number">1</span>个字符（不含第<span class="hljs-number">1</span>个）即 <span class="hljs-number">012345678</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-1]：&quot;</span>+str[-<span class="hljs-number">1</span>])       # 输出最后一个字符 即 <span class="hljs-number">9</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-3:-1]:&quot;</span>+str[-<span class="hljs-number">3</span>:-<span class="hljs-number">1</span>])  #逆序输出,从倒数第 <span class="hljs-number">3</span> ~ 倒数第 <span class="hljs-number">1</span> （不含） 即 <span class="hljs-number">78</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[-3:]:&quot;</span>+str[-<span class="hljs-number">3</span>:])      # 逆序输出,从倒数第 <span class="hljs-number">3</span> ~ 最后 即 <span class="hljs-number">789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::-1]：&quot;</span>+str[::-<span class="hljs-number">1</span>])   # 逆序输出,连续输出所有字符串,即  <span class="hljs-number">9876543210</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::-2]：&quot;</span>+str[::-<span class="hljs-number">2</span>])   # 逆序输出,从最后一个开始，每隔<span class="hljs-number">2</span>个字符串输出一个  <span class="hljs-number">97531</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::1]：&quot;</span>+str[::<span class="hljs-number">1</span>])     # 正序输出,连续输出所有字符串,即 <span class="hljs-number">0123456789</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[::2]：&quot;</span>+str[::<span class="hljs-number">2</span>])     # 正序输出,从第一个开始，每隔<span class="hljs-number">2</span>个字符串输出一个即 <span class="hljs-number">02468</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[:-2:4]:&quot;</span>+str[:-<span class="hljs-number">2</span>:<span class="hljs-number">4</span>])  # 正序输出,从第一个开始，每隔<span class="hljs-number">4</span>个字符输出一个 即 <span class="hljs-number">04</span><br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;str[1:-2:4]:&quot;</span>+str[<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>:<span class="hljs-number">4</span>])# 正序输出,从第二个开始，每隔<span class="hljs-number">4</span>个字符输出一个 即 <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>不同数据类型可以相互转换<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-number">1.</span>  <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>  string = <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-number">3.</span>  num2 = <span class="hljs-built_in">int</span>(string)<br><span class="hljs-number">4.</span>  <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>+num2)<br></code></pre></td></tr></table></figure></li><li><code>+</code>用在字符串中间是连接符，用在数值中间是运算符<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#运算符，结果为3</span><br><span class="hljs-bullet">1.</span>  a = 1<br><span class="hljs-bullet">2.</span>  b = 2<br><span class="hljs-bullet">3.</span>  c = a+b<br><span class="hljs-bullet">4.</span>  print(c)<br><br><span class="hljs-section">#连接符，结果为ab</span><br><span class="hljs-bullet">1.</span>  a = 1<br><span class="hljs-bullet">2.</span>  b = 2<br><span class="hljs-bullet">3.</span>  c = &#x27;a&#x27;+&#x27;b&#x27;<br><span class="hljs-bullet">4.</span>  print(c)<br></code></pre></td></tr></table></figure></li><li>字符串的驻留机制：<a href="https://zhuanlan.zhihu.com/p/35362912">https://zhuanlan.zhihu.com/p/35362912</a></li><li>字符串内建函数：实现了 string 模块的大部分方法。<br>详细参考：<a href="https://www.runoob.com/python/python-strings.html">https://www.runoob.com/python/python-strings.html</a></li></ol><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表是任意对象的有序集合，元素之间用逗号隔开。这里的任意对象，包括列表嵌套列表。</p><ol><li>列表删除操作：<ul><li><p><code>del 目标 或 del(目标)</code>\</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除列表</span><br>list1 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br><span class="hljs-comment"># 2种写法</span><br><span class="hljs-built_in">del</span> list1<br><span class="hljs-comment"># del(list1 )</span><br><br><span class="hljs-comment"># 删除指定数据</span><br>list2 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br><span class="hljs-built_in">del</span> list2[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li><li><p><code>pop()</code><br> 删除指定下标的数据，如果不指定下标，默认删除最后一个数据，无论是按照下标还是删除最后一个，pop函数都会返回这个被删除的数据</p></li><li><p><code>remove(数据)</code></p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list1 = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>]<br>list1.<span class="hljs-built_in">remove</span>(<span class="hljs-string">&#x27;python&#x27;</span>)<br><span class="hljs-comment"># 也可以写成：list1.remove(list1[0]) </span><br></code></pre></td></tr></table></figure></li><li><p><code>clear(列表名) </code>：清空列表</p></li></ul></li><li>更新列表：使用<code>append()</code>添加列表项</li><li>列表脚本操作符:<br>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</li><li>常用列表函数：<br><a href="https://www.runoob.com/python/python-lists.html">https://www.runoob.com/python/python-lists.html</a></li></ol><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号，列表使用方括号。</p><ol><li>删除元组：<code>del 元组名</code></li><li>对元组连接组合</li><li>元组运算符（进行组合和复制）</li><li>元组索引，截取</li><li>无关闭分隔符：任意无符号的对象，以逗号隔开，默认为元组</li><li>元组内置函数：<br><a href="https://www.runoob.com/python/python-tuples.html">https://www.runoob.com/python/python-tuples.html</a></li></ol><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>一种可变容器模型，且可存储任意类型对象。<br><code>dict</code> 作为 Python 的关键字和内置函数，字典的变量名不建议命名为 dict。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">d = &#123;key1 : <span class="hljs-type">value1</span>, key2 : <span class="hljs-type">value2</span> &#125;<br></code></pre></td></tr></table></figure><p>字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><ul><li>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</li><li>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</li></ul><ol><li>访问字典的值<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/usr/bin/python</span><br> <br>tinydict = &#123;<span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-string">&#x27;Zara&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>: 7, <span class="hljs-string">&#x27;Class&#x27;</span>: <span class="hljs-string">&#x27;First&#x27;</span>&#125;<br> <br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="hljs-string">&#x27;Age&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li>修改字典<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tinydict = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: <span class="hljs-number">7</span>, &#x27;Class&#x27;: &#x27;First&#x27;&#125;<br> <br>tinydict[&#x27;Age&#x27;] = <span class="hljs-number">8</span> <span class="hljs-meta"># 更新</span><br>tinydict[&#x27;School&#x27;] = <span class="hljs-string">&quot;RUNOOB&quot;</span> <span class="hljs-meta"># 添加</span><br></code></pre></td></tr></table></figure></li><li>删除字典元素<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">del</span> tinydict[<span class="hljs-string">&#x27;Name&#x27;</span>]  <span class="hljs-comment"># 删除键是&#x27;Name&#x27;的条目</span><br>tinydict.clear()      <span class="hljs-comment"># 清空字典所有条目</span><br><span class="hljs-built_in">del</span> tinydict          <span class="hljs-comment"># 删除字典</span><br></code></pre></td></tr></table></figure></li><li>字典内置函数&amp;方法<br><a href="https://www.runoob.com/python/python-dictionary.html">https://www.runoob.com/python/python-dictionary.html</a></li></ol><h3 id="7-日期与时间"><a href="#7-日期与时间" class="headerlink" title="7. 日期与时间"></a>7. 日期与时间</h3><p>Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。</p><p>时间间隔是以秒为单位的浮点小数。每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。</p><p><code>time.time()</code> 用于获取当前时间戳 </p><h4 id="struct-time元组"><a href="#struct-time元组" class="headerlink" title="struct_time元组"></a><code>struct_time</code>元组</h4><p>很多Python函数用一个元组装起来的9组数字处理时间:<br>html <div align="center"> <img src="https://img-blog.csdnimg.cn/f3c5757a142747c28166d8d1ede987e6.png " width="80%"> </div></p><h4 id="获取当前时间："><a href="#获取当前时间：" class="headerlink" title="获取当前时间："></a>获取当前时间：</h4><p>从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br> <br><span class="hljs-built_in">localtime</span> = <span class="hljs-type">time</span>.<span class="hljs-built_in">localtime</span>(<span class="hljs-type">time</span>.time())<br>print &quot;本地时间为 :&quot;, <span class="hljs-built_in">localtime</span><br></code></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">本地时间为 : time.struct_time(<span class="hljs-attribute">tm_year</span>=2016, <span class="hljs-attribute">tm_mon</span>=4, <span class="hljs-attribute">tm_mday</span>=7, <span class="hljs-attribute">tm_hour</span>=10, <span class="hljs-attribute">tm_min</span>=3, <span class="hljs-attribute">tm_sec</span>=27, <span class="hljs-attribute">tm_wday</span>=3, <span class="hljs-attribute">tm_yday</span>=98, <span class="hljs-attribute">tm_isdst</span>=0)<br></code></pre></td></tr></table></figure><h4 id="获取格式化的时间-asctime"><a href="#获取格式化的时间-asctime" class="headerlink" title="获取格式化的时间: asctime()"></a>获取格式化的时间: <code>asctime()</code></h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">localtime</span> = <span class="hljs-type">time</span>.asctime( <span class="hljs-type">time</span>.<span class="hljs-built_in">localtime</span>(<span class="hljs-type">time</span>.time()) )<br></code></pre></td></tr></table></figure><p>实例输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">本地时间为 : <span class="hljs-type">Thu</span> Apr  <span class="hljs-number">7</span> <span class="hljs-number">10</span>:<span class="hljs-number">05</span>:<span class="hljs-number">21</span> <span class="hljs-number">2016</span><br></code></pre></td></tr></table></figure><h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>使用 time 模块的 <code>strftime</code> 来格式化日期 :<br><code>time.strftime(format[, t])</code></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">import <span class="hljs-keyword">time</span><br> <br><span class="hljs-comment"># 格式化成2016-03-20 11:45:39形式</span><br><span class="hljs-keyword">print</span> time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()) <br> <br><span class="hljs-comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span><br><span class="hljs-keyword">print</span> time.strftime(<span class="hljs-string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>, time.localtime()) <br>  <br><span class="hljs-comment"># 将格式字符串转换为时间戳</span><br>a = <span class="hljs-string">&quot;Sat Mar 28 22:24:24 2016&quot;</span><br><span class="hljs-keyword">print</span> time.mktime(time.strptime(a,<span class="hljs-string">&quot;%a %b %d %H:%M:%S %Y&quot;</span>))<br></code></pre></td></tr></table></figure><p>日期格式化符号解释：<a href="https://www.runoob.com/python/python-date-time.html">https://www.runoob.com/python/python-date-time.html</a></p><h4 id="获取某月日历：引入calendar模块"><a href="#获取某月日历：引入calendar模块" class="headerlink" title="获取某月日历：引入calendar模块"></a>获取某月日历：引入<code>calendar</code>模块</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import calendar<br> <br>cal = calendar.month(2016, 1)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;以下输出2016年1月份的日历:&quot;</span><br><span class="hljs-built_in">print</span> cal<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">以下输出2016年1月份的日历:<br>    January 2016<br>Mo Tu We Th Fr Sa Su<br>            <span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span> 3<br><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span>10<br>11<span class="hljs-number"> 12 </span>13<span class="hljs-number"> 14 </span>15<span class="hljs-number"> 16 </span>17<br>18<span class="hljs-number"> 19 </span>20<span class="hljs-number"> 21 </span>22<span class="hljs-number"> 23 </span>24<br>25<span class="hljs-number"> 26 </span>27<span class="hljs-number"> 28 </span>29<span class="hljs-number"> 30 </span>31<br></code></pre></td></tr></table></figure><p>补充： python中关于时间和日期方面的模块有：<code>Time</code> 模块、<code>Calendar</code>模块、<code>datetime</code>模块、<code>pytz</code>模块、<code>dateutil</code>模块。<br>详细参考：<a href="https://www.runoob.com/python/python-date-time.html">https://www.runoob.com/python/python-date-time.html</a></p><h3 id="8-语句"><a href="#8-语句" class="headerlink" title="8. 语句"></a>8. 语句</h3><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false</p><ol><li>python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现。<br>如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">if 判断条件1</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句1……</span><br><span class="hljs-attribute">elif 判断条件2</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句2……</span><br><span class="hljs-attribute">elif 判断条件3</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">执行语句3……</span><br><span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>    执行语句4……<br></code></pre></td></tr></table></figure></li><li>也可以在同一行的位置上使用if条件判断语句<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> = <span class="hljs-number">100</span> <br> <br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">var</span>  == <span class="hljs-number">100</span> ) : <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;变量 var 的值为100&quot;</span> <br></code></pre></td></tr></table></figure></li></ol><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ol><li><p>基本语法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># while循环</span><br><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(<span class="hljs-built_in">statements</span>)……<br><br><span class="hljs-meta"># for循环</span><br><span class="hljs-keyword">for</span> iterating_var in sequence:<br>   statements(s)<br></code></pre></td></tr></table></figure></li><li><p>continue 用于跳过该次循环，break 则是用于退出循环。<br>此外”判断条件”还可以是个常值，表示循环必定成立。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># continue 和 break 用法</span><br> <br><span class="hljs-attribute">i</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">while</span> i &lt; <span class="hljs-number">10</span>:   <br>    <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> i%<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>:     # 非双数时跳过输出<br>        <span class="hljs-attribute">continue</span><br>    <span class="hljs-attribute">print</span> i         # 输出双数<span class="hljs-number">2</span>、<span class="hljs-number">4</span>、<span class="hljs-number">6</span>、<span class="hljs-number">8</span>、<span class="hljs-number">10</span><br> <br><span class="hljs-attribute">i</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">while</span> <span class="hljs-number">1</span>:            # 循环条件为<span class="hljs-number">1</span>必定成立<br>    <span class="hljs-attribute">print</span> i         # 输出<span class="hljs-number">1</span>~<span class="hljs-number">10</span><br>    <span class="hljs-attribute">i</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> i &gt; <span class="hljs-number">10</span>:     # 当i大于<span class="hljs-number">10</span>时跳出循环<br>        <span class="hljs-attribute">break</span><br></code></pre></td></tr></table></figure></li><li><p>无限循环：如果条件判断语句永远为 true，循环将会无限的执行下去<br>可以使用 <code>CTRL+C</code>来中断无限循环。</p></li><li><p>循环使用 else 语句</p></li></ol><ul><li>while … else 在循环条件为 false 时执行 else 语句块 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">count</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">count</span> &lt; <span class="hljs-number">5</span>:<br>   <span class="hljs-keyword">print</span> <span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; is  less than 5&quot;</span><br>   <span class="hljs-keyword">count</span> = <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> <span class="hljs-keyword">count</span>, <span class="hljs-string">&quot; is not less than 5&quot;</span><br></code></pre></td></tr></table></figure></li><li>for循环<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,<span class="hljs-built_in">num</span>): <span class="hljs-comment"># 根据因子迭代</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span>%i == <span class="hljs-number">0</span>:      <span class="hljs-comment"># 确定第一个因子</span><br>         j=<span class="hljs-built_in">num</span>/i          <span class="hljs-comment"># 计算第二个因子</span><br>         print (<span class="hljs-string">&#x27;%d 等于 %d * %d&#x27;</span> % (<span class="hljs-built_in">num</span>,i,j))<br>         break            <span class="hljs-comment"># 跳出当前循环</span><br>   <span class="hljs-keyword">else</span>:                  <span class="hljs-comment"># 循环的 else 部分</span><br>      print (<span class="hljs-string">&#x27;%d 是一个质数&#x27;</span> % <span class="hljs-built_in">num</span>)<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>简单语句组<br>如果while 循环体中只有一条语句，可以将该语句与while写在同一行中<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">flag = <span class="hljs-number">1</span><br> <br><span class="hljs-keyword">while</span> (flag): print <span class="hljs-symbol">&#x27;Given</span> flag <span class="hljs-keyword">is</span> really <span class="hljs-literal">true</span>!&#x27;<br></code></pre></td></tr></table></figure></li><li>通过序列索引迭代<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>,  <span class="hljs-string">&#x27;mango&#x27;</span>]<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">index</span> in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fruits)):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">&#x27;当前水果 : %s&#x27;</span> % fruits[<span class="hljs-built_in">index</span>])<br></code></pre></td></tr></table></figure></li></ol><h4 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h4><p> pass 是空语句，是为了保持程序结构的完整性，用做占位语句。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 输出 Python 的每个字母</span><br><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;Python&#x27;</span>:<br>   <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;h&#x27;</span>:<br>      pass<br>      <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;这是 pass 块&#x27;</span><br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;当前字母 :&#x27;</span>, letter<br></code></pre></td></tr></table></figure><h3 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9. 运算符"></a>9. 运算符</h3><h4 id="算术运算符（略）"><a href="#算术运算符（略）" class="headerlink" title="算术运算符（略）"></a>算术运算符（略）</h4><h4 id="比较运算符（略）"><a href="#比较运算符（略）" class="headerlink" title="比较运算符（略）"></a>比较运算符（略）</h4><h4 id="赋值运算符（略）"><a href="#赋值运算符（略）" class="headerlink" title="赋值运算符（略）"></a>赋值运算符（略）</h4><p>参考：<a href="https://www.runoob.com/python/python-operators.html">https://www.runoob.com/python/python-operators.html</a></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>按位运算符是把数字看作二进制来进行计算的</p><table><thead><tr><th>运算符</th><th>解释</th><th>作用</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符</td><td>参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td></tr><tr><td>I</td><td>按位或运算符</td><td>只要对应的二个二进位有一个为1时，结果位就为1</td></tr><tr><td>^</td><td>按位异或运算符</td><td>当两对应的二进位相异时，结果为1</td></tr><tr><td>~</td><td>按位取反运算符</td><td>对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符</td><td>运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符</td><td>把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li>and</li><li>or</li><li>not</li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><ul><li>in</li><li>not in<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = 10<br>list = [1, 2, 3, 4, 5 ];<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 在给定的列表中 list 中&quot;</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 不在给定的列表中 list 中&quot;</span><br> <br><span class="hljs-comment"># 修改变量 a 的值</span><br>a = 2<br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 在给定的列表中 list 中&quot;</span><br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;变量 a 不在给定的列表中 list 中&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h4><p>用于比较两个对象的存储单元(本质是判断指针)</p><ul><li>is</li><li>is not</li></ul><p>tips：<code>is 与 == 区别</code> :</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><h3 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h3><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params"> parameters </span>):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><ul><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>在 python 中，类型属于对象，变量是没有类型的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-attr">a</span>=<span class="hljs-string">&quot;Runoob&quot;</span><br></code></pre></td></tr></table></figure><p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p><ul><li><p>可更改(mutable)与不可更改(immutable)对象:<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><p>不可变类型：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</p></li><li><p>可变类型：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p></li></ul></li><li><p>python 函数的参数传递：</p><ul><li><p>不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</p></li><li><p>可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</p></li></ul></li><li><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p></li><li><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值<br>参数默认值在函数声明时设置</p></li></ul><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">def functionname([<span class="hljs-keyword">formal</span><span class="hljs-number">_</span>args,] *var<span class="hljs-number">_</span>args<span class="hljs-number">_</span>tuple ):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   <span class="hljs-keyword">function</span><span class="hljs-number">_</span>suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>加了星号（*）的变量名会存放所有未命名的变量参数<br>示例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta">def printinfo( arg1, *vartuple ):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;输出: &quot;</span><br>   <span class="hljs-keyword">print</span> arg1<br>   <span class="hljs-keyword">for</span> <span class="hljs-built_in">var</span> <span class="hljs-keyword">in</span> vartuple: <span class="hljs-meta">#哇哦，这里的for in体现出不定长的特性！！</span><br>      <span class="hljs-keyword">print</span> <span class="hljs-built_in">var</span><br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-meta"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><h4 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-built_in">lambda</span> [arg1 [,arg2,.....argn]]<span class="hljs-symbol">:expression</span><br></code></pre></td></tr></table></figure><ul><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。<br>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-keyword">lambda</span> arg1, arg2: arg1 + arg2<br> <br><span class="hljs-comment"># 调用sum函数</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;相加后的值为 : &quot;</span>, <span class="hljs-built_in">sum</span>( <span class="hljs-number">20</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">相加后的值为 :  30<br>相加后的值为 :  40<br></code></pre></td></tr></table></figure></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>全局变量</li><li>局部变量</li></ul><h3 id="11-python的版本迭代备注"><a href="#11-python的版本迭代备注" class="headerlink" title="11.python的版本迭代备注"></a>11.python的版本迭代备注</h3><h4 id="关于设置Python解释器的默认字符编码为UTF-8"><a href="#关于设置Python解释器的默认字符编码为UTF-8" class="headerlink" title="关于设置Python解释器的默认字符编码为UTF-8"></a>关于设置Python解释器的默认字符编码为UTF-8</h4><p>一些开源项目里面的python代码会写成：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> sys<br># 设置默认编码为UTF<span class="hljs-number">-8</span><br>sys.setdefaultencoding(<span class="hljs-string">&#x27;utf8&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但Python 3中已经移除了sys.setdefaultencoding()函数，因为它会导致潜在的问题，特别是与第三方库的兼容性。</p><p>在Python 3中，字符串默认使用Unicode编码（UTF-8），而且不再需要显式地设置默认编码,直接使用Unicode字符串而不用担心编码问题。</p><h4 id="decode-和encode"><a href="#decode-和encode" class="headerlink" title="decode( )和encode( )"></a>decode( )和encode( )</h4><p>在Python 3中，decode()方法用于将字节转换为字符串，而encode()方法用于将字符串转换为字节</p><h2 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1. 模块"></a>1. 模块</h3><p>Python 模块(Module)，是一个 Python 文件，以<code> .py</code> 结尾，包含了 Python 对象定义和Python语句。</p><p>模块能够有逻辑地组织Python 代码段。把相关的代码分配到一个模块里能让代码更好用，更易懂。</p><p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><h4 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">import</span> <span class="hljs-keyword">module</span><span class="hljs-number">1</span>[, <span class="hljs-keyword">module</span><span class="hljs-number">2</span>[,... moduleN]]<br></code></pre></td></tr></table></figure><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p><h4 id="搜索路径和环境变量"><a href="#搜索路径和环境变量" class="headerlink" title="搜索路径和环境变量"></a>搜索路径和环境变量</h4><p><a href="https://www.runoob.com/python/python-modules.html">https://www.runoob.com/python/python-modules.html</a></p><h4 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h4><p>命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。</p><p>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。如果要给函数内的全局变量赋值，必须使用 global 语句：<br><code>global VarName</code></p><h4 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h4><p>排好序的字符串列表，内容是一个模块里定义过的名字。<br>返回的列表容纳了在一个模块里定义的所有模块，变量和函数。</p><h4 id="globals-和-locals-函数、reload-函数"><a href="#globals-和-locals-函数、reload-函数" class="headerlink" title="globals() 和 locals() 函数、reload() 函数"></a>globals() 和 locals() 函数、reload() 函数</h4><p><a href="https://www.runoob.com/python/python-modules.html">https://www.runoob.com/python/python-modules.html</a></p><h4 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h4><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。</p><p>简单来说，包就是文件夹，但该文件夹下必须存在 <strong>init</strong>.py 文件, 该文件的内容可以为空。<strong>init</strong>.py 用于标识当前文件夹是一个包。<br>更多可以参考：<br><a href="https://www.runoob.com/python3/python3-module.html">https://www.runoob.com/python3/python3-module.html</a></p><h3 id="2-File-文件-方法"><a href="#2-File-文件-方法" class="headerlink" title="2.  File(文件) 方法"></a>2.  File(文件) 方法</h3><h4 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h4><ul><li>raw_input函数<br>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</li><li>input函数<br>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">str</span> = <span class="hljs-keyword">input</span>(<span class="hljs-string">&quot;请输入：&quot;</span>)<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;你输入的内容是: &quot;</span>, <span class="hljs-keyword">str</span><br></code></pre></td></tr></table></figure>示例：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">请输入：<span class="hljs-comment">[x*5 for x in range(2,10,2)]</span><br>你输入的内容是:  <span class="hljs-comment">[10, 20, 30, 40]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="打开、关闭和读写文件"><a href="#打开、关闭和读写文件" class="headerlink" title="打开、关闭和读写文件"></a>打开、关闭和读写文件</h4><ul><li><p>open函数 ：打开一个文件，创建一个file对象<br><code>file object = open(file_name ,[access_mode],[buffering])</code></p><ul><li>file_name：file_name变量是一个包含了你要访问的文件名称的字符串值</li><li>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)</li><li>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认</li></ul></li><li><p>File对象的属性</p></li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>file.closed</td><td>返回true如果文件已被关闭，否则返回false</td></tr><tr><td>file.mode</td><td>返回被打开文件的访问模式</td></tr><tr><td>file.name</td><td>返回文件的名称</td></tr><tr><td>file.softspace</td><td>如果用print输出后，必须跟一个空格符，则返回false；否则返回true</td></tr></tbody></table><ul><li><p>close（）函数<br><code>fileObject.close()</code> :<br>刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入</p></li><li><p>write()函数<br><code>fileObject.write(string)</code> :将字符串写入一个打开的文件</p><ul><li>Python字符串可以是二进制数据，而不是仅仅是文字。</li><li>write()方法不会在字符串的结尾添加换行符(‘\n’)。</li></ul></li><li><p>read()函数<br><code>fileObject.read([count])</code> :从一个打开的文件中读取一个字符串</p><ul><li>被传递的参数是要从已打开文件中读取的字节计数</li><li>从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾<br>示例：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"># 打开一个文件<br><span class="hljs-keyword">fo</span> = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-keyword">fo</span>.<span class="hljs-keyword">write</span>( <span class="hljs-string">&quot;www.runoob.com!\nVery good site!\n&quot;</span>)<br>str = <span class="hljs-keyword">fo</span>.<span class="hljs-keyword">read</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;读取的字符串是 : &quot;</span>, str<br># 关闭打开的文件<br><span class="hljs-keyword">fo</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure>运行结果 ：<code>读取的字符串是 :  www.runoob</code></li></ul></li></ul><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><ul><li><code>tell()</code> :返回文件内的当前位置，下一次的读写会发生在文件开头这么多字节之后</li><li><code>seek（offset,[from]）</code> :改变当前文件的位置<ul><li>offset变量表示要移动的字节数</li><li>from变量指定开始移动字节的参考位置</li><li>如果from设为0，将文件的开头作为移动字节的参考位置。<br>  如果设为1，则使用当前的位置作为参考位置。<br>  如果设为2，那么该文件的末尾将作为参考位置。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 打开一个文件</span><br>fo = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>)<br><span class="hljs-built_in">str</span> = fo.read(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;读取的字符串是 : &quot;</span>, <span class="hljs-built_in">str</span><br> <br><span class="hljs-comment"># 查找当前位置</span><br>position = fo.tell()<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;当前文件位置 : &quot;</span>, position<br> <br><span class="hljs-comment"># 把指针再次重新定位到文件开头</span><br>position = fo.seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">str</span> = fo.read(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;重新读取字符串 : &quot;</span>, <span class="hljs-built_in">str</span><br><span class="hljs-comment"># 关闭打开的文件</span><br>fo.close()<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">读取的字符串是 :  <span class="hljs-type">www.runoob</span><br>当前文件位置 :  10<br>重新读取字符串 :  <span class="hljs-type">www.runoob</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h4><p>Python的<code>os</code>模块提供了执行文件处理操作的方法，比如重命名和删除文件。</p><p>要使用这个模块，必须先 <code>import os</code>。</p><ul><li>os.rename(current_file_name, new_file_name)<br>重命名文件</li><li>os.remove(file_name)<br>删除文件</li></ul><h4 id="Python里的目录"><a href="#Python里的目录" class="headerlink" title="Python里的目录"></a>Python里的目录</h4><ul><li>os.mkdir(“newdir”)<br>在当前目录下创建新的目录</li><li>os.chdir(“newdir”)<br>改变当前的目录<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span><br> <br># 将当前目录改为<span class="hljs-string">&quot;/home/newdir&quot;</span><br><span class="hljs-built_in">os</span>.chdir(<span class="hljs-string">&quot;/home/newdir&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>os.getcwd()<br>显示当前的工作目录</li><li>os.rmdir(‘dirname’)<br>删除目录，目录名称以参数传递，目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br>更多参考：<a href="https://www.runoob.com/python/file-methods.html">https://www.runoob.com/python/file-methods.html</a></li></ul><h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4><p>用于简化资源管理的一种结构。它允许在代码块中打开一个资源（例如文件、网络连接、数据库连接等），并在使用完毕后自动关闭资源，无需显式地调用关闭方法。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> expression [<span class="hljs-keyword">as</span> <span class="hljs-built_in">variable</span>]:<br>    <span class="hljs-comment"># Code block using the resource</span><br></code></pre></td></tr></table></figure><ul><li><p>expression通常是一个返回可上下文管理器（context manager）的表达式，而可上下文管理器是一个具有<code>__enter__()</code>和<code>__exit__()</code>方法的对象。</p></li><li><p><code>__enter__()</code>方法在进入with代码块时被调用，它负责设置资源，例如打开文件或建立网络连接，并返回相关的资源对象。而<code>__exit__()</code>方法在退出with代码块时被调用，它负责释放资源，例如关闭文件或断开网络连接。</p></li></ul><p>在with语句块中可以使用资源对象，并在代码块执行完毕后，Python会自动调用<code>__exit__()</code>方法来释放资源，即使在代码块中发生了异常也会执行。这样可以确保资源的正确关闭，避免资源泄漏。</p><p>常见例子：使用with来打开文件</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(<span class="hljs-symbol">&#x27;example</span>.txt&#x27;, <span class="hljs-symbol">&#x27;r</span>&#x27;) as <span class="hljs-keyword">file</span>:<br>    content = <span class="hljs-keyword">file</span>.read()<br>    # Code <span class="hljs-keyword">block</span> <span class="hljs-keyword">to</span> work <span class="hljs-keyword">with</span> the <span class="hljs-keyword">file</span> content<br><br># <span class="hljs-keyword">After</span> exiting the <span class="hljs-symbol">&#x27;with</span>&#x27; <span class="hljs-keyword">block</span>, the <span class="hljs-keyword">file</span> <span class="hljs-keyword">is</span> automatically closed.<br></code></pre></td></tr></table></figure><p>在这个例子中，open()函数返回一个文件对象，它是一个上下文管理器。<code>with open(&#39;example.txt&#39;, &#39;r&#39;) as file:</code>会打开名为example.txt的文件，并将文件对象赋值给file变量。在代码块中，我们可以使用file对象读取文件内容。不论代码块是否抛出异常，with语句执行完毕后，文件对象会被自动关闭，无需显式调用file.close()方法。</p><h4 id="readline-函数"><a href="#readline-函数" class="headerlink" title="readline( )函数"></a>readline( )函数</h4><p>用于从文件对象中逐行读取数据，用于读取文件的一行内容，并返回一个字符串，包含了该行的内容（包括行尾的换行符 \n）。<br>每次调用readline()，都会读取文件当前位置的下一行，并将文件指针移动到下一行的开头，直到文件末尾。</p><p>当文件对象的指针移动到文件末尾后，再次调用readline()会返回空字符串，表示文件已经读取完毕。因此，在使用readline()时，通常使用循环来逐行读取文件的内容，直到返回空字符串为止，标志文件的末尾。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:<br>    <span class="hljs-built_in">line</span> = <span class="hljs-built_in">file</span>.readline()<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">line</span>:<br>        print(<span class="hljs-built_in">line</span>.strip())  <span class="hljs-comment"># Remove the newline characters</span><br>        <span class="hljs-built_in">line</span> = <span class="hljs-built_in">file</span>.readline()<br></code></pre></td></tr></table></figure><h4 id="strip-函数"><a href="#strip-函数" class="headerlink" title="strip()函数"></a>strip()函数</h4><p>用于去除字符串首尾的指定字符（默认是空格和换行符）或空白字符。它返回一个新的字符串，该字符串是去除了首尾指定字符后的原始字符串。</p><p>语法格式：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">string</span>.strip([<span class="hljs-keyword">chars</span>])<br></code></pre></td></tr></table></figure><p>其中，string是要操作的字符串，而chars是可选参数，用于指定需要去除的字符集合。如果不提供chars参数，则默认去除字符串首尾的空白字符（空格、制表符、换行符等）。</p><p>示例：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span> = <span class="hljs-string">&quot;   Hello, world!   &quot;</span><br><span class="hljs-literal">result</span> = <span class="hljs-built_in">text</span>.strip()  <span class="hljs-comment"># Removes leading and trailing whitespaces</span><br>print(<span class="hljs-literal">result</span>)  <span class="hljs-comment"># Output: &quot;Hello, world!&quot;</span><br><br>text2 = <span class="hljs-string">&quot;----Hello, world!---&quot;</span><br>result2 = text2.strip(<span class="hljs-string">&quot;-&quot;</span>)  <span class="hljs-comment"># Removes leading and trailing dashes</span><br>print(result2)  <span class="hljs-comment"># Output: &quot;Hello, world!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3. 内置函数"></a>3. 内置函数</h3><p><a href="https://www.runoob.com/python/python-built-in-functions.html">https://www.runoob.com/python/python-built-in-functions.html</a></p><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h3><h4 id="try…-except…else"><a href="#try…-except…else" class="headerlink" title="try….except…else"></a>try….except…else</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">try:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#运行别的代码</span><br>except <span class="hljs-variable">&lt;名字&gt;</span>：<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果在try部份引发了&#x27;name&#x27;异常</span><br>except <span class="hljs-variable">&lt;名字&gt;</span>，<span class="hljs-variable">&lt;数据&gt;</span>:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span><br>else:<br><span class="hljs-variable">&lt;语句&gt;</span>        <span class="hljs-comment">#如果没有异常发生</span><br></code></pre></td></tr></table></figure><ul><li><p>当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p></li><li><p>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</p></li><li><p>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</p></li><li><p>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</p></li></ul><h4 id="使用except而不带任何异常类型"><a href="#使用except而不带任何异常类型" class="headerlink" title="使用except而不带任何异常类型"></a>使用except而不带任何异常类型</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except:<br>    发生异常，执行这块代码<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br><span class="hljs-keyword">else</span>:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><h4 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except(Exception1<span class="hljs-meta">[</span>, Exception2<span class="hljs-meta">[</span>,<span class="hljs-params">...</span>ExceptionN<span class="hljs-meta">]</span>]):<br>   发生以上多个异常中的一个，执行这块代码<br>   ......................<br>else:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><h4 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h4><p>无论是否发生异常都将执行最后的代码</p><h4 id="异常的参数"><a href="#异常的参数" class="headerlink" title="异常的参数"></a>异常的参数</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">try:<br>    正常的操作<br>   <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>except ExceptionType, Argument:<br>    你可以在这输出 Argument 的值<span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>一个异常可以带上参数，可作为输出的异常信息参数。<br>可以通过except语句来捕获异常的参数。</p><ul><li>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。元组通常包含错误字符串，错误数字，错误位置。</li></ul><h4 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h4><p><code>raise [Exception, [args,[traceback]]]</code></p><ul><li>Exception 是异常的类型（例如，NameError）参数标准异常中任一种</li><li>args 是自已提供的异常参数</li><li>最后一个参数是可选的（在实践中很少使用），如果存在，跟踪异常对象<br>示例：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def functionName( <span class="hljs-keyword">level</span> ):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">level</span> &lt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> <span class="hljs-keyword">Exception</span>(&quot;Invalid level!&quot;, <span class="hljs-keyword">level</span>)<br>        # 触发异常后，后面的代码就不会再执行<br></code></pre></td></tr></table></figure>tips：为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。</li></ul><p>例如我们捕获以上异常，”except”语句如下所示：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">try</span>:<br>    正常逻辑<br><span class="hljs-keyword">except</span> Exception,err:<br>    触发自定义异常    <br><span class="hljs-keyword">else</span>:<br>    其余代码<br></code></pre></td></tr></table></figure><h4 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h4><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。<br><a href="https://www.runoob.com/python/python-exceptions.html">https://www.runoob.com/python/python-exceptions.html</a></p><h3 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h3><p><a href="https://blog.csdn.net/zhaofuxiang/article/details/53379394">https://blog.csdn.net/zhaofuxiang/article/details/53379394</a></p><h3 id="6-推导式"><a href="#6-推导式" class="headerlink" title="6.推导式"></a>6.推导式</h3><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体</p><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[表达式 for 变量 in 列表]</span> <br><span class="hljs-string">[out_exp_res for out_exp in input_list]</span><br><br>或者 <br><span class="hljs-string"></span><br><span class="hljs-string">[表达式 for 变量 in 列表 if 条件]</span><br><span class="hljs-string">[out_exp_res for out_exp in input_list if condition]</span><br></code></pre></td></tr></table></figure><ul><li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li><li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li><li>if condition：条件语句，可以过滤列表中不符合条件的值。</li></ul><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; key_expr: value_expr for value in collection &#125;<br><br>或<br><br>&#123; key_expr: value_expr for value in collection if condition &#125;<br></code></pre></td></tr></table></figure><h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">&#123; expression for item in Sequence &#125;</span><br>或<br><span class="hljs-comment">&#123; expression for item in Sequence if conditional &#125;</span><br></code></pre></td></tr></table></figure><h4 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h4><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(expression for item in Sequence )</span><br>或<br><span class="hljs-comment">(expression for item in Sequence if conditional )</span><br></code></pre></td></tr></table></figure><p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 ( ) 圆括号将各部分括起来，而列表推导式用的是中括号 [ ]，另外元组推导式返回的结果是一个生成器对象。</p><h3 id="7-面向对象"><a href="#7-面向对象" class="headerlink" title="7. 面向对象"></a>7. 面向对象</h3><p>面向对象的基本特征：</p><ul><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。<code>对象是类的实例</code>。</li><li>方法：类中定义的函数。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h4 id="类的定义和实例化对象"><a href="#类的定义和实例化对象" class="headerlink" title="类的定义和实例化对象"></a>类的定义和实例化对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span><br>    i = <span class="hljs-number">12345</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br> <br><span class="hljs-comment"># 实例化类</span><br>x = MyClass()<br> <br><span class="hljs-comment"># 访问类的属性和方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())<br></code></pre></td></tr></table></figure><p>类有一个名为&#96;&#96; <strong>init</strong>()&#96; 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.data = []<br></code></pre></td></tr></table></figure><p>类的实例化操作会自动调用 <code>__init__()</code> 方法。例如<code>x = MyClass()</code>时，对应的 <code>__init__()</code> 方法就会被调用。</p><ul><li><strong>init</strong>() 方法可以有参数，参数通过 <strong>init</strong>() 传递到类的实例化操作上：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Complex:<br>    <span class="hljs-attribute">def</span> __init__(self, realpart, imagpart):<br>        <span class="hljs-attribute">self</span>.r = realpart<br>        <span class="hljs-attribute">self</span>.i = imagpart<br><span class="hljs-attribute">x</span> = Complex(<span class="hljs-number">3</span>.<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>.<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span>(x.r, x.i)   # 输出结果：<span class="hljs-number">3</span>.<span class="hljs-number">0</span> -<span class="hljs-number">4</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li>self代表类的实例，而非类;类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>派生类的定义：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">class DerivedClassName(BaseClassName):<br>    &lt;statement-<span class="hljs-number">1</span>&gt;<br>    .<br>    .<br>    .<br>    &lt;statement-N&gt;<br></code></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><ul><li>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-title">modname</span>.<span class="hljs-type">BaseClassName</span>):</span><br></code></pre></td></tr></table></figure>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(self,n,a,w)<br>        self.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))<br> <br> <br>s = student(<span class="hljs-string">&#x27;ken&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">3</span>)<br>s.speak()<br></code></pre></td></tr></table></figure></li></ul><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>定义形式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">DerivedClassName</span>(<span class="hljs-type">Base1</span>, <span class="hljs-type">Base2</span>, <span class="hljs-type">Base3</span>):</span><br><span class="hljs-class">    &lt;statement-1&gt;</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    .</span><br><span class="hljs-class">    &lt;statement-<span class="hljs-type">N</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。<br>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>:<br>    <span class="hljs-comment">#定义基本属性</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义私有属性,私有属性在类外部无法直接进行访问</span><br>    __weight = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w</span>):<br>        self.name = n<br>        self.age = a<br>        self.__weight = w<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))<br> <br><span class="hljs-comment">#单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>(<span class="hljs-title class_ inherited__">people</span>):<br>    grade = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g</span>):<br>        <span class="hljs-comment">#调用父类的构函</span><br>        people.__init__(self,n,a,w)<br>        self.grade = g<br>    <span class="hljs-comment">#覆写父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))<br> <br><span class="hljs-comment">#另一个类，多继承之前的准备</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">speaker</span>():<br>    topic = <span class="hljs-string">&#x27;&#x27;</span><br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,t</span>):<br>        self.name = n<br>        self.topic = t<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))<br> <br><span class="hljs-comment">#多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sample</span>(speaker,student):<br>    a =<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n,a,w,g,t</span>):<br>        student.__init__(self,n,a,w,g)<br>        speaker.__init__(self,n,t)<br> <br>test = sample(<span class="hljs-string">&quot;Tim&quot;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">80</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;Python&quot;</span>)<br>test.speak()   <span class="hljs-comment">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span><br></code></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>:        <span class="hljs-comment"># 定义父类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用父类方法&#x27;</span>)<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_">Parent</span>): <span class="hljs-comment"># 定义子类</span><br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>      print (<span class="hljs-string">&#x27;调用子类方法&#x27;</span>)<br> <br>c = <span class="hljs-title class_">Child</span>()          <span class="hljs-comment"># 子类实例</span><br>c.myMethod()         <span class="hljs-comment"># 子类调用重写方法</span><br><span class="hljs-variable language_">super</span>(<span class="hljs-title class_">Child</span>,c).myMethod() <span class="hljs-comment">#用子类对象调用父类已被覆盖的方法</span><br></code></pre></td></tr></table></figure><p>super() 函数是用于调用父类(超类)的一个方法。</p><h4 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h4><p>__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</p><h4 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h4><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。</p><p>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。</p><p>类的私有方法<br><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。</p><p>小结：<br>类的专有方法：</p><ul><li><code>__init__</code>: 构造函数，在生成对象时调用</li><li><code>__del__</code> : 析构函数，释放对象时使用</li><li><code>__repr__ </code>: 打印，转换</li><li><code>__setitem__ </code>: 按照索引赋值</li><li><code>__getitem__</code>: 按照索引获取值</li><li><code>__len__</code>: 获得长度</li><li><code>__cmp__</code>: 比较运算</li><li><code>__call__</code>: 函数调用</li><li><code>__add__</code>: 加运算</li><li><code>__sub__</code>: 减运算</li><li><code>__mul__</code>: 乘运算</li><li><code>__truediv__</code>: 除运算</li><li><code>__mod__</code>: 求余运算</li><li><code>__pow__</code>: 乘方</li></ul><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>可以对类的专有方法进行重载</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#!/usr/bin/python3<br> <br><span class="hljs-keyword">class</span> Vector:<br>   def <span class="hljs-constructor">__init__(<span class="hljs-params">self</span>, <span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>:<br>      self.a = a<br>      self.b = b<br> <br>   def <span class="hljs-constructor">__str__(<span class="hljs-params">self</span>)</span>:<br>      return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b)<br>   <br>   def <span class="hljs-constructor">__add__(<span class="hljs-params">self</span>,<span class="hljs-params">other</span>)</span>:<br>      return <span class="hljs-constructor">Vector(<span class="hljs-params">self</span>.<span class="hljs-params">a</span> + <span class="hljs-params">other</span>.<span class="hljs-params">a</span>, <span class="hljs-params">self</span>.<span class="hljs-params">b</span> + <span class="hljs-params">other</span>.<span class="hljs-params">b</span>)</span><br> <br>v1 = <span class="hljs-constructor">Vector(2,10)</span><br>v2 = <span class="hljs-constructor">Vector(5,-2)</span><br>print (v1 + v2)<br></code></pre></td></tr></table></figure><p>运行结果：<code>Vector(7,8)</code></p><h3 id="8-迭代器和生成器"><a href="#8-迭代器和生成器" class="headerlink" title="8.迭代器和生成器"></a>8.迭代器和生成器</h3><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</p><ul><li><p>迭代器是一个可以记住遍历的位置的对象,从集合的第一个元素开始访问,直到所有的元素被访问完结束,只能往前不会后退。</p></li><li><p>迭代器有两个基本的方法：iter() 和 next()。</p></li><li><p>字符串，列表或元组对象都可用于创建迭代器</p></li></ul><h4 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h4><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">it = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">list</span>)    <span class="hljs-comment"># 创建迭代器对象</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span></span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> (<span class="hljs-built_in">next</span>(it))</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span><br></code></pre></td></tr></table></figure><h4 id="常规遍历迭代器"><a href="#常规遍历迭代器" class="headerlink" title="常规遍历迭代器"></a>常规遍历迭代器</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">it</span> = iter(<span class="hljs-built_in">list</span>)     <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-keyword">it</span>:        <span class="hljs-comment"># 使用for遍历</span><br>    print (x, <span class="hljs-keyword">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">import sys          <span class="hljs-comment"># 引入 sys 模块</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)     <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> True:         <span class="hljs-comment"># 使用while循环和next()进行遍历</span><br>    try:<br>        print (<span class="hljs-keyword">next</span>(it))<br>    except StopIteration:<br>        sys.<span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><h4 id="创建一个类作为迭代器"><a href="#创建一个类作为迭代器" class="headerlink" title="创建一个类作为迭代器"></a>创建一个类作为迭代器</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__() </code>与<code> __next__()</code> 。<br><code>__iter__() </code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code> __next__()</code>方法并通过 StopIteration 异常标识迭代的完成。</p><p><code> __next__()</code> 方法会返回下一个迭代器对象。</p><p>示例：创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    x = <span class="hljs-variable language_">self</span>.a<br>    <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br> <br>myclass = <span class="hljs-title class_">MyNumbers</span>()<br>myiter = iter(myclass)<br> <br>print(<span class="hljs-keyword">next</span>(myiter))<br>print(<span class="hljs-keyword">next</span>(myiter))<br></code></pre></td></tr></table></figure><p>结果：<code>1 2</code></p><h4 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h4><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>示例:在 20 次迭代后停止执行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumbers</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-variable language_">self</span>.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br> <br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.a &lt;= <span class="hljs-number">20</span>:<br>      x = <span class="hljs-variable language_">self</span>.a<br>      <span class="hljs-variable language_">self</span>.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-symbol">else:</span><br>      <span class="hljs-keyword">raise</span> <span class="hljs-title class_">StopIteration</span><br> <br>myclass = <span class="hljs-title class_">MyNumbers</span>()<br>myiter = iter(myclass)<br> <br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-symbol">myiter:</span><br>  print(x)<br></code></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p><p>生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">yield</span> n<br>        n -= <span class="hljs-number">1</span><br> <br><span class="hljs-comment"># 创建生成器对象</span><br>generator = countdown(<span class="hljs-number">5</span>)<br> <br><span class="hljs-comment"># 通过迭代生成器获取值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: 3</span><br> <br><span class="hljs-comment"># 使用 for 循环迭代生成器</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(value)  <span class="hljs-comment"># 输出: 2 1</span><br></code></pre></td></tr></table></figure><p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。</p><h3 id="9-多线程"><a href="#9-多线程" class="headerlink" title="9. 多线程"></a>9. 多线程</h3><h3 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10. 正则表达式"></a>10. 正则表达式</h3><h4 id="正则表达式的概念"><a href="#正则表达式的概念" class="headerlink" title="正则表达式的概念"></a>正则表达式的概念</h4><p><a href="https://www.runoob.com/regexp/regexp-intro.html">https://www.runoob.com/regexp/regexp-intro.html</a></p><h4 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h4><p>典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>例如，你可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p><p> <strong>python中正则表达式的实现</strong></p><h4 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h4><p>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none（匹配成功re.match方法返回一个匹配的对象，否则返回None）</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">re.<span class="hljs-keyword">match</span>(<span class="hljs-built_in">pattern</span>, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td></tr></tbody></table><p><strong><a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></strong></p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="hljs-comment"># 在起始位置匹配</span><br><span class="hljs-comment"># span()函数作用：返回匹配值的下标</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;com&#x27;</span>, <span class="hljs-string">&#x27;www.runoob.com&#x27;</span>))         <span class="hljs-comment"># 不在起始位置匹配</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hy">(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>稍微复杂一点的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>line = <span class="hljs-string">&quot;Cats are smarter than dogs&quot;</span><br><span class="hljs-comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span><br><span class="hljs-comment"># (.*?) 表示&quot;非贪婪&quot;模式，只保存第一个匹配到的子串</span><br>matchObj = re.<span class="hljs-keyword">match</span>( <span class="hljs-string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)<br> <br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group() : &quot;</span>, matchObj.group())<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="hljs-number">1</span>))<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;No match!!&quot;</span>)<br></code></pre></td></tr></table></figure><p>实例执行结果:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>() :  Cats are smarter than dogs<br><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>(<span class="hljs-number">1</span>) :  Cats<br><span class="hljs-built_in">match</span>Obj.<span class="hljs-keyword">group</span>(<span class="hljs-number">2</span>) :  smarter<br></code></pre></td></tr></table></figure><p>解释：<br>代码尝试从 line 中匹配一个子串，该子串的规则如下：</p><p>捕获 “are” 前面的内容和 “are” 后面的内容。在正则表达式中，括号用于创建分组，以便后续可以通过 matchObj.group(1) 和 matchObj.group(2) 来获取这两个匹配的内容。</p><p>对于给定的 line &#x3D; “Cats are smarter than dogs” 这个例子：</p><p>“Cats” 匹配 (.<em>)，并保存在分组 1 中。<br>“are” 匹配 “are”。<br>“smarter” 匹配 (.</em>?)，并保存在分组 2 中。<br>所以，最终成功匹配的结果是：</p><p>matchObj.group() : Cats are smarter than dogs：整个匹配的字符串。<br>matchObj.group(1) : Cats：匹配到的第一个分组，即 “are” 前面的内容 “Cats”。<br>matchObj.group(2) : smarter：匹配到的第二个分组，即 “are” 后面的内容 “smarter”。</p><h4 id="re-search函数"><a href="#re-search函数" class="headerlink" title="re.search函数"></a>re.search函数</h4><p>扫描整个字符串并返回第一个成功的匹配</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.search(pattern, string, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><ul><li>re.match与re.search的区别<br>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</li></ul><h4 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.sub(pattern, repl, string, <span class="hljs-attribute">count</span>=0, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul><p>前三个为必选参数，后两个为可选参数。</p><p>repl 参数是一个函数的情况：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">import re<br> <br><span class="hljs-meta"># 将匹配的数字乘以 2</span><br>def <span class="hljs-built_in">double</span>(matched):<br>    value = <span class="hljs-built_in">int</span>(matched.<span class="hljs-keyword">group</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(value * <span class="hljs-number">2</span>)<br> <br>s = <span class="hljs-string">&#x27;A23G4HFD567&#x27;</span><br><span class="hljs-keyword">print</span>(re.sub(<span class="hljs-string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, <span class="hljs-built_in">double</span>, s))<br></code></pre></td></tr></table></figure><h4 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h4><p>用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">re<span class="hljs-selector-class">.compile</span>(pattern<span class="hljs-selector-attr">[, flags]</span>)<br></code></pre></td></tr></table></figure><h4 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h4><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">re<span class="hljs-selector-class">.findall</span>(pattern, string, flags=<span class="hljs-number">0</span>)<br>或<br>pattern<span class="hljs-selector-class">.findall</span>(string<span class="hljs-selector-attr">[, pos[, endpos]</span>])<br></code></pre></td></tr></table></figure><ul><li>pattern 匹配模式。</li><li>string 待匹配的字符串。</li><li>pos 可选参数，指定字符串的起始位置，默认为 0。</li><li>endpos 可选参数，指定字符串的结束位置，默认为字符串的长度<br>示例：</li></ul><ol><li>查找字符串中的所有数字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>result1 = re.findall(<span class="hljs-string">r&#x27;\d+&#x27;</span>,<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br> <br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)   <span class="hljs-comment"># 查找数字</span><br>result2 = pattern.findall(<span class="hljs-string">&#x27;runoob 123 google 456&#x27;</span>)<br>result3 = pattern.findall(<span class="hljs-string">&#x27;run88oob123google456&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br> <br><span class="hljs-built_in">print</span>(result1)<br><span class="hljs-built_in">print</span>(result2)<br><span class="hljs-built_in">print</span>(result3)<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;123</span>&#x27;, <span class="hljs-symbol">&#x27;456</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;123</span>&#x27;, <span class="hljs-symbol">&#x27;456</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;88</span>&#x27;, <span class="hljs-symbol">&#x27;12</span>&#x27;]<br></code></pre></td></tr></table></figure></li><li>多个匹配模式，返回元组列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>result = re.findall(<span class="hljs-string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="hljs-string">&#x27;set width=20 and height=10&#x27;</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>运行结果：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[(<span class="hljs-symbol">&#x27;width</span>&#x27;, <span class="hljs-symbol">&#x27;20</span>&#x27;), (<span class="hljs-symbol">&#x27;height</span>&#x27;, <span class="hljs-symbol">&#x27;10</span>&#x27;)]<br></code></pre></td></tr></table></figure></li></ol><h4 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h4><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.finditer(pattern, string, <span class="hljs-attribute">flags</span>=0)<br></code></pre></td></tr></table></figure><h4 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h4><p>按照能够匹配的子串将字符串分割后返回列表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.split(pattern, string[, <span class="hljs-attribute">maxsplit</span>=0, <span class="hljs-attribute">flags</span>=0])<br></code></pre></td></tr></table></figure><ul><li>maxsplit分割次数，maxsplit&#x3D;1 分割一次，默认为 0，不限制次数。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>)<br>[<span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;(\W+)&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;, &#x27;</span>, <span class="hljs-string">&#x27;runoob&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;\W+&#x27;</span>, <span class="hljs-string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="hljs-number">1</span>) <br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;runoob, runoob, runoob.&#x27;</span>]<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">&#x27;a*&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>)   <span class="hljs-comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br>[<span class="hljs-string">&#x27;hello world&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="导入自己写的Python文件作为自定义库"><a href="#导入自己写的Python文件作为自定义库" class="headerlink" title="导入自己写的Python文件作为自定义库"></a>导入自己写的Python文件作为自定义库</h3><p>只需要将需要引用的函数或变量定义在一个.py文件中，然后在其他.py文件中通过import语句导入即可。</p><p>注意，当你导入一个自定义库时，Python会执行该库中的所有顶层代码。这意味着如果在自定义库中有一些不是函数或类定义的代码，它们也将会被执行。因此，最好将不需要立即执行的代码放在条件语句中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># my_custom_library.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_numbers</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>custom_variable = <span class="hljs-string">&quot;This is a custom variable.&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 这里的代码只有在直接运行 my_custom_library.py 文件时才会执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is executed only when running my_custom_library.py directly.&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="import导入一个库"><a href="#import导入一个库" class="headerlink" title="import导入一个库"></a>import导入一个库</h4><ul><li>可以通过库的名称引用库中的类:</li></ul><p>例如，假设有一个名为my_module.py的Python文件，其中定义了一个类MyClass，你可以使用以下方式引用这个类：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># 导入my_module库</span><br><span class="hljs-keyword">import</span> my_module<br><br><span class="hljs-meta"># 创建MyClass的实例</span><br><span class="hljs-title">obj</span> = my_module.<span class="hljs-type">MyClass</span>()<br><br><span class="hljs-meta"># 调用MyClass的方法</span><br><span class="hljs-title">obj</span>.some_method()<br></code></pre></td></tr></table></figure><ul><li>另一种方式是使用from关键字，这样你可以直接使用类名，而不需要使用库名称来引用类：<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"># 从my_module库导入<span class="hljs-keyword">MyClass</span>类<br><span class="hljs-keyword">from</span> my_module import <span class="hljs-keyword">MyClass</span><br><br># 创建<span class="hljs-keyword">MyClass</span>的实例<br>obj = <span class="hljs-keyword">MyClass</span>()<br><br># 调用<span class="hljs-keyword">MyClass</span>的方法<br>obj.some_method()<br></code></pre></td></tr></table></figure></li></ul><h3 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h3><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h3 id="使用python进行GUI设计"><a href="#使用python进行GUI设计" class="headerlink" title="使用python进行GUI设计"></a>使用python进行GUI设计</h3><h3 id="使用-Python-语言来编码和解码-JSON-对象"><a href="#使用-Python-语言来编码和解码-JSON-对象" class="headerlink" title="使用 Python 语言来编码和解码 JSON 对象"></a>使用 Python 语言来编码和解码 JSON 对象</h3><h3 id="使用python进行AI绘画"><a href="#使用python进行AI绘画" class="headerlink" title="使用python进行AI绘画"></a>使用python进行AI绘画</h3>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习指南</title>
    <link href="/2023/07/26/Git-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/26/Git-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>常用的Git命令整理</p><span id="more"></span> <h3 id="拷贝仓库"><a href="#拷贝仓库" class="headerlink" title="拷贝仓库"></a>拷贝仓库</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;url</span>&gt; [directory]<br></code></pre></td></tr></table></figure><p>url为git仓库地址，directory为本地目录</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>git branch：列出你在本地的分支</li><li>git branch  branchname：创建分支</li><li>git merge branchname：将任意分支合并到到当前分支中，branchname为需要合并的分支</li><li>git branch -d (branchname)：删除分支</li><li>git log –-oneline：查看简洁的历史记录</li><li>git log –graph ：查看历史中什么时候出现了分支、合并</li><li>git checkout:<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git checkout .              <span class="hljs-comment">#放弃工作区中全部的修改</span><br>git checkout -- filename    <span class="hljs-comment">#放弃工作区中某个文件的修改</span><br><br>git checkout <span class="hljs-keyword">branchname </span>    <span class="hljs-comment">#切换分支</span><br>git checkout -<span class="hljs-keyword">b </span>(<span class="hljs-keyword">branchname)#创建新分支并立即切换到该分支下</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li>git remote：查看当前的远程仓库</li><li>git pull：提取远程仓仓库</li><li>git push：推送到远程仓库</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">head</span>       <span class="hljs-comment">#当前版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>^      <span class="hljs-comment">#回退到上一个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>^^     <span class="hljs-comment">#回退到上上一个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>~<span class="hljs-string">3</span>     <span class="hljs-comment">#回退到往上3个版本</span><br><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>~<span class="hljs-string">10</span>    <span class="hljs-comment">#回退到往上10个版本</span><br></code></pre></td></tr></table></figure><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3><ul><li>git config：配置用户名和邮箱地址<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;你的用户名&#x27;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&#x27;你的邮箱&#x27;</span><br></code></pre></td></tr></table></figure></li><li>git status -s：查看相关文件的状态<ul><li>M - 被修改</li><li>A - 被添加</li><li>D - 被删除</li><li>R - 重命名</li><li>?? - 未被跟踪</li></ul></li><li>git add：将文件添加到缓存<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> .       <span class="hljs-comment">#添加所有文件到缓存</span><br><span class="hljs-keyword">it</span> <span class="hljs-built_in">add</span> *.java   <span class="hljs-comment">#添加某一类文件到缓存</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用好GitHub桌面和网页端"><a href="#使用好GitHub桌面和网页端" class="headerlink" title="使用好GitHub桌面和网页端"></a>使用好GitHub桌面和网页端</h3><p>相对复杂的：合并冲突，远程新建&#x2F;删除仓库等操作可以在桌面和网页版完成，更清楚简单。</p><p>更多可以参考：<br><a href="https://blog.csdn.net/qtiao/article/details/97783243">https://blog.csdn.net/qtiao/article/details/97783243</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>some tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openCV学习指南</title>
    <link href="/2023/07/26/openCV%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/26/openCV%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>一些opencv的函数积累，还有传统opencv处理项目的流程整理</p><span id="more"></span> <h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><h3 id="pnp解算"><a href="#pnp解算" class="headerlink" title="pnp解算"></a>pnp解算</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">bool solvePnP(InputArray objectPoints, InputArray imagePoints, <br>               InputArray cameraMatrix, InputArray distCoeffs, <br>               OutputArray rvec, OutputArray tvec, bool <span class="hljs-attribute">useExtrinsicGuess</span>=<span class="hljs-literal">false</span>, <br>               int <span class="hljs-attribute">flags</span>=ITERATIVE )<br></code></pre></td></tr></table></figure><p>函数solvepnp接收一组对应的3D坐标和2D坐标，计算得到两组坐标对应的几何变换（旋转矩阵rvec，平移矩阵tvec）,从而建立相机拍摄2D图像中物体坐标和3D世界坐标系中物体坐标的映射关系。</p><h3 id="重映射"><a href="#重映射" class="headerlink" title="重映射"></a>重映射</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec,<br>                   InputArray cameraMatrix, InputArray distCoeffs, <br>                   OutputArray imagePoints, OutputArray <span class="hljs-attribute">jacobian</span>=noArray(), <br>                   double <span class="hljs-attribute">aspectRatio</span>=0 )                  <br></code></pre></td></tr></table></figure><p>根据所给的3D坐标和已知的几何变换来求解投影后的2D坐标</p><h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><h3 id="同时标定两个摄像头"><a href="#同时标定两个摄像头" class="headerlink" title="同时标定两个摄像头"></a>同时标定两个摄像头</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">double stereoCalibrate(<span class="hljs-title class_">InputArrayOfArrays</span> objectPoints, <span class="hljs-title class_">InputArrayOfArrays</span> imagePoints1,<br>　　　　　　　　　　　　　<span class="hljs-title class_">InputArrayOfArrays</span> imagePoints2, <br>                       <span class="hljs-title class_">InputOutputArray</span> cameraMatrix1,<span class="hljs-title class_">InputOutputArray</span> distCoeffs1, <br>                       <span class="hljs-title class_">InputOutputArray</span> cameraMatrix2, <span class="hljs-title class_">InputOutputArray</span> distCoeffs2, <br>                       <span class="hljs-title class_">Size</span> imageSize,<span class="hljs-title class_">OutputArray</span> R,<span class="hljs-title class_">OutputArray</span> T, <span class="hljs-title class_">OutputArray</span> E, <br>                       <span class="hljs-title class_">OutputArray</span> F,<br>                       <span class="hljs-title class_">TermCriteria</span>  criteria=<span class="hljs-title class_">TermCriteria</span>(<span class="hljs-title class_">TermCriteria</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:COUNT+TermCriteria</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:EPS</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1e-6</span>),<br>                       int flags=<span class="hljs-variable constant_">CALIB_FIX_INTRINSIC</span> )<br></code></pre></td></tr></table></figure><p>能够求出两个摄像头的内外参数矩阵，还能够得出两个摄像头的位置关系R,T</p><h3 id="立体矫正"><a href="#立体矫正" class="headerlink" title="立体矫正"></a>立体矫正</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, <br>                   InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, <br>                   InputArray R, InputArray T,OutputArray R1, OutputArray R2, <br>                   OutputArray P1, OutputArray P2,OutputArray Q, <br>                   int <span class="hljs-attribute">flags</span>=CALIB_ZERO_DISPARITY, double <span class="hljs-attribute">alpha</span>=-1,<br>                   Size <span class="hljs-attribute">newImageSize</span>=Size(), Rect* <span class="hljs-attribute">validPixROI1</span>=0, <br>                   Rect* <span class="hljs-attribute">validPixROI2</span>=0 )<br></code></pre></td></tr></table></figure><p>计算每个摄像机(实际上)的旋转矩阵，从而使两个摄像机图像平面成为同一平面。因此，这使得所有的外极线平行，从而简化了稠密立体对应问题。</p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="预处理流程"><a href="#预处理流程" class="headerlink" title="预处理流程"></a>预处理流程</h3><p>常规步骤：</p><ul><li><p>图像颜色空间转换：RGB2HSV</p><ul><li>原因：HSV中的H表示色调，S表示饱和度，V表示亮度。不同颜色在HSV空间有严格的分量范围，从而将颜色进行量化。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mat imgHSV;<br>cvt<span class="hljs-constructor">Color(<span class="hljs-params">imgOriginal</span>, <span class="hljs-params">imgHSV</span>, COLOR_BGR2HSV)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>直方图均衡化(三个通道各自均衡化再组合)</p><ul><li>目的：通过拉伸像素强度分布范围来增强图像对比度，利于后面的二值化处理。</li><li>效果对比：<img src="/images/opencv/p2.png" alt="直方图均衡化效果对比"></li><li>代码：  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">vector&lt;Mat&gt; hsvSplit;<br><span class="hljs-built_in">split</span>(imgHSV, hsvSplit);                    <span class="hljs-comment">//通道分离</span><br><span class="hljs-built_in">equalizeHist</span>(hsvSplit[<span class="hljs-number">2</span>], hsvSplit[<span class="hljs-number">2</span>]);     <span class="hljs-comment">//通道各自均衡化</span><br><span class="hljs-built_in">merge</span>(hsvSplit, imgHSV);                    <span class="hljs-comment">//通道合并</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>阈值处理</p><ul><li>目的：图像进行目标分割，可用于目标检测、图像增强等。</li><li>常用的阈值处理办法：<br>  <code>二值化阈值处理</code>：threshold函数，大于阈值设为最大值，小于就是0。(最简单但是感觉不太好用，轮廓提取不明显。)<br>  <code>自适应阈值处理</code>:根据图像的局部特征，自动确定每个像素点的阈值，能够在不同光照条件下得到更好的效果。(但是不能筛选特定颜色的轮廓目标，可以区分背景和前景)<br>  <code>双阈值化操作</code>：将在两个阈值内的像素值设置为白色（255），而不在阈值区间内的像素值设置为黑色（0），可以用来筛选指定颜色的物体。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mat imgThresholded;<br><span class="hljs-keyword">in</span><span class="hljs-constructor">Range(<span class="hljs-params">imgHSV</span>, LOWERB, UPPERB, <span class="hljs-params">imgThresholded</span>)</span>;    <span class="hljs-comment">//双阈值化操作</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>开闭操作：</p><ul><li>目的：<br>  <code>开运算</code>：先腐蚀后膨胀，用于消除细小物体、在窄区域分离物体、平滑大物体边界。<br>  <code>闭运算</code>：先膨胀后腐蚀，用于填充物体空洞、消除噪声、连接邻近物体、平滑边界。</li><li>代码：  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//得到一个矩形卷积核</span><br>Mat element = get<span class="hljs-constructor">StructuringElement(MORPH_RECT, Size(8, 8)</span>);<br><span class="hljs-comment">//闭操作，填充物体空洞</span><br>morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_CLOSE, <span class="hljs-params">element</span>)</span>;<br>dilate(imgThresholded, imgThresholded, <span class="hljs-number">300</span><span class="hljs-operator"> * </span><span class="hljs-number">300</span>, <span class="hljs-constructor">Point(-1, -1)</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//开操作，去除噪点</span><br>morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_OPEN, <span class="hljs-params">element</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="轮廓修复"><a href="#轮廓修复" class="headerlink" title="轮廓修复"></a>轮廓修复</h3><p>预处理的逻辑比较通用，但是在实际光线和物体呈现角度的因素影响下，预处理得到的轮廓是不太好的，比如圆可能识别出来是个月牙、形状被分割成好几个物体、正方形可能只识别了一个多边形的轮廓，并没有完整的被抠出来等等，这样的预处理效果不足以用于后续的轮廓判断，因此需要进行轮廓修复。</p><ul><li>修复效果图：<img src="/images/opencv/p1.png" alt="轮廓修复"></li></ul><h4 id="凸包检测-多边形填充-闭运算"><a href="#凸包检测-多边形填充-闭运算" class="headerlink" title="凸包检测+多边形填充+闭运算"></a>凸包检测+多边形填充+闭运算</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">Contours(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">contour</span>, <span class="hljs-params">hierarchy</span>, RETR_EXTERNAL, CHAIN_APPROX_TC89_KCOS)</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; contour.size<span class="hljs-literal">()</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//凸包检测</span><br>        convex<span class="hljs-constructor">Hull(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">hull</span>, <span class="hljs-params">false</span>, <span class="hljs-params">true</span>)</span>;<br>        <span class="hljs-comment">//凸包填充</span><br>        fill<span class="hljs-constructor">Poly(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">hull</span>, Scalar(255, 255, 255)</span>);<br>        <span class="hljs-comment">//闭操作，填充空洞</span><br>        morphology<span class="hljs-constructor">Ex(<span class="hljs-params">imgThresholded</span>, <span class="hljs-params">imgThresholded</span>, MORPH_CLOSE, <span class="hljs-params">element</span>)</span>;<br>        dilate(imgThresholded, imgThresholded, <span class="hljs-number">770</span><span class="hljs-operator"> * </span><span class="hljs-number">770</span>, <span class="hljs-constructor">Point(-1, -1)</span>, <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="轮廓判断"><a href="#轮廓判断" class="headerlink" title="轮廓判断"></a>轮廓判断</h3><p>整体逻辑很简单，使用多边形拟合得到轮廓的边数信息，再与目标形状的边数进行比对判断是否为所求形状。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector&lt;vector&lt;Point&gt;&gt; contour;<br>vector&lt;Vec4i&gt; hierarchy;<br>find<span class="hljs-constructor">Contours(<span class="hljs-params">imgPre</span>, <span class="hljs-params">contour</span>, <span class="hljs-params">hierarchy</span>, RETR_EXTERNAL, CHAIN_APPROX_TC89_KCOS)</span>;<br><br>vector&lt;vector&lt;Point&gt;&gt; con<span class="hljs-constructor">Poly(<span class="hljs-params">contour</span>.<span class="hljs-params">size</span>()</span>);<br>vector&lt;Rect&gt; bound<span class="hljs-constructor">Rect(<span class="hljs-params">contour</span>.<span class="hljs-params">size</span>()</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; contour.size<span class="hljs-literal">()</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">string</span> objectType;<span class="hljs-comment">//形状</span><br>    <span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span>;<br>    <span class="hljs-keyword">if</span> (area &lt; <span class="hljs-number">6000</span>)<br>        continue;<br><br>    <span class="hljs-built_in">float</span> peri = arc<span class="hljs-constructor">Length(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">true</span>)</span>;<br>    approx<span class="hljs-constructor">PolyDP(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>], <span class="hljs-params">conPoly</span>[<span class="hljs-params">i</span>], 0.02 <span class="hljs-operator">*</span> <span class="hljs-params">peri</span>, <span class="hljs-params">true</span>)</span>;<span class="hljs-comment">//光滑曲线折线化</span><br>    boundRect<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = bounding<span class="hljs-constructor">Rect(<span class="hljs-params">conPoly</span>[<span class="hljs-params">i</span>])</span>;<br><br>    <span class="hljs-built_in">int</span> objCor = (<span class="hljs-built_in">int</span>)conPoly<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.size<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (objCor != SHAPE<span class="hljs-operator"> &amp;&amp; </span>SHAPE !=<span class="hljs-number">5</span>) continue;<span class="hljs-comment">//不找圆形的时候，边数非目标</span><br>    <span class="hljs-keyword">if</span> (objCor &lt; SHAPE<span class="hljs-operator"> &amp;&amp; </span>SHAPE<span class="hljs-operator"> == </span><span class="hljs-number">5</span>)continue;<span class="hljs-comment">//找圆形的时候，排除其余形状</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;FIND!!!&quot;</span>&lt;&lt;objCor&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但是现实情况往往更复杂，以下为笔者在轮廓识别的过程中进行的优化：<ul><li><code>圆度检测</code>：<br> 其他图像可能在轮廓修复和开闭操作之后，棱角不明显，接近圆形，从而导致误识别，因此引入圆度检测。  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">if</span><span class="hljs-constructor">Circle(<span class="hljs-params">vector</span>&lt;Point&gt;<span class="hljs-params">contour</span>)</span> &#123;<br><span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>)</span>;                    <span class="hljs-comment">//计算轮廓面积</span><br><span class="hljs-built_in">float</span> len = arc<span class="hljs-constructor">Length(<span class="hljs-params">contour</span>, <span class="hljs-params">true</span>)</span>;               <span class="hljs-comment">//计算轮廓周长</span><br><span class="hljs-built_in">float</span> roundness = (<span class="hljs-number">4</span><span class="hljs-operator"> * </span>CV_PI<span class="hljs-operator"> * </span>area)<span class="hljs-operator"> / </span>(len<span class="hljs-operator"> * </span>len); <span class="hljs-comment">//计算圆度</span><br>    <span class="hljs-comment">// cout &lt;&lt; &quot;未确定圆的圆度：&quot; &lt;&lt; roundness &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (roundness &lt; <span class="hljs-number">0.92</span>) &#123;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;没过检测，圆度：&quot; &lt;&lt; roundness &lt;&lt; endl;</span><br>    return <span class="hljs-literal">false</span>;<br>&#125;<br>return <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>矩形检测</code>：圆形在预处理之后，有概率被误识别为矩形；为更好的区分矩形和圆形，引入矩形检测。 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">if</span><span class="hljs-constructor">Rect(<span class="hljs-params">vector</span>&lt;Point&gt;<span class="hljs-params">contour</span>)</span> &#123;<br> <span class="hljs-built_in">float</span> rectangularity;<br> <span class="hljs-comment">//计算最小外接矩形的面积：</span><br> RotatedRect minrect = min<span class="hljs-constructor">AreaRect(<span class="hljs-params">contour</span>)</span>;     <span class="hljs-comment">//最小外接矩形</span><br> <span class="hljs-built_in">int</span> area = contour<span class="hljs-constructor">Area(<span class="hljs-params">contour</span>)</span>;                <span class="hljs-comment">//计算轮廓面积</span><br> <span class="hljs-built_in">int</span> Sminrect = minrect.size.height<span class="hljs-operator"> * </span>minrect.size.width;<br> <span class="hljs-keyword">if</span> (Sminrect<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) rectangularity = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">else</span> rectangularity = (<span class="hljs-built_in">float</span>)area<span class="hljs-operator"> / </span>Sminrect;<br> <span class="hljs-comment">// cout &lt;&lt; &quot;矩形度：&quot;&lt;&lt;rectangularity&lt;&lt;&quot;最小外接矩形面积：&quot;&lt;&lt; Sminrect&lt;&lt;&quot;轮廓面积:&quot; &lt;&lt; area &lt;&lt; endl;</span><br> <span class="hljs-keyword">if</span> (rectangularity &lt;<span class="hljs-number">0.86</span>)return <span class="hljs-literal">false</span>;<br> return <span class="hljs-literal">true</span>;<br> &#125;<br><br> *************在轮廓函数中，采用矩形度和圆度双重检测，有效提高矩形的识别精确度****************<br><br> <span class="hljs-keyword">if</span> (objCor<span class="hljs-operator"> == </span><span class="hljs-number">4</span>) &#123;<br>         <span class="hljs-comment">//矩形度检测</span><br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">if</span><span class="hljs-constructor">Circle(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span> ! <span class="hljs-keyword">if</span><span class="hljs-constructor">Rect(<span class="hljs-params">contour</span>[<span class="hljs-params">i</span>])</span>) &#123;</span><br><span class="hljs-pattern-match">             cout &lt;&lt; &quot;矩形没过检测！！&quot; &lt;&lt; endl;</span><br><span class="hljs-pattern-match">             continue;</span><br><span class="hljs-pattern-match">         &#125;;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="在图片上进行标记"><a href="#在图片上进行标记" class="headerlink" title="在图片上进行标记"></a>在图片上进行标记</h3><h4 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawContours</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">InputOutputArray image,</span></span><br><span class="hljs-params"><span class="hljs-function">InputArrayOfArrays contours,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> contourIdx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> Scalar&amp; color,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> thickness=<span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> lineType=<span class="hljs-number">8</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">InputArray hierarchy = noArray(),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> maxLevel = INT_MAX,</span></span><br><span class="hljs-params"><span class="hljs-function">Point offset = Point() )</span></span>;<br></code></pre></td></tr></table></figure><h4 id="框出目标物体"><a href="#框出目标物体" class="headerlink" title="框出目标物体"></a>框出目标物体</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> cv::<span class="hljs-variable constant_">rectangle</span> (InputOutputArray img, Point pt1, Point pt2, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Scalar</span> &amp;color, <span class="hljs-keyword">int</span> thickness=<span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> lineType=LINE_8, <span class="hljs-keyword">int</span> shift=<span class="hljs-number">0</span>)<br>***或者****<br><span class="hljs-keyword">void</span> cv::<span class="hljs-variable constant_">rectangle</span> (InputOutputArray img, Rect rec, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Scalar</span> &amp;color, <span class="hljs-keyword">int</span> thickness=<span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> lineType=LINE_8, <span class="hljs-keyword">int</span> shift=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="标注点"><a href="#标注点" class="headerlink" title="标注点"></a>标注点</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//标注矩形顶点</span><br><span class="hljs-built_in">for</span>(int j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<br>circle(img, conPoly[i][j], <span class="hljs-number">3</span>, Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">120</span>), -<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="计算点的坐标"><a href="#计算点的坐标" class="headerlink" title="计算点的坐标"></a>计算点的坐标</h3><h4 id="找圆点"><a href="#找圆点" class="headerlink" title="找圆点"></a>找圆点</h4><ul><li>霍夫检测（我感觉很难调参而且精度不太行）</li><li>最小二乘法拟合圆（没试过，但是据说可以，就是得自己造轮子）</li><li>先识别得到一个圆度大于0.9的圆，再找最小外接矩形，矩形中点即为圆心（有点偷奸耍滑，但是几何上说得通嘿嘿）<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">CircleCenter(Mat <span class="hljs-params">img</span>, Rect <span class="hljs-params">rect</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> x = rect.width<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> y = rect.height<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    Point Radius = <span class="hljs-constructor">Point(<span class="hljs-params">rect</span>.<span class="hljs-params">x</span> + <span class="hljs-params">x</span>, <span class="hljs-params">rect</span>.<span class="hljs-params">y</span> + <span class="hljs-params">y</span>)</span>;<br>    circle(img, Radius, <span class="hljs-number">3</span>, <span class="hljs-constructor">Scalar(0, 255, 120)</span>, -<span class="hljs-number">1</span>);<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="找矩形的四个顶点"><a href="#找矩形的四个顶点" class="headerlink" title="找矩形的四个顶点"></a>找矩形的四个顶点</h4><p>只要通过矩形检测，四边形就是矩形啦。多边形拟合之后的那个conpoly就是矩形的角点点集。</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMakeLists 学习指南</title>
    <link href="/2023/07/25/CMakeLists-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2023/07/25/CMakeLists-%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>CMake是一个元（meta）构建系统，可用于为许多其他构建工具创建构建文件。<br>三天速通！结合UGAS的CMakeLists食用更香捏！</p><span id="more"></span> <h4 id="上交教程："><a href="#上交教程：" class="headerlink" title="上交教程："></a>上交教程：</h4><p><a href="https://sjtu-robomaster-team.github.io/vision-learning-4-cmake-introduction/">https://sjtu-robomaster-team.github.io/vision-learning-4-cmake-introduction/</a></p><h4 id="完整教程："><a href="#完整教程：" class="headerlink" title="完整教程："></a>完整教程：</h4><p><a href="https://zhuanlan.zhihu.com/p/367808125">https://zhuanlan.zhihu.com/p/367808125</a></p><h4 id="核心语法："><a href="#核心语法：" class="headerlink" title="核心语法："></a>核心语法：</h4><p><a href="https://zhuanlan.zhihu.com/p/368701263">https://zhuanlan.zhihu.com/p/368701263</a></p><h3 id="速览：处理多源文件目录的方法"><a href="#速览：处理多源文件目录的方法" class="headerlink" title="速览：处理多源文件目录的方法"></a>速览：<code>处理多源文件目录的方法</code></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<br><br><span class="hljs-keyword">project</span> (hello_headers)<br><span class="hljs-comment">#设置了项目的名字为 hello_headers</span><br><br><span class="hljs-keyword">set</span>(SOURCES<br>    src/Hello.cpp<br>    src/main.cpp<br>)<br><span class="hljs-comment">#set 指令创建了一个变量，第一个参数为变量名 `SOURCES`，后面的参数就是这个变量所指代的内容</span><br><br><span class="hljs-keyword">add_executable</span>(hello_headers <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><span class="hljs-comment"># $&#123;SOURCES&#125; 使用前面创建的变量来代替要进行编译的文件。</span><br><span class="hljs-comment"># hello_headers 指明了生成可执行文件需要的资源文件</span><br><span class="hljs-comment">#PRIVATE 关键字。</span><br><br><span class="hljs-keyword">target_include_directories</span>(hello_headers<br>    PRIVATE <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br><span class="hljs-comment">#添加编译需要用到的头文件,hello_headers指明了需要的头文件的目录</span><br><span class="hljs-comment">#$&#123;PROJECT_SOURCE_DIR&#125;指明include文件所在的文件夹路径。(include文件夹所在的目录。)</span><br></code></pre></td></tr></table></figure><ul><li>关键字有三种，PRIVATE | PUBLIC | INTERFACE，不同的关键字在进行CMake编译后会生成不同的include 文件夹</li><li>在CMake中，变量的使用都是 ${变量名} 这种格式。</li><li>除了README.md文件是用来讲解的文件外，另外几个文件都是要进行编译的。</li><li>${PROJECT_SOURCE_DIR}指当前项目的顶级(上级)源目录,则在编写程序时引用include里面的头文件可以直接写头文件名，不用写相对路径了</li><li>${CMAKE_CXX_FLAGS} C++编译器的编译选项。具体常用选项有：<ul><li><code>-rdynamic</code> 通知链接器将所有符号添加到动态符号表，通过使用 dlopen 来实现向后跟踪</li><li><code>-O3</code> 开启优化</li><li><code>-fPIC</code> 编译器产生与位置无关代码，即产生的代码中全部使用相对地址</li><li><code>-ggdb</code> 编译器生成gdb专用的更为丰富的调试信息</li><li><code>-std=c++11</code></li><li><code>-Wall</code> 编译后显示所有警告<br>  （还有一些不太常用的，网址自查：<a href="https://blog.csdn.net/m0_51551385/article/details/125083575?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8=%EF%BC%89">https://blog.csdn.net/m0_51551385/article/details/125083575?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D）</a></li></ul></li></ul><p><code>编译指令：</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> build<br><br><span class="hljs-keyword">cd</span> build<br><br>cmake ..<br><br><span class="hljs-keyword">make</span><br></code></pre></td></tr></table></figure><p>编译完成后，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hello_headers<br></code></pre></td></tr></table></figure><p>就可以运行程序文件。</p><h3 id="高级点的语法："><a href="#高级点的语法：" class="headerlink" title="高级点的语法："></a>高级点的语法：</h3><h4 id="递归搜索所有的-cpp文件并将列表存储在一个变量中"><a href="#递归搜索所有的-cpp文件并将列表存储在一个变量中" class="headerlink" title="递归搜索所有的.cpp文件并将列表存储在一个变量中:"></a>递归搜索所有的.cpp文件并将列表存储在一个变量中:</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">file(GLOB_RECURSE UGAS_SOURCE CONFIGURE_DEPENDS<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/src/</span>*.cpp<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/src/</span>*.cc)<br></code></pre></td></tr></table></figure><ul><li><code>CONFIGURE_DEPENDS</code><br>告知 CMake 有关配置过程的其他输入文件的信息。如果修改了任何命名文件，生成系统将重新运行 CMake 以重新配置文件并再次生成生成系统。<br>将文件指定为以分号分隔的路径列表。</li><li><code>configure_file</code>：通过读取输入文件中的内容，将 CMakeLists.txt 文件中的变量转变为 C&#x2F;C++ 中可识别的宏定义，然后存入输出文件中。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">configure<span class="hljs-constructor">_file(&lt;<span class="hljs-params">input</span>&gt; &lt;<span class="hljs-params">output</span>&gt;)</span><br></code></pre></td></tr></table></figure>具体参考：<a href="https://zhuanlan.zhihu.com/p/436923370">https://zhuanlan.zhihu.com/p/436923370</a></li></ul><p>输入文件为 xxx（目录路径）-config.h.in<br>输出文件为 xxx-config.h</p><h4 id="选项开关："><a href="#选项开关：" class="headerlink" title="选项开关："></a>选项开关：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">option</span><span class="hljs-params">(&lt;OPTION_NAME&gt; <span class="hljs-string">&quot;&lt;help_text&gt;&quot;</span> [value])</span></span><br></code></pre></td></tr></table></figure><p>第一个参数为选项名称。此选项不仅可以是boolean，也可以是string或list。</p><p>第二个参数为选项介绍，为string。</p><p>第三个参数为选项默认值，依据选项类型设置。</p><ul><li>条件分支：<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">if</span> (CONDITION_1)<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">elseif</span> (CONDITION_2)<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-meta"># do something</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></li></ul><h4 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a><code>find_package</code></h4><p>查找并载入一个外部包</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">find_package(&lt;PackageName&gt; <span class="hljs-comment">[version]</span> <span class="hljs-comment">[EXACT]</span> <span class="hljs-comment">[QUIET]</span> <span class="hljs-comment">[MODULE]</span><br>             <span class="hljs-comment">[REQUIRED]</span> <span class="hljs-comment">[<span class="hljs-comment">[COMPONENTS]</span> <span class="hljs-comment">[components...]</span>]</span><br>             <span class="hljs-comment">[OPTIONAL_COMPONENTS components...]</span><br>             <span class="hljs-comment">[NO_POLICY_SCOPE]</span>)<br></code></pre></td></tr></table></figure><p>最常用用法:<br>find_package(OpenCV 4.7 REQUIRED) <br>find_package(HikCameraSDK REQUIRED)<br>查找名为 XX 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。</p><ul><li>include_directories<br>cmake使用 include_directories是用来 提供搜索头文件路径</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">include_directories (<span class="hljs-selector-attr">[AFTER|BEFORE]</span> <span class="hljs-selector-attr">[SYSTEM]</span> dir1 <span class="hljs-selector-attr">[dir2 ...]</span>)<br></code></pre></td></tr></table></figure><h4 id="在ROS2环境下编译："><a href="#在ROS2环境下编译：" class="headerlink" title="在ROS2环境下编译："></a>在ROS2环境下编译：</h4><ul><li>生成目标文件，并且不需要再使用target_link_libraries  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ament_auto_add_executable</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">ament_auto_add_library</span><br></code></pre></td></tr></table></figure></li><li><code>ament_auto_find_build_dependencies</code><br>  ROS2环境下的链接库方式，相当于不用写find_package了。（ROS之前连接库的指令）</li><li><code>ament_auto_package</code><br>  这个用来代替以前的export（导出库）和两次install（安装库），以及最后的ament_package</li></ul><ul><li><code>link_directories</code><br>链接库；添加需要链接的库文件路径之后就可以使用相对路径，使用TARGET_LINK_LIBRARIES时，只需给出动态链接库名即可。</li><li><code>target_link_libraries </code><ul><li>如果所有目标都使用相关的include目录，则需要使用link_libraries;<br>如果路径是特定于目标，就用target_link_libraries </li><li>如果所有目标都使用相关的include目录，则需要使用link_libraries；<br>如果路径是特定于目标，就用target_link_libraries</li></ul></li></ul><ol start="6"><li><code>DEBUG</code>时使用的命令：</li></ol><ul><li><p>打印变量信息</p><ul><li>SET(USER_KEY, “Hello World”)\</li></ul></li></ul><p>#设置变量</p><ul><li>MESSAGE( STATUS “this var key &#x3D; ${USER_KEY}.”)</li><li>message([<mode>] “message text” …)</mode></li></ul><p>UGAS的CMakeLists.txt参考：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.12</span>)<br><span class="hljs-keyword">project</span>(ugas VERSION <span class="hljs-number">1.0</span> LANGUAGES C CXX)<br><br><span class="hljs-comment"># Set compilation flags</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_C_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -O3&quot;</span>)<br><br><span class="hljs-keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="hljs-keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Clang&quot;</span>)<br>    <span class="hljs-keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">set</span>(CMAKE_MODULE_PATH <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cmake)<br><br><span class="hljs-comment"># Set configure_file</span><br><span class="hljs-keyword">set</span> (CONFIGURE_DIR_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/config)<br><span class="hljs-keyword">configure_file</span> (<br>        <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/config.h.in&quot;</span><br>        <span class="hljs-string">&quot;$&#123;CONFIGURE_DIR_PATH&#125;/config.h&quot;</span>)<br><br><span class="hljs-comment"># Initialize custom options</span><br><span class="hljs-keyword">option</span> (ENABLE_DEBUG_CANVAS <span class="hljs-string">&quot;Enable debug canvas to draw debug image&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_RECORDING <span class="hljs-string">&quot;Enable recording of raw camera image&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_OPENVINO <span class="hljs-string">&quot;Enable openvino to identify buff&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span> (ENABLE_ROS <span class="hljs-string">&quot;Enable ROS to visualize positions&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-comment"># Set the output executable file name:</span><br><span class="hljs-comment"># When compiling in the ROS environment, the output executable file name will be the node name.</span><br><span class="hljs-comment"># Otherwise, the output file name will be the project name.</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_NAME main)<br><span class="hljs-keyword">else</span> ()<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br>    <span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Find non-ros packages</span><br><span class="hljs-keyword">find_package</span>(OpenCV <span class="hljs-number">4.7</span> REQUIRED)<br><span class="hljs-keyword">find_package</span>(HikCameraSDK REQUIRED)<br><br><span class="hljs-keyword">if</span> (ENABLE_OPENVINO)<br>    <span class="hljs-keyword">find_package</span>(OpenVINO REQUIRED)<br>    <span class="hljs-keyword">set</span>(OpenVINO_LIB openvino::runtime)<br><span class="hljs-keyword">endif</span> (ENABLE_OPENVINO)<br><br><span class="hljs-comment"># Include project source directory</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src <span class="hljs-variable">$&#123;CONFIGURE_DIR_PATH&#125;</span>)<br><br><span class="hljs-comment"># Recursively search for all source files under the &#x27;src&#x27; folder and store them into UGAS_SOURCE variable</span><br><span class="hljs-comment"># Flag &#x27;CONFIGURE_DEPENDS&#x27; asks cmake to detect GLOB result changes so no need to rerun cmake when adding a new source file.</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE UGAS_SOURCE CONFIGURE_DEPENDS<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp<br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cc)<br><br><span class="hljs-comment"># Find ros packages &amp; add source files to compilation</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    <span class="hljs-keyword">find_package</span> (ament_cmake_auto REQUIRED)<br>    ament_auto_find_build_dependencies ()<br>    ament_auto_add_executable(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;UGAS_SOURCE&#125;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;UGAS_SOURCE&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Link libraries</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;EXECUTABLE_NAME&#125;</span> <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span> <span class="hljs-variable">$&#123;HikCameraSDK_LIB&#125;</span> <span class="hljs-variable">$&#123;OpenVINO_LIB&#125;</span> -lpthread)<br><br><span class="hljs-comment"># Install package</span><br><span class="hljs-keyword">if</span> (ENABLE_ROS)<br>    ament_auto_package()<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="使用ninja构建"><a href="#使用ninja构建" class="headerlink" title="使用ninja构建"></a>使用ninja构建</h3><h4 id="概念——生成器"><a href="#概念——生成器" class="headerlink" title="概念——生成器"></a>概念——生成器</h4><p>CMake生成器负责为底层构建系统编写输入文件(例如Makefile)。<br>运行<code>cmake--help</code>将显示可用的生成器。<br>CMake包括不同类型的生成器，如命令行生成器、IDE生成器和其他生成器。</p><ol><li>命令行生成工具生成器<br>这些生成器用于命令行构建工具，如Make和Ninja。</li><li>IDE构建工具生成器<br>这些生成器用于集成开发环境，其中包括它们自己的编译器。例如Visual Studio和Xcode，它们本身就包含一个编译器。</li><li>其他生成器<br>这些生成器创建配置并与其他IDE工具共同工作，并且必须包含在IDE或命令行生成器中。</li></ol><table><thead><tr><th>Note</th><th>在本例中，ninja是通过命令sudo apt-get install ninja-build安装的。</th></tr></thead></table><h4 id="调用生成器"><a href="#调用生成器" class="headerlink" title="调用生成器"></a>调用生成器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> cmake .. <span class="hljs-literal">-G</span> Ninja<br><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>build.ninja  CMakeCache.txt  CMakeFiles  cmake_install.cmake  rules.ninja<br></code></pre></td></tr></table></figure><p>CMake将生成所需的Ninja构建文件，这些文件可以通过使用Ninja命令运行。</p><h4 id="实例：使用Ninja编译UGAS"><a href="#实例：使用Ninja编译UGAS" class="headerlink" title="实例：使用Ninja编译UGAS"></a>实例：使用Ninja编译UGAS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/ros2_ws/src &amp; <span class="hljs-built_in">cd</span> ~/ros2_ws                   <span class="hljs-comment">#创建工作区文件夹</span><br><span class="hljs-built_in">cp</span> -r ~/Desktop/UGAS ./src/ugas                         <span class="hljs-comment">#拷贝目录</span><br>colcon build --packages-select ugas --cmake-args  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DENABLE_ROS=ON -GNinja<br><span class="hljs-built_in">source</span> ./install/local_setup.bash                       <span class="hljs-comment">#配置该功能包环境</span><br>ros2 run ugas main                                      <span class="hljs-comment">#运行一个节点</span><br></code></pre></td></tr></table></figure><p>tips:</p><ul><li>colcon：使用colcon构建ros包，相当于ros1中的catkin工具</li><li>cp -r Dir&#x2F; &#x2F;home&#x2F;test ：将Dir目录copy到test目录下</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu使用技巧</title>
    <link href="/2023/07/25/Ubuntu%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/07/25/Ubuntu%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>一些使用技巧和操作命令整理合集</p><span id="more"></span> <h3 id="在-Ubuntu-Linux-上安装-Deb-文件的-3-种方法"><a href="#在-Ubuntu-Linux-上安装-Deb-文件的-3-种方法" class="headerlink" title="在 Ubuntu Linux 上安装 Deb 文件的 3 种方法"></a>在 Ubuntu Linux 上安装 <code>Deb</code> 文件的 3 种方法</h3><blockquote><ol><li>使用软件中心安装</li><li>使用命令行安装：</li></ol></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">sudo apt install path<span class="hljs-emphasis">_to_deb_file</span><br><span class="hljs-emphasis">或者</span><br><span class="hljs-emphasis">sudo dpkg -i path_to_deb_</span>file<br></code></pre></td></tr></table></figure><p>在这两个命令中，使用已下载的 deb 文件的路径和名称来替换 path_to_deb_file 。</p><h3 id="关于权限和存储"><a href="#关于权限和存储" class="headerlink" title="关于权限和存储"></a>关于权限和存储</h3><p>访问权限：</p><ul><li><p>读取 <code>r</code> ：数字表示 4，允许查看、下载文件内容、显示目录列表；</p></li><li><p>写入 <code>w</code> ：数字表示 2，允许修改文件内容，允许在目录中新建、移动、删除文件或子目录；</p></li><li><p>可执行 <code>x</code> ：数字表示 1，允许运行程序、切换目录。</p></li></ul><p>归属（所有权）</p><ul><li>属主：拥有该文件或目录的用户帐号；</li><li>属组：拥有该文件或目录的组帐号。</li></ul><p>操作对象</p><pre><code class="hljs">u 文件属主权限g 同组用户权限o 其它用户权限a 所有用户（包括以上三种）s（setuid）：该位是让普通用户可以以 root 用户的角色运行只有 root 帐号才能运行的程序或命令</code></pre><p>权限设定</p><pre><code class="hljs">+ 增加权限- 取消权限= 设置权限</code></pre><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><h4 id="相对路径的表现形式"><a href="#相对路径的表现形式" class="headerlink" title="相对路径的表现形式"></a>相对路径的表现形式</h4><ul><li>绝对路径：从 &#x2F; （根目录）为起点的路径。</li><li>相对路径：以当前目录为起点（当前文件所在的路径相对于其它文件或文件夹的路径关系）。</li></ul><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>直接使用目录名或文件名</td><td>表示当前工作目录中的子目录、文件的位置</td></tr><tr><td>.开头</td><td>表示以当前的工作目录作为起点，如 .&#x2F;etc</td></tr><tr><td>..开头</td><td>表示以当前目录的上一级目录（父目录）作为起点，如 ..&#x2F;etc</td></tr><tr><td>以 “~用户名” 形式开头</td><td>表示以指定用户名的宿主目录作为起点</td></tr><tr><td>以 “~” 形式开头</td><td>表示以当前用户的宿主目录作为起点</td></tr></tbody></table><h4 id="cd-命令"><a href="#cd-命令" class="headerlink" title="cd 命令"></a><code>cd</code> 命令</h4><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>cd&#x2F;</td><td>切换到系统根目录</td></tr><tr><td>cd~或cd</td><td>切换到当前用户的宿主目录（家目录）</td></tr><tr><td>cd-</td><td>切换到 上一次执行cd命令 之前所在的目录</td></tr></tbody></table><h4 id="ls-命令：用于显示指定工作目录下的文件及子目录"><a href="#ls-命令：用于显示指定工作目录下的文件及子目录" class="headerlink" title="ls 命令：用于显示指定工作目录下的文件及子目录"></a><code>ls</code> 命令：用于显示指定工作目录下的文件及子目录</h4><p>可使用命令 ls –help、man ls 查看所有参数。</p><p><a href="https://blog.csdn.net/duanbaoke/article/details/115462030">https://blog.csdn.net/duanbaoke/article/details/115462030</a></p><blockquote><p>3.1  通配符:参数可结合通配符一起使用。</p></blockquote><table><thead><tr><th>命令行</th><th>说明</th></tr></thead><tbody><tr><td>？</td><td>代表任意一个字符，只能占一个字符；</td></tr><tr><td>*</td><td>代表任意数个字符，可以是0个或多个；</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任意一个字符，每个通配符只匹配一次，多个通配符可一起使用，不区分大小写。如ls [abc]，ls [a-c]，ls [1ab][1ab]。</td></tr></tbody></table><blockquote><p>3.2 ls-l:查看某一个目录会得到一个7个字段的列表。</p></blockquote><h4 id="alias：设置命令的别名"><a href="#alias：设置命令的别名" class="headerlink" title="alias：设置命令的别名"></a><code>alias</code>：设置命令的别名</h4><p><code>alias [别名]=‘指令名称’ </code>，等于号左右不能有空格，指令名称必须是可执行的完整的命令；</p><p>参数：若不加任何参数，则列出目前所有的别名设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> 命令别名      <span class="hljs-comment">#查看别名</span><br><br><span class="hljs-built_in">unalias</span> 命令别名   <span class="hljs-comment">#取消命令别名</span><br></code></pre></td></tr></table></figure><h4 id="du-选项-文件或目录"><a href="#du-选项-文件或目录" class="headerlink" title="du [选项] [文件或目录...] \"></a><code>du [选项] [文件或目录...] </code>\</h4><p>统计指定目录（或文件）所占用磁盘空间的大小。</p><p>有-a,-s,-h,-c,–math-depth&#x3D;n等选项，要用自己查</p><h4 id="修改权限命令：chmod"><a href="#修改权限命令：chmod" class="headerlink" title="修改权限命令：chmod"></a>修改权限命令：<code>chmod</code></h4><p>命令格式：<code>chmod [ugoa][+-=][rwx]文件或目录 </code>；<br>或用数字表示：<code>chmod [777] </code>文件或目录 ，默认为操作所有用户a；</p><p> 常用格式： <code>-R</code>：递归修改指定目录下所有子项的权限；</p><h4 id="设置目录和文件的默认权限-umask"><a href="#设置目录和文件的默认权限-umask" class="headerlink" title="设置目录和文件的默认权限 umask"></a>设置目录和文件的默认权限 <code>umask</code></h4><p>umask查看：umask<br>umask设置：umask 000，umask 022 #新建目录或者文件，再查看权限</p><p>umask（权限反码） 作用：</p><ul><li>控制新建的文件或者目录的权限默认值</li><li>默认权限去除umask的权限为新建的文件或者目录的权限</li></ul><p>新建的文件或者目录的权限为默认最大权限减去umask权限。<br>umask 默认值为 <code>022</code>，普通文件的最大默认权限.为 <code>666</code>，目录的最大默认权限为 <code>777</code>;</p><h4 id="ln"><a href="#ln" class="headerlink" title="ln - \"></a><code>ln -</code> \</h4><p>为文件或目录创建链接文件，在文件之间建立连接。</p><p>链接文件类型：</p><ul><li>软链接（符号链接）(symbolic link):产生一个特殊的档案，该档案的内容是指向另一个档案的位置</li><li>硬链接(hard link):一个档案可以有多个文件名（一个文件可以有好几个文件名，只有将最后一个文件名从 磁盘上删除，才能把这个文件删掉）</li></ul><p>知识点：<br>参考：<a href="https://blog.csdn.net/duanbaoke/article/details/115485100">https://blog.csdn.net/duanbaoke/article/details/115485100</a></p><ul><li>在Linux中，文件名和文件类型是分开存储的，</li><li>在Linux中，只有文件的<code>硬链接数==0</code> 才会被删除</li><li>使用 ls -l 可以查看一个文件的硬链接数量<br>在日常工作中，几乎不会创建文件的硬链接，只有超级用户才能建立目录的硬连接。</li><li>硬链接是存在同一个档案系统中，而软链接却可以跨越不同的档案系统</li><li>ln- 在文件间产生连接。默认产生硬链接，有-s选项，则产生软链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">创建硬链接：<span class="hljs-built_in">ln</span> 源文件 目标位置<br><span class="hljs-built_in">ln</span> -s 源文件或目录名... 链接文件或目标位置<br></code></pre></td></tr></table></figure></li></ul><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h4><p>将需要复制的文件或目录（源）重建一份，并保存为新的文件或目录。</p><p><code>cp[选项]...源文件或目录.…目标文件或目录...</code><br>-f,-i,-p,-r四个选项。<br>注：复制多个文件或目录时，目标位置必须是目录，且目标目录必须已存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -p test.rb /home/test <br><span class="hljs-comment">#将test.rb copy到test目录，并且保留原文件的属性</span><br><br><span class="hljs-built_in">cp</span> -p test.rb /home/test/haha.rp  <br><span class="hljs-comment">#将test.rb copy到test目录，并将文件名修改为haha.rp</span><br><br><span class="hljs-built_in">cp</span> -r Dir/ /home/test      <br><span class="hljs-comment">#将Dir目录copy到test目录下</span><br><br><span class="hljs-built_in">cp</span> -fr Dir/* /home/test    <br><span class="hljs-comment">#将Dir下面的所有文件强制copy到test目录下</span><br><br><span class="hljs-built_in">cp</span> /root/&#123;1,2,3&#125;.txt ./    <br><span class="hljs-comment">#批量复制三个同扩展文件到当前目录</span><br><br><span class="hljs-built_in">cp</span> test.rb&#123;,.bak&#125;          <br><span class="hljs-comment">#备份test.rb，并在尾部加上.bak后缀</span><br></code></pre></td></tr></table></figure><h4 id="rm-删除-unlink-文件"><a href="#rm-删除-unlink-文件" class="headerlink" title="rm :删除 (unlink) 文件"></a><code>rm</code> :删除 (unlink) 文件</h4><p>常用选项：-f,-i,-r</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> test.php        <span class="hljs-comment">#删除文件需要确认</span><br><br><span class="hljs-built_in">rm</span> -f test.php     <span class="hljs-comment">#强制删除文件不确认</span><br><br><span class="hljs-built_in">rm</span> -rfv ./test     <span class="hljs-comment">#递归强制删除当前的test目录，并显示删除的详细过程</span><br><br><span class="hljs-built_in">rm</span> -rf aa/         <span class="hljs-comment">#递归强制删除aa目录下的所有</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>删除文件可以直接使用 rm 命令，若删除目录则必须配合选项 “ -r “，因为目录下有 . 和 .. 两个隐藏子目录；</li><li>不要直接删除系统中已有的目录或配置文件，以避免出现意外故障；</li><li>删除目录下文件时建议最好先切换到目录下再执行 rm -rf 命令 <br>（ 1 . cd aa 2 . rm -rf aa&#x2F;）</li></ul><h4 id="mv：-移动文件或目录、对单个文件进行重命名。"><a href="#mv：-移动文件或目录、对单个文件进行重命名。" class="headerlink" title="mv： 移动文件或目录、对单个文件进行重命名。\"></a><code>mv</code>： 移动文件或目录、对单个文件进行重命名。\</h4><p><code>mv [选项] 源文件或目录 目标文件或目录</code></p><ul><li>将指定的文件或目录转移位置；</li><li>如果目标位置与源位置相同，则相当于重命名操作。</li></ul><h4 id="rename-批量修改文件名"><a href="#rename-批量修改文件名" class="headerlink" title="rename:批量修改文件名"></a><code>rename</code>:批量修改文件名</h4><p><code>rename 旧字符 新字符 文件名</code><br><code>rename 旧文件 新文件 目标文件</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">rename</span> <span class="hljs-keyword">abc</span> def <span class="hljs-keyword">abc</span>    # 修改 <span class="hljs-keyword">abc</span> 名字为 dec<br></code></pre></td></tr></table></figure><h4 id="tree：在终端输入下面的指令查看文件结构"><a href="#tree：在终端输入下面的指令查看文件结构" class="headerlink" title="tree：在终端输入下面的指令查看文件结构"></a><code>tree</code>：在终端输入下面的指令查看文件结构</h4><p>安装tree:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> tree<br></code></pre></td></tr></table></figure><h3 id="仓库克隆"><a href="#仓库克隆" class="headerlink" title="仓库克隆"></a>仓库克隆</h3><p> linux 系统下 <code>github 仓库的克隆</code>可以直接在终端通过指令克隆。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ttroy50/</span>cmake-examples.git cmake-examples<br></code></pre></td></tr></table></figure><p>第一行是跳转至 home 目录，第二行是将github链接地址的内容克隆到 cmake-example 目录下，输入后会自动新建一个cmake-example 目录并把下载的代码放进去，十分方便。</p><h3 id="linux设置串口别名"><a href="#linux设置串口别名" class="headerlink" title="linux设置串口别名"></a>linux设置串口别名</h3><p><a href="https://blog.csdn.net/beiguodexueCSDN/article/details/103099456">https://blog.csdn.net/beiguodexueCSDN/article/details/103099456</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>my technology stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相机标定</title>
    <link href="/2023/07/25/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <url>/2023/07/25/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>几步完成相机标定！（图传也有相机，也可以标定）</p><span id="more"></span> <ul><li>step 1:打印标定板（不能有折痕，要哑光纸打印，A3大小），贴在碳板上，一定要平整。</li><li>step 2:用需要标定的相机拍照，设定好需要的分辨率，拍20-30张不同角度的标定板照片，要求标定板要占大部分相片区域（80%以上）</li><li>step 3:使用matlab进行标定。<br>关于options：<ul><li>(1)Radial Distortion：径向畸变<br> 2 Coefficients选项:使用四次多项式来估计透镜的径向畸变,适用于一般相机<br> 3 Coefficients选项:使用六次多项式来估计透镜的径向畸变,仅适用于大视场相机</li><li>(2)Compute：<br> 关于Skew:假设X轴和Y轴不垂直。这意味着图像像素不是矩形的。所以，Skew选项一般不需要选择<br> 关于Tangential Distortion：当镜头的主轴与相机传感器不垂直时，会发生切向失真<br><code>选择options的要求是使平均误差尽量小，低于0.5为可用</code></li></ul></li><li>step 4：将matlab标定得到的畸变参数写成opencv可用的畸变系数的排列（k<sub>1</sub>,k<sub>2</sub>,p<sub>1</sub>,p<sub>2</sub>,k<sub>3</sub>）,其中三个径向畸变，两个切向畸变<ul><li>RadialDistortion里面的两个参数对应k<sub>1</sub>和k<sub>2</sub>，k<sub>3</sub>为0（对于鱼眼镜头等径向畸变特别大的才需要计算k3）</li><li>TangentialDistortion里面的两个参数对应p<sub>1</sub>,p<sub>2</sub></li><li>记录大疆图传相机数据：<br>  畸变系数：（-0.285400532140372、0.106341621768377、 0、0、   -0.0203255154424868）<br>  内参矩阵:(matlab直接计算得到)<br>$$\begin{matrix}<br>870.536594077599&amp;0&amp;0\<br>0&amp;871.002811118890&amp;0\<br>959.879173875982&amp;554.055610210946&amp;1\<br>\end{matrix}$$<br>需要将上方的内参矩阵转置之后才能给opencv使用：<br>$$\begin{matrix}<br>870.536594077599&amp;0&amp;959.879173875982\<br>0&amp;871.00281111889&amp;554.055610210946\<br>0&amp;0&amp;1\<br>\end{matrix}$$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim</title>
    <link href="/2023/07/25/vim/"/>
    <url>/2023/07/25/vim/</url>
    
    <content type="html"><![CDATA[<p>vim共分为3种模式，分别是<code>命令模式</code>、<code>输入模式</code>、<code>底线命令模式</code>。</p><span id="more"></span> <h4 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1. 命令模式"></a>1. 命令模式</h4><p>启动vim，默认进入命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。<br>常用命令：</p><ul><li><code>i</code> 切换到输入模式，以输入字符。</li><li><code>x</code> 删除当前光标所在处的字符。</li><li><code>:</code> 切换到底线命令模式，以在最底一行输入命令。</li></ul><h4 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2. 输入模式"></a>2. 输入模式</h4><p>正常输入即可。<br>按<code>ESC</code>退出输入模式，切换到命令模式。</p><h4 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3. 底线命令模式"></a>3. 底线命令模式</h4><p>在命令模式下按下 <code>:</code>（英文冒号）进入底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，基本命令（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li><li>wq 保存并退出<br>按<code>ESC</code>退出底线命令模式。</li></ul><h4 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h4><p>step1 :在终端输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vim</span> runoob.txt<br></code></pre></td></tr></table></figure><p>使用vim建立一个名为 runoob.txt 的文件。<br>直接输入 vim 文件名 就能够进入 vi 的一般模式了。<br><code>记得 vi 后面一定要加文件名，不管该文件存在与否！</code></p><p>step 2:按<code>i</code>进入编辑模式，编辑文件内容</p><p>step 3:按<code>ESC</code>退出编辑模式</p><p>step 4：按<code>:wq</code>保存退出</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>some tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>creat your own blogs</title>
    <link href="/2023/07/25/creat-your-own-blogs/"/>
    <url>/2023/07/25/creat-your-own-blogs/</url>
    
    <content type="html"><![CDATA[<p>通过github创建自己的博客</p><span id="more"></span> <p><a href="https://blog.csdn.net/Dabie_haze/article/details/117407833/">https://blog.csdn.net/Dabie_haze/article/details/117407833\</a><br><a href="https://zhuanlan.zhihu.com/p/111614119">https://zhuanlan.zhihu.com/p/111614119</a></p><p>补充：</p><ul><li>安装npm的教程：<br><a href="https://blog.csdn.net/yyuggjggg/article/details/120836231#:~:text=1.%E5%8F%8C%E5%87%BB%202%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%203%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%204%EF%BC%9A%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E4%B8%80%E6%AD%A5,5%E7%82%B9%E5%87%BBnext%EF%BC%8C%E5%85%B6%E4%BA%92%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%206.%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%80%E7%9B%B4%E6%98%AF%E2%80%9Cnext%E2%80%9D%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%9C%80%E5%90%8E%E7%82%B9%E5%87%BBfinish%207.%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%208.%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%AD%A3%E5%B8%B8">https://blog.csdn.net/yyuggjggg/article/details/120836231#:~:text=1.%E5%8F%8C%E5%87%BB%202%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%203%EF%BC%9A%E6%8C%89%E5%A6%82%E4%B8%8B%E6%93%8D%E4%BD%9C%204%EF%BC%9A%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E4%B8%80%E6%AD%A5,5%E7%82%B9%E5%87%BBnext%EF%BC%8C%E5%85%B6%E4%BA%92%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%206.%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%80%E7%9B%B4%E6%98%AF%E2%80%9Cnext%E2%80%9D%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%9C%80%E5%90%8E%E7%82%B9%E5%87%BBfinish%207.%E6%9F%A5%E7%9C%8B%E5%90%84%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%208.%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%AD%A3%E5%B8%B8</a></li><li>npm使用国内淘宝镜像的方法：<br><a href="https://blog.csdn.net/DongShanYuXiao/article/details/129902599">https://blog.csdn.net/DongShanYuXiao/article/details/129902599</a></li><li>获取&#x2F;更新SSH：<br><a href="https://blog.csdn.net/qq_36667170/article/details/79094257">https://blog.csdn.net/qq_36667170/article/details/79094257</a></li><li>Hexo初始化报错：</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">fatal: could not <span class="hljs-keyword">create</span> <span class="hljs-keyword">work</span> tree dir <span class="hljs-string">&#x27;C:\Program Files\Hexo_blog\hexo\ZoeChen04616.github.io&#x27;</span>: Permission denied<br><br></code></pre></td></tr></table></figure><p>是权限不够，不能新建文件夹所以不能建立工作目录。在文件夹属性-安全-user找写入权限添加上就好。</p><ul><li><p>Hexo部署时报错：Error: Spawn failed<br> <a href="https://blog.csdn.net/qq_45020818/article/details/126949337">https://blog.csdn.net/qq_45020818/article/details/126949337</a> </p></li><li><p>关于hexo博客更换主题：<br><a href="https://zhuanlan.zhihu.com/p/385525053">https://zhuanlan.zhihu.com/p/385525053</a></p></li><li><p>一些主题推荐：<br><a href="https://zhuanlan.zhihu.com/p/137679728/">https://zhuanlan.zhihu.com/p/137679728\</a><br><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></li><li><p>hexo常用口令：</p><ul><li><code>hexo clean</code> : 清除缓存</li><li><code>hexo g</code>：生成静态网页</li><li><code>hexo d</code>：同步远程github仓库</li><li><code>hexo s</code>：本地预览效果</li><li><code>hexo new post &quot;article title&quot;</code> ： 新建一篇文章</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>some skills about web</tag>
      
      <tag>hexo</tag>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积累向的视觉小知识</title>
    <link href="/2023/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%A7%86%E8%A7%89%E6%95%99%E7%A8%8B/"/>
    <url>/2023/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%A7%86%E8%A7%89%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>没有特定的主题，遇到有啥不会的就往里补充。</p><span id="more"></span> <h4 id="1-O1-O2-O3-Os优化（gcc）"><a href="#1-O1-O2-O3-Os优化（gcc）" class="headerlink" title="1.-O1,-O2,-O3,-Os优化（gcc）"></a>1.-O1,-O2,-O3,-Os优化（gcc）</h4><ol><li><p>使用-Q –help &#x3D;optimizers来获取每个优化标识所启用的优化选项。</p></li><li><p>解释：</p><blockquote><ol><li>-O，-O1：</li></ol></blockquote></li></ol><p>这两个命令的效果是一样的，目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。</p><blockquote><ol start="2"><li>-O2:</li></ol></blockquote><p>该优化选项会牺牲部分编译速度，除了执行-O1所执行的所有优化之外，还会采用几乎所有的目标配置支持的优化算法，用以提高目标代码的运行速度。</p><blockquote><ol start="3"><li>-O3:</li></ol></blockquote><p>该选项除了执行-O2所有的优化选项之外，一般都是采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等。</p><p>这个选项会提高执行代码的大小，当然会降低目标代码的执行时间。</p><blockquote><ol start="4"><li>-Os:</li></ol></blockquote><p>这个优化标识和-O3有异曲同工之妙，当然两者的目标不一样，-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。为了降低目标代码大小，会禁用下列优化选项，一般就是压缩内存中的对齐空白(alignment padding)</p><blockquote><ol start="5"><li>-Ofast:</li></ol></blockquote><p>该选项将不会严格遵循语言标准，除了启用所有的-O3优化选项之外，也会针对某些语言启用部分优化。如：-ffast-math </p><blockquote><ol start="6"><li>-Og:</li></ol></blockquote><p>该标识会精心挑选部分与-g选项不冲突的优化选项，当然就能提供合理的优化水平，同时产生较好的可调试信息和对语言标准的遵循程度。</p><h4 id="2-动态连接库-共享库-和静态连接库"><a href="#2-动态连接库-共享库-和静态连接库" class="headerlink" title="2.动态连接库(共享库)和静态连接库"></a>2.动态连接库(共享库)和静态连接库</h4><p>1.静态链接库 <code>＊.a</code><br>将需要调用的函数统一链接到可执行文件中，成为可执行文件的一部分。</p><ul><li>优点：<br>运行速度快（因为已经链接到可执行文件中了）<br>不需要重新编译代码就可以链接<br>(因为已经和可执行文件链接在一起了，可执行文件调用链接库时可以直接跳转)</li><li>缺点：<br>占用内存，当多个程序调用相同的函数时，内存中就会存在该函数的多个备份</li></ul><p>2.动态链接库 <code>＊.so</code><br>仅加入被调函数的描述信息，当程序执行时由运行链接加载库。<br>仅当被装入内存时，才开始运行。相对于静态链接库，动态链接库只会在内存中保留一份。</p><ul><li>优点：不占用内存；可以实现进程之间的资源共享。<br>（因此动态库也称为共享库） </li><li>缺点：速度比静态的慢</li></ul><h4 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h4><ol><li>定义：在操作系统中用来指定操作系统运行环境的一些参数，要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。<br>用户通过设置环境变量，来更好的运行进程。</li></ol><ul><li>windows系统中的环境变量：PATH<br>可以直接在终端输入echo %PATH%查看系统所有的环境变量</li><li>linux系统中的环境变量： export<br>可以直接在终端输入export查看系统所有的环境变量</li><li>暂时不管CMakeLists里面的环境变量</li></ul><ol start="2"><li>linux中，添加路径到环境变量里面的方法：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">echo <span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;~/.aspera/connect/bin/:<span class="hljs-variable">$PATH</span>&quot;</span> &gt;&gt;.bashrc<br></code></pre></td></tr></table></figure>即，添加到.bashrc的脚本中。（也可以用vim直接编辑.bashrc内容）</li></ol><ul><li><p>.bashrc是一个配置文件，也是一个隐藏文件，存在于用户的家目录~下，需要用<code>ls -a</code>才能查看到，每次登陆bash，这个文件就会被执行一次，在文件内的代码会被运行一遍。<br>参考：<a href="https://cloud.tencent.com/developer/article/1457751">https://cloud.tencent.com/developer/article/1457751</a></p></li><li><p>bash: 终端的那个框</p></li><li><p>echo 输出命令</p></li><li><p><code>&gt;&gt;</code>表示一个类似管道的意思</p></li></ul><h4 id="4-opencv配置环境"><a href="#4-opencv配置环境" class="headerlink" title="4.opencv配置环境"></a>4.opencv配置环境</h4><p>查看UGAS的opencv配置，后面新建项目如果要使用opencv，直接将.props文件复制粘贴到项目文件夹，再在VS里面<code>添加现有属性表</code>即可。</p><h4 id="5-分辨率"><a href="#5-分辨率" class="headerlink" title="5.分辨率"></a>5.分辨率</h4><p>分辨率只是数学上的一个概念，跟任何设备无关。<br>它仅仅是用来表示横向和纵向有多少个像素点而已，可以粗略理解为图片的尺寸以及清晰度。<br>参考：<a href="https://zhuanlan.zhihu.com/p/424498440">https://zhuanlan.zhihu.com/p/424498440</a><br> （分辨率？1080P、2K、4K?英寸？）</p><h4 id="6-image-distorition：图像畸变"><a href="#6-image-distorition：图像畸变" class="headerlink" title="6. image distorition：图像畸变"></a>6. image distorition：图像畸变</h4><h4 id="7-oop-python面向对象编程"><a href="#7-oop-python面向对象编程" class="headerlink" title="7. oop: python面向对象编程"></a>7. oop: python面向对象编程</h4><h4 id="8-markdown怎么写下标：例如k1"><a href="#8-markdown怎么写下标：例如k1" class="headerlink" title="8. markdown怎么写下标：例如k1"></a>8. markdown怎么写下标：例如k<sub>1</sub></h4><h4 id="9-markdown怎么表示矩阵："><a href="#9-markdown怎么表示矩阵：" class="headerlink" title="9.markdown怎么表示矩阵："></a>9.markdown怎么表示矩阵：</h4><p>$$\begin{matrix}<br>0&amp;1&amp;1\<br>1&amp;1&amp;0\<br>1&amp;0&amp;1\<br>\end{matrix}$$</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/25/hello-world/"/>
    <url>/2023/07/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This is my very first post. </p><span id="more"></span> <p>I hope the blogs can record my learning journey, and through my learning journey, I could gradually enrich my little knowledge planet.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
